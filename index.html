<!doctype html>
<html>
<head>
<title>Mandelbrot Explorer</title>
<meta name="description" content="Beautiful, fast, and accurate exploration of the Mandelbrot Set in your browser. Click to zoom. Hover to see orbits.">
<meta name="viewport" content="width=device-width">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<!--
Written by David Bau as a Javascript example in 2009; updated in 2020
to handle high device pixel ratios, show orbits, and report periodicity.
Keyboard controls added in 2022, and quad-precision added in 2024.

URL options: use ?grid=3 to select 3-column view,
                   c=-0.14-0.65i to set center,
               and s=0.5 to set viewed size.

Implementation notes.  To minimize computation, the code identifies both
points that diverge and points that converge.  It uses a method that can
identiify convergence to periodic cylces of arbitrarily long length.
After the number of unknown points is less than half the visual field,
it computes the remaining points sparsely, avoiding iterating over the
already-known points.
-->
<style>
body { font-family: Arial; background: #888; margin: 16px 0;}
td { position: relative; vertical-align: top;}
canvas { vertical-align:bottom;cursor:crosshair }
#grid > div, #text, #movie > div { display: inline-block; margin: 8px;
  position: relative; vertical-align: top }
#grid { color: yellow }
#grid > div:only-child .closebox { display: none; }
#text { text-align: left; width: 439px; max-width: 82%; background:#aaa;
  position:relative;padding:1px 4px;font-size:9pt }
.closebox { position: absolute; right: 3px; top: 0; cursor: pointer;
  transition: opacity 0.3s }
.closebox::after { content: '\00d7'; font-size: 20px; }
.closebox:hover { font-weight: bold; }
.rect { position: absolute; outline: 1px solid yellow; height: 0; width: 0;
  pointer-events: none; opacity: 0.7; transition: opacity 0.3s; }
.hidemarks .rect { opacity: 0; }
.overlay { position: absolute; pointer-events: none; opacity: 0.8;
  top:0; left:0; z-index:1; transition: opacity 0.3s }
.zoomnum { position:absolute; display:inline-block; right:0; bottom:-12px;
  text-decoration: none; font-size:12px; color: yellow; min-width: 25%;
  text-align:right; transition: opacity 0.3s; z-index: 1; cursor: pointer }
.zoomnum[href]:hover { text-decoration: underline; }
td#b_0 { background-color: navy; vertical-align: middle; }
td#b_0 p { color:white; text-align: center; font-size: 16px; }
body.hidemarks .overlay { opacity: 0; }
body.hidemarks .zoomnum { opacity: 0; }
body.hidemarks #grid .closebox { opacity: 0; }
a[status]::after { /* tooltips */
 position: absolute; bottom: -2.2rem; right: 0; width: auto;
 background-color: #ddd; color: #444; font: 9pt Arial;
 padding: 3px 7px; box-shadow: 2px 2px 5px #777;
 content: attr(status); text-align: right; white-space: pre;
 pointer-events: none; z-index: 2;
 opacity: 0; transition: opacity 0.25s ease;
}
a[status]:focus::after, a[status]:hover::after { opacity: 0.95; }
div#b_0::after { display: flex; position: absolute; top: 0; left: 0;
  width: 100%; height: 100%; align-items: center; justify-content: center;
  content:"Starting...";color:white;z-index: -1;background: rgb(32,16,64); }
</style>
</head>
<body>
<center>
<div id=grid></div>

<div id=movie></div>

<div id=text>
<div class=closebox></div>

<h4 style="margin-top:3px;margin-bottom:6px">
Javascript Mandelbrot Set Fractal Viewer
</h4>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> is iterated for each <a href="http://en.wikipedia.org/wiki/Complex_number">complex number</a> <em>c</em>.  Points are colored by <a href="http://warp.povusers.org/Mandelbrot/">counting iterations</a> to divergence; black points converge or cycle.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Click to zoom.</b>  Click zoom number to enlarge.  Right-click to save the fractal.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Yellow dots show <a href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbits</a></b>.  Red dots show limit cycles.
Details in popup.
</p>

<p style="margin-top:6px;margin-bottom:6px">
This page shows more fractal detail over time by refining iterations to infinity as you explore: the longer you wait, the more detail is shown. If you have a super-high resolution monitor like a retina display, the full resolution is used. After you zoom beyond trillion-fold magnification, a quad-precision algorithm resolves fine details to more than 30 digits of accuracy.
</p>

<p style="margin-top:6px;margin-bottom:6px">
Keys:
<b>H</b> shrinks and <b>G</b> grows the size of each field;
<b>I</b> zooms in;
<b>R</b> reopens midway windows;
<b>C</b> recenters all;
<b>U</b> highlights unfinished pixels;
<b>X</b> increases and <b>Z</b> decreases the <em>z</em> exponent;
<b>M</b> makes a movie;
<nobr><b>?</b> shows this help.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a>
</div>

</center>

<script>
// Helper function to convert a regular number to quad-precision
function toQd(x) {
  return Array.isArray(x) ? x : [x, 0];
}

var vw = window.innerWidth || document.documentElement.clientWidth;
var gridcols = Math.max(1, Math.min(3, Math.floor((vw - 32) / 200)));
var exponent = 2;
var firstr = [-0.5, 0];
var firstj = [0.0, 0];
var firstsize = 3.0;
var orbitlength = 100000; // show very long orbits
var pixelRatio = Math.ceil(window.devicePixelRatio || 1);

var opts = document.location.search.split('&');
for (var j in opts) {
  var m;
  if (null !== (m = opts[j].match(/exponent=(\d+)/))) {
    exponent = Math.max(2, parseInt(m[1]));
    if (exponent > 2) { firstr = [0.0, 0]; }
    for (var el of document.getElementsByClassName('exponent')) {
      el.innerText = exponent;
    }
  }
  if (null !== (m = opts[j].match(/grid=(\d+)/))) {
    gridcols = Math.max(1, parseInt(m[1]));
  }
  if (null !== (m = opts[j].match(/c=([-+]?\d?\.?\d+)(?:([-+]\d?\.\d+)i)?/))) {
    firstr = qdParse(m[1]);
    firstj = qdParse(m[2] || 0);
  }
  if (null !== (m = opts[j].match(/s=([-+]?\d?\.?\d+(?:e[-+]\d+)?)/))) {
    firstsize = parseFloat(m[1]);
  }
  if (null !== (m = opts[j].match(/pixelratio=(\d+)/))) {
    pixelRatio = Math.max(1, parseInt(m[1]));
  }
}

var cssDims = Math.max(32,
  Math.floor((vw - 48) / gridcols) - 16);
var dims = Math.floor(cssDims * pixelRatio);
var dims2 = dims * dims;

function grid() {
  return document.getElementById('grid');
}

var it = [];  // the current iteration num
var cc = [];  // the constant at every pixel
var zz = [];  // the current iterate value
var bb = [];  // the recent value at iteration r
var pp = [];  // the point at which the value was first closer than epsilon2
var nn = [];  // the number of iterations until divergence (or convergence, neg)
var un = [];  // number of uncomputed pixels
var di = [];  // number of known diverged pixels
var hi = [];  // history of up to 256 of [uncomputed, iter]
var ss = [];  // list of uncomputed indexes
var fi = [];  // 1 if finished.
var sizes = [];
var gridboards = 0;
var steps = 0;
var ukcs = ["rgb(32,16,64)", "#888", "#fff", "yellow", "red", "#000"];
var unknowncolor = ukcs[0];

function updateGridLayout(newColumns) {
  gridcols = Math.max(1, newColumns);
  cssDims = Math.max(32, Math.floor((vw - 48) / gridcols) - 16);
  dims = Math.floor(cssDims * pixelRatio);
  dims2 = dims * dims;
  var hidden = [];
  for (let k = 0; k < sizes.length; k++) {
    hidden.push(hiddenboard(k));
  }

  // Recreate the grid
  var gridElement = grid();
  gridElement.innerHTML = '';
  gridboards = 0;

  // Recreate all boards
  for (let k = 0; k < sizes.length; k++) {
    setboard(k, sizes[k][0], sizes[k][1], sizes[k][2]);
    makeboard(k);
    draw(k);
    if (hidden[k]) { hideboard(k); }
  }
  updateZoomRectangles();
}

function updateExponent(newExponent) {
  if (newExponent < 2) { return; }
  exponent = newExponent;
  for (var el of document.getElementsByClassName('exponent')) {
    el.innerText = exponent;
  }
  truncateboards(1);
  removeboardspast(0);
  if (firstsize == 3) {
    firstr = [exponent > 2 ? 0.0 : -0.5, 0];
    firstj = [0.0, 0];
  }
  setboard(0, firstsize, firstr, firstj);
  makeboard(0);
  draw(0);
  clearseq(0);
  updateZoomRectangles();
}

function updateZoomRectangles() {
  let prevBoard = null;
  let prevK = 0;
  for (let k = 0; k < sizes.length; k++) {
    if (hiddenboard(k)) { continue; }
    let currBoard = sizes[k];
    if (prevBoard != null) {
      let x = (currBoard[1][0] - prevBoard[1][0]) / prevBoard[0] + 0.5;
      let y = 0.5 - (currBoard[2][0] - prevBoard[2][0]) / prevBoard[0];
      let zf = prevBoard[0] / currBoard[0];
      showrect(prevK, x, y, zf);
    }
    prevBoard = currBoard;
    prevK = k;
  }
}

function cycle(m, z, c, p) {
  var len = figureperiod(p[m]);
  return suborbit(m, z, c, len);
}

function orbit(m, c, len) {
  return suborbit(m, c, c, len);
}

function suborbit(m, z, c, len) {
  var m2 = m * 2;
  var m2i = m2 + 1;

  // Always convert to quad precision
  var r = toQd(z[m2]);
  var j = toQd(z[m2i]);
  var cr = toQd(c[m2]);
  var cj = toQd(c[m2i]);

  var result = [r[0], r[1], j[0], j[1]];
  while (result.length < len * 4) {
    var j2 = qdSquare(j);
    var ja = qdMul(qdDouble(r), j);
    var r2 = qdSquare(r);
    var ra = qdSub(r2, j2);
    for (let ord = 2; ord < exponent; ord++) {
      let rt = qdSub(qdMul(r, ra), qdMul(j, ja));
      ja = qdAdd(qdMul(r, ja), qdMul(j, ra));
      ra = rt;
    }
    r = qdAdd(ra, cr);
    j = qdAdd(ja, cj);
    result.push(r[0], r[1], j[0], j[1]);
  }
  return result;
}

function compute(m, i, n, z, c, b, p, epsilon, epsilon2) {
  if (n[m]) return 0;
  let m2 = m * 2;
  let m2i = m2 + 1;
  let useQuad = Array.isArray(z[0]);

  let r, j, r2, j2, ra, ja, rb, jb, db;

  if (useQuad) {
    r = z[m2]
    j = z[m2i]

    let r2 = qdSquare(r);
    let j2 = qdSquare(j);
    if (qdGt(qdAdd(r2, j2), 4)) {
      n[m] = i;
      return 1;
    }
    ra = qdSub(r2, j2);
    ja = qdMul(qdDouble(r), j);
    for (let ord = 2; ord < exponent; ord++) {
      let rt = qdSub(qdMul(r, ra), qdMul(j, ja));
      ja = qdAdd(qdMul(r, ja), qdMul(j, ra));
      ra = rt;
    }
    ra = qdAdd(ra, c[m2]);
    ja = qdAdd(ja, c[m2i]);
    z[m2] = ra;
    z[m2i] = ja;
    rb = b[m2];
    jb = b[m2i];
    db = qdAdd(qdAbs(qdSub(rb, ra)), qdAbs(qdSub(jb, ja)));
    db = db[0] + db[1];
  } else {
    r = z[m2];
    j = z[m2i];
    r2 = r * r;
    j2 = j * j;
    if (r2 + j2 > 4.0) {
      n[m] = i;
      return 1;
    }
    ra = r2 - j2;
    ja = 2 * r * j;
    for (let ord = 2; ord < exponent; ord++) {
      let rt = r * ra - j * ja;
      ja = r * ja + j * ra;
      ra = rt;
    }
    ra += c[m2];
    ja += c[m2i];
    z[m2] = ra;
    z[m2i] = ja;
    rb = b[m2];
    jb = b[m2i];
    db = Math.abs(rb - ra) + Math.abs(jb - ja);
  }

  if (db <= epsilon2) {
    if (!p[m]) { p[m] = i; }
    if (db <= epsilon) {
      n[m] = -i;
      return -1;
    }
  }
  return 0;
}

function iterate(k) {
  var i = ++it[k];  // total iteration count
  var z = zz[k];    // current iterate for each pixel
  var c = cc[k];    // current constant for each pixel
  var n = nn[k];    // number of iterations before conv/divergence
  var b = bb[k];    // recent remembered z
  var p = pp[k];    // iteration at which converged within epsilon2
  var s = ss[k];    // speedy list of indexes to compute
  var pix = sizes[k][0] / dims;  // current for quad-precision check
  var epsilon = Math.min(1e-12, pix);
  var epsilon2 = Math.min(1e-9, pix * 10000);
  // head and tail factor i into an odd num and largest power of 2.
  var head = i, tail = 1;
  while ((head & 1) == 0) { head >>= 1; tail <<= 1; }
  if (s === null && un[k] <= z.length / 4) {
    var news = [];
    for (var m = 0; m < dims2; ++m) {
      if (n[m]) continue;
      news.push(m);
    }
    s = ss[k] = news;
  }
  if (s === null) {
    if (head <= tail) {
      for (var m = 0; m < dims2; ++m) {
        if (n[m]) continue;
        b[m * 2] = z[m * 2];
        b[m * 2 + 1] = z[m * 2 + 1];
        p[m] = 0;
      }
    }
    var count = 0, diverged = 0, a;
    for (var m = 0; m < dims2; ++m) {
      a = compute(m, i, n, z, c, b, p, epsilon, epsilon2);
      if (a) { count += 1; }
      if (a > 0) { diverged += 1; }
    }
    un[k] -= count;
    di[k] += diverged;
  } else {
    if (s.length > un[k] * 1.25) {
      var news = [];
      for (var t = 0; t < s.length; ++t) {
        if (n[s[t]]) continue;
        news.push(s[t]);
      }
      s = ss[k] = news;
    }
    if (head <= tail) {
      for (var t = 0; t < s.length; ++t) {
        var m = s[t];
        if (n[m]) continue;
        b[m * 2] = z[m * 2];
        b[m * 2 + 1] = z[m * 2 + 1];
        p[m] = 0;
      }
    }
    var count = 0, diverged = 0, a;
    for (var t = 0; t < s.length; ++t) {
      a = compute(s[t], i, n, z, c, b, p, epsilon, epsilon2);
      if (a) { count += 1; }
      if (a > 0) { diverged += 1; }
    }
    un[k] -= count;
    di[k] += diverged;
  }
  if (hi[k][0][0] - un[k] >= dims2 / 256) {
    hi[k].unshift([un[k], di[k], i]);
  }
  if (!fi[k] && un[k] != dims2) {
    fi[k] = i;
  }
}

function setboard(k, size, re, im) {
  while (it.length <= k) {
    it.push(0);
    fi.push(0);
    zz.push([]);
    cc.push([]);
    nn.push([]);
    bb.push([]);
    pp.push([]);
    ss.push(null);
    sizes.push([0, 0, 0]);
    un.push(dims2);
    di.push(0);
    hi.push([[dims2, 0]]);
  }
  sizes[k] = [size, toQd(re), toQd(im)];
  it[k] = 1;
  var c = cc[k] = [];
  var n = nn[k] = [];
  var p = pp[k] = [];
  ss[k] = null;
  un[k] = dims2;
  di[k] = 0;
  hi[k] = [[dims2, 0, 1]];

  var useQuad = size / dims < 1e-15;

  for (var y = 0; y < dims; y++) {
    var jFrac = (0.5 - (y / dims));
    var j = (useQuad
        ? qdAdd(toQd(im), qdMul(toQd(jFrac), toQd(size)))
        : jFrac * size + im[0]);

    for (var x = 0; x < dims; x++) {
      var rFrac = ((x / dims) - 0.5);

      if (useQuad) {
        var r = qdAdd(toQd(re), qdMul(toQd(rFrac), toQd(size)));
        c.push(r, j);
        var r2j2 = qdAdd(qdMul(r, r), qdMul(j, j));
        if (qdGt(r2j2, 4)) {
          n.push(1);
          p.push(0);
          un[k] -= 1;
        } else {
          n.push(0);
          p.push(0);
        }
      } else {
        var r = rFrac * size + re[0];
        c.push(r, j);
        if (r * r + j * j > 4) {
          n.push(1);
          p.push(0);
          un[k] -= 1;
        } else {
          n.push(0);
          p.push(0);
        }
      }
    }
  }
  zz[k] = c.slice();
  bb[k] = c.slice();
  fi[k] = (un[k] == dims2 ? 0 : 1);
}

function truncateboards(k) {
  if (it.length > k) {
    it.length = k;
    zz.length = k;
    cc.length = k;
    nn.length = k;
    un.length = k;
    sizes.length = k;
  }
}

function clearseq(k) {
  var ctx = overlay(k).getContext('2d');
  ctx.clearRect(0, 0, dims, dims);
}

function showseq(k, seq, color) {
  var ctx = overlay(k).getContext('2d');
  ctx.fillStyle = color;
  var sc = sizes[k];
  var s = sc[0];
  var cr = sc[1];
  var cj = sc[2];
  for (var i = 0; i < seq.length; i += 4) {
    var r = [seq[i], seq[i+1]];
    var j = [seq[i+2], seq[i+3]];
    var x = qdMul(qdSub(r, cr), [dims/s, 0]);
    var y = qdMul(qdSub(cj, j), [dims/s, 0]);
    x = x[0] + dims/2;
    y = y[0] + dims/2;
    if (x >= 0 && y >= 0 && x < dims && y < dims) {
      ctx.beginPath();
      ctx.arc(x, y, 1 * pixelRatio, 0, 2 * Math.PI, false);
      ctx.fill();
    }
  }
}

function drawcolor(k, i) {
  var color = makecolor(k, i);
  var converged = makecolor(k, -i);
  var n = nn[k];
  var ctx = board(k).getContext('2d');
  for (var m = 0; m < dims2; ++m) {
    if (n[m] == i || n[m] == -i) {
      var x = m % dims;
      var y = (m - x) / dims;
      ctx.fillStyle = n[m] > 0 ? color : converged;
      ctx.fillRect(x, y, 1, 1);
    }
  }
}

function clearboard(k) {
  var ctx = board(k).getContext('2d');
  ctx.fillStyle = makecolor(k, 0);
  ctx.fillRect(0, 0, dims, dims);
}

function colornum(n) {
  if (n <= 0) { return "0"; }
  if (n < 16) { return (n * 17).toString(10); }
  return "255";
}

function intcolor(n) {
  if (n <= 0) { return "0"; }
  if (n >= 1) { return "255"; }
  return (n * 255).toString(10);
}

function makecolor(k, i) {
  if (i == 0) return unknowncolor;
  if (i < 0) return 'black';
  for (var j = 0; i < hi[k][j][2]; j += 1) {}
  var frac = (dims2 - hi[k][j][0]) / dims2; // frac of pixels done.
  var len = hi[k].length, half = Math.floor((len + j) / 2);
  var s = sizes[k][0];
  var ff = Math.pow(frac, 2);
  var fr = Math.pow(frac, 0.333);
  var fg = Math.pow(frac, 3);
  var g = intcolor(Math.max(fg, Math.min(fr, i * Math.pow(s, 0.33) / 64)));
  var r = intcolor(Math.min(fr, i * Math.pow(s, 0.22) / 64));
  var b = intcolor(ff / 3 + 0.667);
  return "rgb(" + r + "," + g + "," + b + ")";
}

function draw(k) {
  if (nn.length <= k) return;
  var n = nn[k];
  var ctx = board(k).getContext('2d');
  for (var m = 0; m < dims2; ++m) {
    var x = m % dims;
    var y = (m - x) / dims;
    ctx.fillStyle = makecolor(k, n[m]);
    ctx.fillRect(x, y, 1, 1);
  }
}

function drawall() {
  for (var k = 0; k < nn.length; ++k) {
    draw(k);
  }
}

function makeboard(k) {
  var gd = grid();
  while (gridboards <= k) {
    var dd = document.createElement('div');
    dd.id = 'b_' + gridboards;
    dd.innerHTML = boardstring(gridboards);
    dd.className = 'hidemarks';
    gd.appendChild(dd);
    gridboards += 1;
  }
}

function formatScale(scale) {
  if (scale < 10) {
    return +scale.toFixed(1) + 'x';
  } else if (scale < 100000) {
    return +scale.toFixed(0) + 'x';
  } else {
    return scale.toExponential(2);
  }
}

function boardstring(k) {
  var factor = 3.0 / (k < sizes.length ? sizes[k][0] :
    firstsize / Math.pow(zoomfactor, k));
  factor = formatScale(factor);
  return '<canvas width=' + dims + ' height=' + dims +
         ' style="height:' + cssDims + 'px;width:' + cssDims + 'px;">' +
         '</canvas>' +
         '<div class="closebox"></div>' +
         '<div class="rect"></div>' +
         '<canvas class=overlay width=' + dims + ' height=' + dims +
         ' style="height:' + cssDims + 'px;width:' + cssDims + 'px;">' +
         '</canvas>' +
         '<a class="zoomnum" href="?grid=1">' + factor + '</a>';
}

function progress() {
  if (computationPaused) {
    setTimeout(progress, 100); // Check less frequently when paused
    return;
  }
  try {
    // Contribute to every unfinished cell
    var pri = Array.from(sizes.keys())
      .filter(k => un[k] > 0 && !hiddenboard(k));
    if (steps % 2) {
      // Prioritize most unfinished half the time.
      pri = pri.sort((a, b) => un[b] - un[a]);
    } else {
      // Prioritize the most recent half the time.
      pri = pri.reverse();
    }
    // Exponential scheduling policy
    var shift = Math.floor(steps++ / 2);
    for (var p = 0; 1 << p & shift; p += 1) { }
    var k = pri[Math.min(p, pri.length)];
    // Do at least 1000 pixel-steps.
    var u = un[k];
    for (var amt = 0; u > 0 && amt < 1000; amt += (u + 1)) {
      iterate(k);
      if (un[k] < u) {
        drawcolor(k, it[k]);
        u = un[k];
      }
    }
  } catch (e) {
    console.log(e);
  }
  setTimeout(progress, 0);
}

function absoluteLeft(target) {
  var left = 0;
  while (target) {
    left += target.offsetLeft;
    target = target.offsetParent;
  }
  return left;
}

function absoluteTop(target) {
  var top = 0;
  while (target) {
    top += target.offsetTop;
    target = target.offsetParent;
  }
  return top;
}

function eventtarget(e) {
  var target = (e.target ? e.target : e.srcElement ? e.srcElement : null);
  while (target) {
    if (target.id) { return target; }
    target = target.parentNode;
  }
  return null;
}

document.onmousedown = function(e) {
  if (movieMode) { toggleMovieMode(); }
  var target = eventtarget(e);
  if (e.button != 0) { return true; }
  if (target) {
    var m = target.id.match(/b_(\d+)/);
    if (e.target.tagName == 'A') {
      e.target.href = bigurl(m[1]);
      return true;
    }
    if (m) {
      var se = document.scrollingElement || document.body;
      var x = (e.clientX + se.scrollLeft - absoluteLeft(target)) * pixelRatio;
      var y = (e.clientY + se.scrollTop - absoluteTop(target)) * pixelRatio;
      cellclick(parseInt(m[1]), x + y * dims);
      return false;
    }
  }
  return true;
}

document.onmousemove = function(e) {
  var target = eventtarget(e);
  if (target) {
    var m = target.id.match(/b_(\d+)/);
    if (m) {
      var se = document.scrollingElement || document.body;
      var x = (e.clientX + se.scrollLeft - absoluteLeft(target)) * pixelRatio;
      var y = (e.clientY + se.scrollTop - absoluteTop(target)) * pixelRatio;
      var k = parseInt(m[1]);
      var j = x + y * dims;
      var orb = [];
      var cyc = [];
      target.setAttribute('title', '');
      if (cc[k] && j >= 0 && j * 2 < cc[k].length) {
        // Convert to quad precision if necessary
        var cr = Array.isArray(cc[k][j * 2]) ? cc[k][j * 2] : [cc[k][j * 2], 0];
        var cj = Array.isArray(cc[k][j * 2 + 1]) ? cc[k][j * 2 + 1] : [cc[k][j * 2 + 1], 0];
        var title = 'c=' + formatcomplex(k, cr, cj);
        var len = Math.min(Math.max(pp[k][j], nn[k][j]) || Math.max(it[k], 8), orbitlength);
        orb = orbit(j, cc[k], len);
        if (nn[k][j]) {
          if (nn[k][j] > 0) {
            title += '\ndiverges in ' + nn[k][j];
          } else {
            var period = figureperiod(pp[k][j]);
            if (period == 1) {
              title += '\nconverges after ' + pp[k][j];
            } else {
              title += '\nafter ' + pp[k][j] + ', period ' + figureperiod(pp[k][j]);
            }
            var cyc = cycle(j, zz[k], cc[k], pp[k]);
          }
        }
        target.setAttribute('title', title);
      }
      for (var i = 0; i < sizes.length; i++) {
        if (!hiddenboard(i)) {
          clearseq(i);
          showseq(i, orb, 'yellow');
          showseq(i, cyc, 'red');
        }
      }
    }
  }
}

document.body.onkeydown = function(e) {
  if (movieMode) { toggleMovieMode(); return; }
  // Pressing backspace will delete the last zoom.
  if (e.key == 'Backspace' && sizes.length > 1) {
    var k = sizes.length - 1;
    truncateboards(k);
    removeboardspast(k - 1);
    truncatehiddenboards();
  }
  // Pressing C will center all the zoom positions.
  if (e.key == 'c' && sizes.length > 1) {
    var k = sizes.length - 1;
    var ore = sizes[k][1];
    var oim = sizes[k][2];
    showrect(0, 0.5 + (ore - sizes[0][1]) / sizes[0][0],
                0.5 - (oim - sizes[0][2]) / sizes[0][0],
                sizes[0][0] / sizes[1][0]);
    for (k = 1; k < sizes.length - 1; k += 1) {
      showrect(k, 0.5, 0.5, sizes[k][0] / sizes[k+1][0]);
      if (sizes[k][1] != ore || sizes[k][2] != oim) {
        setboard(k, sizes[k][0], ore, oim);
        clearboard(k);
        clearseq(k);
      }
    }
  }
  // Pressing U will cycle through the uncomputed colors.
  if (e.key == 'u') {
    unknowncolor = ukcs[(ukcs.indexOf(unknowncolor) + 1) % ukcs.length];
    for (var k = 0; k < nn.length; ++k) {
      drawcolor(k, 0);
    }
  }
  // Pressing I will zoom in at the same position.
  if (e.key == 'i') {
    var k = sizes.length - 1;
    if (di[k] == 0) { return; }
    var osize = sizes[k][0];
    var ore = sizes[k][1];
    var oim = sizes[k][2];
    var rre = 0.5;
    if (k == 0 && ore == -0.5 && oim == 0) {
      ore = -1.786440255563652; // Feigenbaum constant
      rre = (ore - sizes[0][1]) / sizes[0][0] + 0.5;
    }
    showrect(k, rre, 0.5, zoomfactor);
    nsize = osize / zoomfactor;
    setboard(k + 1, nsize, ore, oim);
    makeboard(k + 1);
    removeboardspast(k + 1);
    board(k + 1).parentElement.className = 'hidemarks';
    board(k + 1).parentElement.scrollIntoView({ behavior: 'smooth' });
    draw(k + 1);
  }
  // Pressing ? will show the help window
  if (e.key == '?') {
    document.getElementById('text').style.display = 'block';
  }
  // G reduces the grid column and H increases
  if (e.key === 'g' && gridcols > 1) {
    updateGridLayout(gridcols - 1);
  }
  if (e.key === 'h') {
    updateGridLayout(gridcols + 1);
  }
  // R will restore any hidden boards
  if (e.key === 'r') {
    showallboards();
  }
  // Increase the exponent
  if (e.key === 'x') {
    updateExponent(exponent + 1);
  }
  // Decrease the exponent
  if (e.key === 'z') {
    updateExponent(exponent - 1);
  }
  // Toggle movie mode
  if (e.key === 'm' && sizes.length > 1) {
    toggleMovieMode();
  }
}

document.body.onmouseover = function(e) {
  document.body.className = 'hidemarks';
  var target = eventtarget(e);
  if (target) {
    var m = target.id.match(/b_(\d+)/);
    if (m) {
      k = parseInt(m[1]);
      if (nn.length <= k) return;
      for (var i = 0; i < gridboards; ++i) {
        board(i).parentElement.className = i < k ? '' : 'hidemarks';
      }
      document.body.className = '';
      var overtarget = e.target;
      function update_progress() {
        if (overtarget.tagName == 'A') {
          overtarget.href = bigurl(k)
          overtarget.setAttribute('status', ('center at ' +
              formatcomplex(k, sizes[k][1], sizes[k][2]) + '\n'
            + Math.floor(1000 * (1.0 - un[k] / dims2))/10.0  + '% done '
            + 'after ' + it[k] + ' iters'));
        }
        if (overtarget.matches(':hover')) {
          setTimeout(update_progress, 100);
        }
      }
      update_progress();
    } else if (target.id.startsWith('movie') && e.target.id != 'movie') {
      document.body.className = '';
    }
  }
}

function figureperiod(i) {
  // Reverse the computation that was done for exponential backoff.
  var head = i, tail = 1;
  while (head > tail) { head >>= 1; tail <<= 1; }
  return i - (head * tail) + 1;
}

function formatcomplex(k, re, im) {
  var pix = sizes[k][0] / dims;
  var digits = 0;
  while (pix < 1.0) {
    pix *= 10;
    digits += 1;
  }
  var useQuad = Array.isArray(re);
  if (useQuad) {
    var ra = qdFormat(qdAbs(re)).split('e');
    var ia = qdFormat(qdAbs(im)).split('e');
    var rs = re[0] < 0.0 ? '\u2212' : '+';
    var is = im[0] < 0.0 ? '\u2212' : '+';
  } else {
    var ra = ('' + Math.abs(re)).split('e');
    var ia = ('' + Math.abs(im)).split('e');
    var rs = re < 0.0 ? '\u2212' : '+';
    var is = im < 0.0 ? '\u2212' : '+';
  }
  if (ra[0].length > digits + 2) ra[0] = ra[0].substring(0, digits + 2);
  if (ia[0].length > digits + 2) ia[0] = ia[0].substring(0, digits + 2);
  var rd = ra[0] + (ra[1] ? 'e' + ra[1] : '');
  var id = ia[0] + (ia[1] ? 'e' + ia[1] : '');
  return rs + rd + is + id + 'i';
}

function removeboardspast(k) {
  if (gridboards > k) {
    for (var j = k + 1; j < gridboards; ++j) {
      board(j).parentElement.remove();
    }
    gridboards = k + 1;
  }
}

function showboard(k) {
  board(k).parentElement.style.display = '';
}

function hideboard(k) {
  board(k).parentElement.style.display = 'none';
}

function showallboards() {
  for (var j = 0; j < gridboards; ++j) {
    showboard(j);
  }
  updateZoomRectangles();
}

function hiddenboard(k) {
  var b = board(k);
  return b && b.parentElement.style.display == 'none';
}

function truncatehiddenboards(k) {
  for (var j = gridboards - 1; j > 0; j--) {
    if (!hiddenboard(j)) {
      break;
    }
  }
  truncateboards(j + 1);
  removeboardspast(j);
  if (j == 0) {
    showboard(j);
  }
}

function board(k) {
  var b = document.getElementById("b_" + k);
  return b && b.firstElementChild;
}

function closebutton(k) {
  return board(k).nextElementSibling;
}

function rect(k) {
  return closebutton(k).nextElementSibling;
}

function overlay(k) {
  return rect(k).nextElementSibling;
}

function cellclick(k, m) {
  // Only accept clicks on cells with something computed in them.
  if (k >= sizes.length || di[k] <= 0) return;
  truncateboards(k + 2);
  removeboardspast(k + 1);
  setTimeout(function() { cellclickdelay(k, m); }, 1);
}

var zoomfactor = 5;

function cellclickdelay(k, m) {
  if (k >= sizes.length) return;
  var osize = sizes[k][0];
  var ore = sizes[k][1];
  var oim = sizes[k][2];
  cx = m % dims;
  cy = (m - cx) / dims;
  removeboardspast(k + 1);
  showrect(k, cx / dims, cy / dims, zoomfactor);
  truncateboards(k + 2);
  // Do slow parts after a moment.
  setTimeout(function() {
    nsize = osize / zoomfactor;
    nre = qdAdd(ore, [((cx / dims) - 0.5) * osize, 0]);
    nim = qdAdd(oim, [(0.5 - (cy / dims)) * osize, 0]);
    setboard(k + 1, nsize, nre, nim);
    makeboard(k + 1);
    board(k + 1).parentElement.className = 'hidemarks';
    board(k + 1).parentElement.scrollIntoView({ behavior: 'smooth' });
    draw(k + 1);
    showboard(k + 1);
  }, 10);
}

function showrect(k, x, y, zf) {
  var s = rect(k).style;
  zf = Math.min(125, zf); // Make rectangle visible if it is tiny.
  board(k).parentElement.className = '';
  s.top = (y * cssDims - cssDims / 2 / zf) + 'px';
  s.left = (x * cssDims - cssDims / 2 / zf) + 'px';
  s.width = (cssDims / zf) + 'px';
  s.height = (cssDims / zf) + 'px';
}

function bigurl(k) {
  if (k >= sizes.length) return;
  var osize = sizes[k][0];
  osize = parseFloat(osize.toPrecision(
     Math.max(2, -Math.ceil(Math.log(osize)/2.5))))
  if (exponent != 2) {
    osize += '&exponent=' + exponent;
  }
  var ore = sizes[k][1];
  var oim = sizes[k][2];
  return '?grid=1&s=' + osize + '&c=' + qdFormat(ore) +
         (qdLt(oim, 0) ? '' : '+') + qdFormat(oim) + 'i';
}

function removerect(k) {
  var s = rect(k).style;
  s.top = s.left = s.width = s.height = '';
}

let movieCanvas, movieCtx;
let movieContainer = document.getElementById('movie');
let movieMode = false;
let animationFrame = null;
let computationPaused = false;
let frameCanvases = [];

function createMovieCanvas() {
  movieContainer.innerHTML = '<div>' +
    `<canvas width=${dims} height=${dims} ` +
    `style="width:${cssDims}px;height:${cssDims}px"></canvas>` +
    `<a id="moviescale" class="zoomnum">Rendering...</a></div>`;
  movieCanvas = movieContainer.firstElementChild.firstElementChild;
  movieCtx = movieCanvas.getContext('2d');
  movieCtx.drawImage(board(0), 0, 0);
}

function removeMovieCanvas() {
  while (movieContainer.firstChild) {
    movieContainer.removeChild(movieContainer.firstChild);
  }
  movieCanvas = null;
  movieCtx = null;
}

function toggleMovieMode() {
  movieMode = !movieMode;
  computationPaused = movieMode;
  if (movieMode) {
    grid().style.display = 'none';
    movieContainer.style.display = 'block';
    createMovieCanvas();
    movieContainer.scrollIntoView({ behavior: 'smooth' });
    setTimeout(function() {
      document.body.className = '';
      preRenderFrames(function() {
        startMovieAnimation();
      });
    }, 20);
  } else {
    grid().style.display = 'block';
    movieContainer.style.display = 'none';
    stopMovieAnimation();
    removeMovieCanvas();
  }
}

function preRenderFrames(after) {
  frameCanvases = [];
  function queueOneFrame(k, after) {
    return (function () {
      document.getElementById('moviescale').textContent =
        `Rendering ${formatScale(3.0 / sizes[k][0])}`;
      let canvas1 = null;
      let canvas2 = null;
      const n = nn[k];
      // Render with k-1 palette
      if (k > 0) {
        canvas1 = document.createElement('canvas');
        canvas1.width = canvas1.height = dims;
        const ctx1 = canvas1.getContext('2d');
        for (let y = 0; y < dims; y++) {
          for (let x = 0; x < dims; x++) {
            const m = y * dims + x;
            const i = n[m];
            ctx1.fillStyle = makecolor(k - 1, i);
            ctx1.fillRect(x, y, 1, 1);
          }
        }
      }
      // Render with k+1 palette
      if (k < sizes.length - 1) {
        canvas2 = document.createElement('canvas');
        canvas2.width = canvas2.height = dims;
        const ctx2 = canvas2.getContext('2d');
        for (let y = 0; y < dims; y++) {
          for (let x = 0; x < dims; x++) {
            const m = y * dims + x;
            const i = n[m];
            ctx2.fillStyle = makecolor(k + 1, i);
            ctx2.fillRect(x, y, 1, 1);
          }
        }
      }
      frameCanvases.push({ prev: canvas1, next: canvas2 });
      setTimeout(after, 1);
    });
  }
  for (let k = sizes.length - 1; k >= 0; k--) {
    after = queueOneFrame(k, after);
  }
  setTimeout(after, 0);
}

function startMovieAnimation() {
  let frame = 0;
  let framesteps = 300;
  let endpause = 180;
  const totalFrames = (sizes.length - 1) * framesteps;
  function animate() {
    const kk = Math.min(frame, totalFrames) / framesteps;
    drawMovieFrame(kk);
    frame = (frame + 1) % (totalFrames + endpause);
    animationFrame = requestAnimationFrame(animate);
  }
  animate();
}

function stopMovieAnimation() {
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
    animationFrame = null;
  }
}

function drawMovieFrame(kk) {
  const k = Math.floor(kk);
  const t = kk - k;
  const sourceSize = sizes[k][0];
  const targetSize = k + 1 < sizes.length ? sizes[k + 1][0] : sourceSize;
  const zoomRatio = targetSize / sourceSize;
  // Use zoom ratio for exponential interpolation
  const expT = zoomRatio == 1.0 ? 1.0 :
         (Math.pow(zoomRatio, t) - 1) / (zoomRatio - 1);
  const colorT = expT * expT;
  const interpolatedSize = sourceSize * Math.pow(zoomRatio, t);
  const sourceCenter = [sizes[k][1], sizes[k][2]];
  const targetCenter = k + 1 < sizes.length ?
             [sizes[k + 1][1], sizes[k + 1][2]] : sourceCenter;
  const interpolatedCenter = [
    qdAdd(sourceCenter[0], qdMul(qdSub(targetCenter[0], sourceCenter[0]), [expT, 0])),
    qdAdd(sourceCenter[1], qdMul(qdSub(targetCenter[1], sourceCenter[1]), [expT, 0]))
  ];
  // Clear the movie canvas
  movieCtx.clearRect(0, 0, dims, dims);
  // Draw the current frame
  const scale = sourceSize / interpolatedSize;
  const offsetX = qdSub(interpolatedCenter[0], sourceCenter[0])[0] / sourceSize * dims;
  const offsetY = qdSub(sourceCenter[1], interpolatedCenter[1])[0] / sourceSize * dims;
  movieCtx.save();
  movieCtx.translate(dims / 2, dims / 2);
  movieCtx.scale(scale, scale);
  movieCtx.translate(-dims / 2 - offsetX, -dims / 2 - offsetY);
  movieCtx.globalAlpha = 1;
  movieCtx.drawImage(board(k), 0, 0);
  // Blend the color palette of the next frame
  if (frameCanvases[k].next) {
    movieCtx.globalAlpha = colorT;
    movieCtx.drawImage(frameCanvases[k].next, 0, 0);
  }
  movieCtx.restore();
  // Draw the next frame
  if (k < sizes.length - 1) {
    const targetScale = targetSize / interpolatedSize;
    const targetOffsetX = qdSub(interpolatedCenter[0], targetCenter[0])[0] / targetSize * dims;
    const targetOffsetY = qdSub(targetCenter[1], interpolatedCenter[1])[0] / targetSize * dims;
    movieCtx.save();
    movieCtx.translate(dims / 2, dims / 2);
    movieCtx.scale(targetScale, targetScale);
    movieCtx.translate(-dims / 2 - targetOffsetX, -dims / 2 - targetOffsetY);
    movieCtx.globalAlpha = 1;
    movieCtx.drawImage(frameCanvases[k + 1].prev, 0, 0);
    movieCtx.globalAlpha = colorT;
    movieCtx.drawImage(board(k + 1), 0, 0);
    movieCtx.restore();
  }
  // Update scale text
  const currentScale = (3.0 / firstsize) * (Math.pow(zoomfactor, kk));
  document.getElementById('moviescale').textContent = formatScale(currentScale);
}

function start() {
  setboard(0, firstsize, firstr, firstj);
  makeboard(0);
  draw(0);
  progress();
}

document.body.onmousedown = function(e) {
  if (e.target.className == 'closebox') {
    e.stopPropagation();
  }
}
document.body.onclick = function(e) {
  if (e.target.className == 'closebox') {
    e.target.parentElement.style.display = 'none';
    truncatehiddenboards();
    updateZoomRectangles();
  }
}

if (dims > 800) {
  makeboard(0);
  setTimeout(start, 100);
} else{
  setTimeout(start, 1);
}

//////////// quad-precision (qd, double double), aided by claude.ai ///////////

function fast2Sum(a, b) {
  let s = a + b;
  let t = b - (s - a);
  return [s, t];
}

function slow2Sum(a, b) {
  let s = a + b;
  let c = s - a;
  return [s, (a - (s - c)) + (b - c)];
}

function qdSplit(a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  return [x, y];
}

function twoProduct(a, b) {
  let p = a * b;
  let [ah, al] = qdSplit(a);
  let [bh, bl] = qdSplit(b);
  let err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  return [p, err];
}

function twoSquare(a) {
  let p = a * a;
  let [ah, al] = qdSplit(a);
  let err = ((ah * ah - p) + 2 * ah * al) + al * al;
  return [p, err];
}

function qdAdd(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [h1, h2] = slow2Sum(a1, b1);
  let [l1, l2] = slow2Sum(a0, b0);
  let [v1, v2] = fast2Sum(h1, h2 + l1);
  return fast2Sum(v1, v2 + l2);
}

function qdMul(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [p1, p2] = twoProduct(a1, b1);
  return fast2Sum(p1, p2 + a1 * b0 + b1 * a0);
}

function qdDouble(a) {
  return [a[0] * 2, a[1] * 2];
}

function qdSquare(a) {
  let [a1, a0] = a;
  let [p1, p2] = twoSquare(a1);
  return fast2Sum(p1, p2 + 2 * a1 * a0);
}

function qdNegate(a) {
  let [a1, a0] = a;
  return [-a1, -a0];
}

function qdSub(a, b) {
  return qdAdd(a, qdNegate(b));
}

function qdDiv(a, b) {
  let reciprocal = qdReciprocal(b);
  return qdMul(a, reciprocal);
}

function qdReciprocal(b, iters = 2) {
  if (b[0] === 0 && b[1] === 0) {
    return [NaN, 0];  // Return NaN for division by zero
  }
  // Refine the approximation using Newton-Raphson iteration
  let x = [1 / b[0], 0];
  for (let i = 0; i < iters; i++) {
    x = qdMul(x, qdSub([2, 0], qdMul(x, b)));
  }
  return x;
}

function qdParse(s) {
  s = s.trim().toLowerCase();
  if (s === "infinity" || s === "+infinity") return [Infinity, 0];
  if (s === "-infinity") return [-Infinity, 0];
  if (s === "nan") return [NaN, 0];
  let sign = 1;
  if (s[0] === '-') {
    sign = -1;
    s = s.slice(1);
  } else if (s[0] === '+') {
    s = s.slice(1);
  }
  let e = 0;
  let parts = s.split('e');
  if (parts.length > 1) {
    s = parts[0];
    e = parseInt(parts[1]);
  }
  let decimalPos = s.indexOf('.');
  if (decimalPos !== -1) {
    s = s.replace('.', '');
    e -= s.length - decimalPos;
  }
  s = s.replace(/^0+/, '');
  if (s === '') return [0, 0];
  let result = [0, 0];
  for (let digit of s) {
    result = qdAdd(qdMul(result, [10, 0]), [parseInt(digit), 0]);
  }
  if (e !== 0) {
    result = qdMul(result, qdPow10(e));
  }
  if (sign === -1) {
    result = qdNegate(result);
  }
  return result;
}

function qdPow10(e) {
  if (e === 0) return [1, 0];
  let result = [1, 0];
  for (let i = 0; i < Math.abs(e); i++) {
    result = qdMul(result, [10, 0]);
  }
  return (e < 0) ? qdReciprocal(result) : result;
}

function qdFloor(q) {
  let [a, b] = q;
  let fl = Math.floor(a);
  let [r0, r1] = qdSub([a, b], [fl, 0]);
  if (r0 < 0 || (r0 === 0 && r1 < 0)) {
    fl -= 1;
  }
  return [fl, 0];
}

function qdCompare(a, b) {
  if (a[0] < b[0]) return -1;
  if (a[0] > b[0]) return 1;
  if (a[1] < b[1]) return -1;
  if (a[1] > b[1]) return 1;
  return 0;
}

function qdLt(a, s) {
  return a[0] + a[1] < s;
}

function qdGt(a, s) {
  return a[0] + a[1] > s;
}

function qdAbs(q) {
  return (q[0] + q[1] < 0) ? qdNegate(q) : q;
}

function qdFixed(q, digits = 0) {
  // With fixed-point notation, digits specifies the number of digits after the decimal point.
  return qdFormat(q, digits, true);
}

const qdTen = [10, 0];

function qdFormat(q, digits = 'auto', useFixedPoint = false) {
  // With scientific notation, digits specifies the number of significant digits.

  let [a, b] = q;
  let s = a < 0 || (a === 0 && b < 0) ? '-' : '';
  let autoFormat = (digits == 'auto');
  if (autoFormat) {
     digits = 32;
  }
  q = qdAbs(q);

  if (!isFinite(a) || !isFinite(b)) return a.toString();
  if (a === 0 && b === 0) {
     if (autoFormat) return '0';
     if (usedFixedPoint) digits += 1;
     return '0' + (digits > 1 ? '.' + '0'.repeat(digits - 1) : '');
  }

  // Scale q to be between 1 and 10, avoiding cumulative rounding
  let e = 0;
  let ex = [1, 0];
  while (qdCompare(q, qdMul(ex, qdTen)) >= 0) {
    ex = qdMul(ex, qdTen);
    e += 1;
  }
  while (qdLt(qdMul(ex, q), 1)) {
    ex = qdMul(ex, qdTen);
    e -= 1;
  }
  if (e) {
    q = (e > 0 ? qdDiv(q, ex) : qdMul(q, ex));
  }
  if (!qdLt(q, 10)) { // Hit boundary condition
    q = qdDiv(q, qdTen);
    e += 1;
  }

  let result = '';
  let nonzeroDigits = digits;

  if (useFixedPoint && !autoFormat) {
     nonzeroDigits = nonzeroDigits + e + 1;
  }

  for (let i = 0; i < nonzeroDigits + 1; i++) {
    let floorQ = qdFloor(q);
    let digit = floorQ[0];
    result += digit;
    q = qdSub(q, floorQ);
    q = qdMul(q, qdTen);
  }

  if (autoFormat) {
    if (parseInt(result.slice(result.length - 3)) > 970 ||
      parseInt(result.slice(result.length - 3)) < 30 ||
      parseInt(result.slice(result.length - 2)) > 92) {
      nonzeroDigits -= 1; // round to one fewer digit
    }
  }

  // Rounding
  if (parseInt(result[nonzeroDigits]) >= 5) {
    let carry = 1;
    for (let i = nonzeroDigits - 1; i >= 0; i--) {
      let digit = parseInt(result[i]) + carry;
      if (digit < 10) {
        result = result.slice(0, i) + digit + result.slice(i + 1);
        carry = 0;
        break;
      } else {
        result = result.slice(0, i) + '0' + result.slice(i + 1);
        carry = 1;
      }
    }
    if (carry) {
      result = '1' + result;
      e++;
    }
  }
  result = result.slice(0, nonzeroDigits);

  epart = '';
  if (!useFixedPoint && (!autoFormat || e < -6 || e > 32)) {
    // Scientific notation
    if (result.length > 1) {
      result = result[0] + '.' + result.slice(1);
    }
    if (e !== 0) {
      epart = 'e' + e;
    }
  } else {
    // Fixed-point notation
    if (e >= 0) {
      result = result.padEnd(e + 1, '0');
      result = result.slice(0, e + 1) + '.' + result.slice(e + 1);
    } else {
      result = '0.' + '0'.repeat(-e - 1) + result;
    }
    // Ensure the correct number of digits after the decimal point
    let [intPart, fracPart] = result.split('.');
    if (digits <= 0) {
      result = intPart;
    } else {
      fracPart = (fracPart || '').padEnd(digits, '0');
      result = intPart + '.' + fracPart;
    }
  }
  if (autoFormat) {
    // Auto digit selection: trim trailing zeros
    result = result.replace(/\.0+$|(\.\d*[1-9])0+$/, "$1");
  }
  return s + result + epart;
}
</script>
</body>
<script src="https://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-242212-1";
urchinTracker();
</script>
</html>
