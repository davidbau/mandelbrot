<!doctype html>
<html>
<head>
<title>Mandelbrot Explorer</title>
<meta name="description" content="Beautiful, fast, and accurate exploration of the Mandelbrot Set online. Click to zoom. Hover to see orbits. M makes a smooth animation of your zoom path.">
<meta name="viewport" content="width=device-width">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="shortcut icon" type="image/png" href="favicon-128x128.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="favicon-180x180.png">
<link rel="apple-touch-icon" type="image/png" sizes="192x192" href="favicon-192x192.png">
<link rel="apple-touch-icon" type="image/png" sizes="512x512" href="favicon-512x512.png">
<link rel=“canonical” href=“https://mandelbrot.page/">
<!--
Written by David Bau as a Javascript example in 2009; updated in 2020
to handle high device pixel ratios, show orbits, and report periodicity.
Keyboard controls added in 2022, and quad-precision perturbations,
additional exponents, movie generation and web workers added in 2024.

URL options: use ?grid=3 to select 3-column view,
                    &c=-0.14-0.65i to set center,
                and &s=0.5 to set viewed size.

Implementation notes.  To minimize computation, the code identifies both
points that diverge and points that converge.  It uses a method that can
identiify convergence to periodic cylces of arbitrarily long length.
After the number of unknown points is less than half the visual field,
it computes the remaining points sparsely, avoiding iterating over the
already-known points.
-->
<style>
body { font-family: Arial; background: #888; margin: 14px;}
canvas { vertical-align:bottom; cursor:crosshair; user-select: none; }
#grid > div, #text, #movie > div { display: inline-block; margin: 10px;
  position: relative; vertical-align: top; background: rgba(90, 90, 90, 0.5); }
#grid { color: yellow }
#grid > div:only-child .closebox { display: none; }
#grid:empty ~ #text { display: none; }
#text { text-align: left; width: auto; background:#aaa; margin: 10px;
  position:relative;padding:3px 8px;font-size: 11pt }
.closebox { position: absolute; right: 3px; top: 0; cursor: pointer;
  transition: opacity 0.3s; user-select: none; }
.closebox:after { content: '\00d7'; font-size: 20px; }
.closebox:active:after { -webkit-text-stroke: 2px; opacity: 0.8; }
.closebox:hover { font-weight: bold; }
.rect { position: absolute; height: 0; width: 0;
  pointer-events: none; opacity: 0.7; transition: opacity 0.3s; }
.rect:after { content: ''; display: block; position: absolute;
  top: 0; bottom: 0; left: 0; right: 0; border: 1px solid yellow;
  box-shadow: 0px 0px 4px 1px #880; }
.circle .rect:after { border-radius: 100px; }
.hidemarks .rect { opacity: 0; }
.overlay { position: absolute; pointer-events: none; opacity: 0.8;
  top:0; left:0; z-index:1; transition: opacity 0.3s }
.zoomnum { position:absolute; display:inline-block; right:0; bottom:-11pt;
  text-decoration: none; font-size: 11pt; color: yellow; min-width: 25%;
  text-align:right; transition: opacity 0.3s; z-index: 1; cursor: pointer;
  user-select: none; }
.zoomnum[href]:hover { text-decoration: underline; }
body.hidemarks .overlay { opacity: 0; }
body.hidemarks #grid .zoomnum { opacity: 0; }
body.hidemarks #grid .closebox { opacity: 0; }
div.status { display: none; }
div:hover a div.status { /* tooltips */
  display: block; position: absolute; top: 12.5pt; right: 0;
  width: auto; background-color: #ddd; color: #444;
  font: 11pt Arial; text-align: right; white-space: pre;
  padding: 3px 7px; box-shadow: 2px 2px 5px #777;
  pointer-events: none; z-index: 2;
  opacity: 0; transition: opacity 0.25s ease;
}
div:hover a:focus div.status, div:hover a:hover div.status {
  opacity: 0.95;
}
body.starting div#b_0:after { display: flex; position: absolute;
  top: 0; left: 0; width: 100%; height: 100%; align-items: center;
  justify-content: center; content:"Starting..."; color: white;
  z-index: -1; background: rgb(32,16,64); }
</style>
</head>
<body class="starting">
<center>
<div id=movie></div>
<div id=grid></div>
<div id=text style="max-width: 442px">
<div class=closebox></div>

<h4 style="margin-top:3px;margin-bottom:6px">
Mandelbrot Set Fractal Viewer
</h4>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> is iterated for each <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">complex number</a> <em>c</em>.  Colors show <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iterations</a> to divergence; black points converge or cycle.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Tap">Click</span> to zoom.</b>  <span mobile="">Right-click to save images, <b>M</b> to make and save a movie of your zoom path.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Yellow dots show <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbits</a></b>.  Red dots show limit cycles.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>About iterations.</b> This viewer shows more fractal detail over time by refining iterations to infinity as you explore. The longer you wait, the more detail is shown.
After thousands or millions of iterations, you can resolve the finest details in the most complex parts of the fractal.
See information on iterations, progress, and coordinates by <span mobile="tapping">hovering over</a> the yellow zoom number under each window.
<span mobile="Holding your fingertip">Moving your mouse</span> over fractal content will animate the orbit of <em>z</em> values for each location <em>c</em>, revealing the complex boundary dynamics that have fascinated mathematicians.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Exploring a zoom path.</b>
Each <span mobile="tap">click</span> on the fractal starts a new parallel computation worker at a higher zoom level at the selected location.
After you zoom beyond trillion-fold magnification, we slow things down a bit to use a quad-precision perturbation algorithm that resolves fine details to more than 30 digits of accuracy.
Once you have crafted an interesting path that shows the detail you want, you can <a class="moviemode">create and download your own Mandelbrot deep zoom video</a> or bookmark your URL to save and share your exploration.
To create high-quality images and videos, this viewer computes subpixels with a <span class="pixelratio">2</span>:1 ratio<span mobile="">, and that can be increased to create more precise displays</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>More commands:</b>
<b>I</b> zooms in;
<b mac="&#8984;">Ctrl</b>-click to zoom in-place;
<b>H</b> shrinks and <b>G</b> grows each window;
<b>R</b> reopens midway windows;
<b>C</b> recenters all;
<b>T</b> changes color theme;
<b>U</b> highlights unfinished pixels;
<b mac="Return">Enter</b> toggles full-screen;
<b>X</b> increases and <b>Z</b> decreases the <em>z</em> exponent;
<b>F</b> increases and <b>D</b> decreases the pixel ratio;
<b>M</b> makes a movie that follows your path;
<nobr><b>?</b> shows this help.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a>
</div>

</center>

<script>
class Config {
  constructor() {
    document.body.style.overflowY = 'scroll';
    this.vw = document.documentElement.clientWidth || (
       window.innerWidth - 20);
    document.body.style.overflowY = '';
    this.dgc = Math.min(3, Math.ceil(this.vw / 501));
    this.gridcols = this.dgc;
    this.exponent = 2;
    this.firstr = [-0.5, 0];
    this.firstj = [0.0, 0];
    this.firstsize = 3.0;
    this.pixelRatio = Math.max(Math.ceil(window.devicePixelRatio || 1), 2);
    this.zoomfactor = 5;
    this.cssDims = 0;
    this.dims = 0;
    this.dims2 = 0;
    this.ukcs = ["#000", "#888", "#fff", "yellow", "red", "rgb(32,16,64)"];
    this.theme = 'warm';
    this.unknowncolor = "#000";
    this.mobile = ('ontouchstart' in document.documentElement);
    this.mac = (navigator.platform.indexOf('Mac') == 0);
    this.defineColorThemes();
  }

  defineColorThemes() {
    this.colorThemes = {
      warm: (i, frac, fracD, fracL, s) => {
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        let hue = (Math.log(i + 20) * 200) % 360;
        let chroma = 100;
        let light = 15 * frac + 85 * frac ** 5;
        return hclColor(hue, chroma, light);
      },
      iceblue: (i, frac, fracD, fracL, s) => {
        // Current implementation
        let ff = Math.pow(frac, 2);
        let fr = Math.pow(frac, 0.333);
        let fg = Math.pow(frac, 3);
        let g = intcolor(Math.max(fg, Math.min(fr, i * Math.pow(s, 0.33) / 64)));
        let r = intcolor(Math.min(fr, i * Math.pow(s, 0.22) / 64));
        let b = intcolor(ff / 3 + 0.667);
        return `rgb(${r},${g},${b})`;
      },
      tiedye: (i, frac, fracD, fracL, s) => {
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        let hue = (Math.log(i + 20) * 1000) % 360;
        let chroma = 100;
        let light = 25 * frac + 75 * frac ** 5;
        return hclColor(hue, chroma, light);
      },
      gray: (i, frac, fracD, fracL, s) => {
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        let value = intcolor(0.15 + 0.85 * frac ** 5);
        return `rgb(${value},${value},${value})`;
      },
      // Add more color themes here
    };
    this.colorThemes.all = Object.keys(this.colorThemes);
  }

  initSizes() {
    this.cssDims = Math.max(32, Math.floor((this.vw - 28) / this.gridcols) - 20);
    this.dims = Math.floor(this.cssDims * this.pixelRatio);
    this.dims2 = this.dims * this.dims;
    for (let el of document.getElementsByClassName('pixelratio')) {
      el.innerText = this.pixelRatio;
    }
  }

  updateExponent(newExponent) {
    if (newExponent < 2) { return; }
    this.exponent = newExponent;
    for (let el of document.getElementsByClassName('exponent')) {
      el.innerText = this.exponent;
    }
    if (this.firstsize == 3) {
      this.firstr = [this.exponent > 2 ? 0.0 : -0.5, 0];
      this.firstj = [0.0, 0];
    }
  }

  firststate() {
    return {sizes:[[this.firstsize, this.firstr, this.firstj]], hidden:[]};
  }
}

class View {
  constructor(k, size, re, im, config, id) {
    this.k = k;
    this.id = id;
    this.config = config;
    this.convergedData = new Map();
    this.initview(size, re, im);
    this.workerInfo = 'no worker';
  }

  initview(size, re, im) {
    this.sizes = [size, toQd(re), toQd(im)];
    this.nn = new Array(this.config.dims2).fill(0);
    this.un = this.config.dims2;
    this.di = 0;
    this.ch = 0;
    this.it = 0;
    this.hi = [[0, 1, 1, 0]];
    this.convergedData.clear();
  }

  updateFromWorkerResult(data) {
    for (let change of data.changeList) {
      for (let index of change.nn) {
        this.nn[index] = change.iter;
      }
      for (let v of change.vv) {
        this.nn[v.index] = -change.iter;
        this.convergedData.set(v.index, { z: toQdc(v.z), p: v.p });
      }
      this.di += change.nn.length;
      this.un -= change.nn.length + change.vv.length;
      this.updateHistogram(this.un, this.di, change.iter);
    }
    this.un = data.un;
    this.di = data.di;
    this.ch = data.ch;
    this.it = data.it;
    this.workerInfo = data.workerInfo;
    // console.log(`View ${this.k}: Updated to iteration ${this.it}`);
  }

  currentc(j) {
    const x = j % this.config.dims;
    const y = Math.floor(j / this.config.dims);
    const rFrac = (x / this.config.dims) - 0.5;
    const jFrac = 0.5 - (y / this.config.dims);
    const r = qdAdd(this.sizes[1], qdScale(toQd(rFrac), this.sizes[0]));
    const i = qdAdd(this.sizes[2], qdScale(toQd(jFrac), this.sizes[0]));
    return [r[0], r[1], i[0], i[1]];
  }

  currentz(j) {
    const data = this.convergedData.get(j);
    return data ? data.z : null;
  }

  currentp(j) {
    const data = this.convergedData.get(j);
    return data ? data.p : null;
  }

  updateHistogram(un, di, i) {
    if (this.hi[0][1] - un / this.config.dims2 >= 1 / 256) {
      const uFrac = un / this.config.dims2;
      const dFrac = 1 - di / this.config.dims2;
      this.hi.unshift([i, uFrac, dFrac, 0]);
      if (this.hi.length > 10) {
        // Estimate the limit of di as i goes to infinity.
        const sample = this.hi.slice(0, this.hi.length - 2).map(
           (e, i) => ({ x: e[0], y: e[2], weight: (e[0] - this.hi[i+1][0]) ** 4 })
        ).reverse();
        const estimate = Math.min(1, Math.max(0, estimateLimit(sample)));
        // Smooth the estimate.
        const avg = (estimate + this.hi[1][3] * 4) / 5;
        this.hi[0][3] = avg;
      }
    }
  }

  draw(ctx, colorview = null) {
    if (this.un == this.config.dims2) {
      this.clearcanvas(ctx);
      return;
    }
    if (colorview === null) {
      colorview = this;
    }
    // Sort pixels to minimize color transitions
    const n = this.nn;
    const msort = n.map((v, i) => i).sort((a, b) => n[a] - n[b]);
    let prev = null;
    for (let m of msort) {
      const x = m % this.config.dims;
      const y = (m - x) / this.config.dims;
      const cur = n[m];
      if (prev !== cur) {
        ctx.fillStyle = colorview.makecolor(cur);
        prev = cur;
      }
      ctx.fillRect(x, y, 1, 1);
    }
  }

  clearcanvas(ctx) {
    ctx.fillStyle = this.makecolor(0);
    ctx.fillRect(0, 0, this.config.dims, this.config.dims);
  }

  drawchange(ctx, change) {
    if (change.nn.length) {
      ctx.fillStyle = this.makecolor(change.iter);
      for (let m of change.nn) {
        const x = m % this.config.dims;
        const y = (m - x) / this.config.dims;
        ctx.fillRect(x, y, 1, 1);
      }
    }
    if (change.vv.length) {
      ctx.fillStyle = this.makecolor(-change.iter);
      for (let v of change.vv) {
        const x = v.index % this.config.dims;
        const y = (v.index - x) / this.config.dims;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  }

  drawcolor(ctx, i) {
    let color = this.makecolor(i);
    let converged = this.makecolor(-i);
    let n = this.nn;
    for (let m = 0; m < this.config.dims2; ++m) {
      if (n[m] == i || n[m] == -i) {
        let x = m % this.config.dims;
        let y = (m - x) / this.config.dims;
        ctx.fillStyle = n[m] > 0 ? color : converged;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  }

  makecolor(i) {
    if (i == 0) return this.config.unknowncolor;
    if (i < 0) return 'black';
    let j = 0;
    for (; i < this.hi[j][0]; j += 1) {}
    let fracK = 1 - this.hi[j][1]; // Fraction known
    let fracD = 1 - this.hi[j][2]; // Fraction diverged
    let fracL = 1 - this.hi[j][3]; // Estimated limit on fracD
    return this.config.colorThemes[this.config.theme](
       i, fracK, fracD, fracL, this.sizes[0]);
  }

  uninteresting() {
    // Boring: nothing computed, or done with less than 5 colors
    return this.di <= 0 || (this.un == 0 && this.hi.length <= 5);
  }

  unfinished() {
    // Chaotic points in the spike counted as finished after 100000 iterations.
    const result = this.un + (this.it < 100000 ? this.ch : 0);
    return result;
  }


  debugStatus() {
    const debugGraph = this.renderHiGraph(600, 300);
    return `${this.di} diverged, ${this.un} unfinished, ${this.ch} chaotic\n` +
           `${this.workerInfo}\n` +
           `<img src="${debugGraph}" style="width:300px;height:150px">`;
  }

  renderHiGraph(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    const hi = this.hi;
    const scale = [
      (y) => y / hi[Math.floor(hi.length / 8)][0] / 2,
      (y) => y,
      (y) => y,
      (y) => y,
    ];
    const barWidth = width / (hi.length * scale.length);

    // Background
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);

    // Draw bars
    const colors = ['blue', 'red', 'green', 'purple'];
    hi.forEach((row, i) => {
      row.forEach((value, j) => {
        const x = i * scale.length * barWidth + j * barWidth;
        const barHeight = scale[j](value) * (height - 20);
        ctx.fillStyle = colors[j];
        ctx.fillRect(x, height - barHeight - 10, barWidth, barHeight);
      });
    });

    // Draw x-axis
    ctx.strokeStyle = 'black';
    ctx.beginPath();
    ctx.moveTo(0, height - 10);
    ctx.lineTo(width, height - 10);
    ctx.stroke();

    // Add labels
    ctx.font = '20px Arial';
    ctx.shadowColor = 'white';
    ctx.shadowBlur = 8;
    ctx.fillStyle = 'red';
    ctx.fillText(`Undone: ${this.hi[0][1]}`, 5, 30);
    ctx.fillStyle = 'green';
    ctx.fillText(`Dark: ${this.hi[0][2]}`, 5, 60);
    ctx.fillStyle = 'purple';
    ctx.fillText(`Est: ${this.hi[0][3]}`, 5, 90);

    return canvas.toDataURL();
  }
}

class Grid {
  constructor(config) {
    this.config = config;
    this.views = [];
    this.canvascount = 0;
    this.focusk = null;
    this.urlListeners = [];
    this.zoomListeners = [];
    this.scheduler = new Scheduler(this);
  }

  makeView(k, size, re, im) {
    const id = Math.random();
    const view = new View(k, size, re, im, this.config, id);
    this.views[k] = view;
    this.scheduler.assignBoardToWorker(k, size, re, im, this.config, id);
    return view;
  }

  removeView(k) {
    this.views[k] = null;
    let i = this.views.length - 1;
    for (i = this.views.length - 1; i >= 0; i -= 1) {
      if (this.views[i] !== null) { break; }
    }
    this.views.length = i + 1;
    this.scheduler.removeBoardFromWorker(k);
  }

  setFocusedView(k) {
    this.focusk = k;
    this.scheduler.setFocusedBoard(k);
  }

  updateHiddenViews() {
    const hiddenViews = this.views.map((v, i) =>
            this.hiddencanvas(i) ? i : -1).filter(i => i !== -1);
    this.scheduler.setHiddenBoards(hiddenViews);
  }

  updateViewFromWorkerResult(k, data, workerIndex) {
    if (this.views[k]) {
      if (this.views[k].id != data.id) {
        console.log(`Mismatched id for board ${k} from worker ${workerIndex}; discarding.`);
        return;
      }
      this.views[k].updateFromWorkerResult(data);
      this.updateCanvas(k, data);
    }
  }

  updateCanvas(k, data) {
    const canvas = this.canvas(k);
    if (canvas && data.changeList.length) {
      const ctx = canvas.getContext('2d');
      for (let change of data.changeList) {
        this.views[k].drawchange(ctx, change);
      }
    }
  }

  currentGridState() {
    let state = { hidden: [], sizes: [] };
    for (let k = 0; k < this.views.length; k++) {
      if (this.hiddencanvas(k)) {
        state.hidden.push(k);
      }
      state.sizes.push(this.views[k].sizes);
    }
    return state;
  }

  updateLayout(state = null) {
    if (this.currentUpdateProcess) {
      this.currentUpdateProcess.abort();
    }
    if (state === null) {
      state = this.currentGridState();
    }
    this.config.initSizes();

    // Recreate the grid
    let gridElement = document.getElementById('grid');
    gridElement.innerHTML = '';
    this.canvascount = 0;
    this.truncateviews(0);

    // Recreate all canvases
    for (let k = 0; k < state.sizes.length; k++) {
      this.makecanvas(k);
      if (state.hidden.indexOf(k) >= 0) { this.hidecanvas(k); }
    }
    this.currentUpdateProcess = this.createUpdateProcess(state);
    this.currentUpdateProcess.start();
  }

  createUpdateProcess(state) {
    let aborted = false;
    let currentIndex = 0;

    const processNext = () => {
      if (aborted || currentIndex >= state.sizes.length) {
        if (!aborted) {
          this.notifyurl();
          this.notifyzoom();
        }
        this.currentUpdateProcess = null;
        return;
      }

      const k = currentIndex;
      if (!this.views[k]) {
        this.views[k] = this.makeView(k, state.sizes[k][0], state.sizes[k][1], state.sizes[k][2]);
      }
      this.views[k].initview(state.sizes[k][0], state.sizes[k][1], state.sizes[k][2]);
      this.views[k].draw(this.canvas(k).getContext('2d'));
      if (state.hidden.indexOf(k) >= 0) { this.hidecanvas(k); }
      currentIndex++;
      setTimeout(processNext, 200);
    };

    return {
      start: () => {
        if (this.config.gridcols == 1) {
          setTimeout(processNext, 100);
        } else {
          processNext();
        }
      },
      abort: () => { aborted = true; }
    };
  }

  makecanvas(k) {
    let gd = document.getElementById('grid');
    while (this.canvascount <= k) {
      let dd = document.createElement('div');
      dd.id = 'b_' + this.canvascount;
      dd.innerHTML = this.canvasstring(this.canvascount);
      dd.className = 'hidemarks';
      gd.appendChild(dd);
      this.canvascount += 1;
    }
  }

  canvasstring(k) {
    let factor = 3.0 / (k < this.views.length ? this.views[k].sizes[0] :
      this.config.firstsize / Math.pow(this.config.zoomfactor, k));
    factor = formatScale(factor);
    return `<canvas width="${this.config.dims}" height="${this.config.dims}"` +
           ` style="height:${this.config.cssDims}px;width:${this.config.cssDims}px;">` +
           '</canvas>' +
           '<div class="closebox"></div>' +
           '<div class="rect"></div>' +
           `<canvas class=overlay width=${this.config.dims} height="${this.config.dims}"` +
           ` style="height:${this.config.cssDims}px;width:${this.config.cssDims}px;">` +
           '</canvas>' +
           `<a class="zoomnum" target="_blank" href="?grid=1">${factor}` +
           '<div class="status"></div></a>';
  }

  hidecanvas(k) {
    this.canvas(k).parentElement.style.display = 'none';
  }

  showcanvas(k) {
    this.canvas(k).parentElement.style.display = '';
  }

  hiddencanvas(k) {
    let b = this.canvas(k);
    return b && b.parentElement.style.display == 'none';
  }

  grid() {
    return document.getElementById('grid');
  }

  canvas(k) {
    let b = document.getElementById("b_" + k);
    return b && b.firstElementChild;
  }

  closebutton(k) {
      const view = this.canvas(k);
      return view && view.nextElementSibling;
  }

  rect(k) {
      const closeBtn = this.closebutton(k);
      return closeBtn && closeBtn.nextElementSibling;
  }

  overlay(k) {
      const rect = this.rect(k);
      return rect && rect.nextElementSibling;
  }

  truncateviews(k) {
    while (this.views.length > k) {
      let removeIndex = this.views.length - 1;
      this.removeView(removeIndex);
    }
    while (this.canvascount > k) {
      let removeIndex = this.canvascount - 1;
      this.canvas(removeIndex)?.parentElement?.remove();
      this.canvascount -= 1;
    }
  }

  showAllViews() {
    for (let j = 0; j < this.canvascount; ++j) {
      this.showcanvas(j);
    }
    this.notifyzoom();
  }

  truncatehiddenviews() {
    let j = this.canvascount - 1;
    for (; j > 0; j--) {
      if (!this.hiddencanvas(j)) {
        break;
      }
    }
    this.truncateviews(j + 1);
    if (j == 0) {
      this.showcanvas(j);
    }
  }

  updateProgress(overtarget, k) {
    if (overtarget.tagName == 'A' && overtarget.classList.contains('zoomnum')) {
      if (this.config.mobile) {
        overtarget.removeAttribute('href');
      } else {
        overtarget.href = this.bigurl(k, overtarget.showDebug);
      }

      let statusDiv = overtarget.querySelector('.status');
      if (!statusDiv) return;

      // Regular status
      let regularStatus = 'center at ' +
        formatcomplex(k, this.views[k].sizes[1], this.views[k].sizes[2])
          .replaceAll('-', '\u2212') + '\n' +
        Math.floor(1000 * (1.0 - this.views[k].unfinished() / this.config.dims2))/10.0  +
          '% done after ' + this.views[k].it + ' iters';
      statusDiv.textContent = regularStatus;

      // Debug status
      if (overtarget.showDebug) {
        statusDiv.innerHTML += '\n' + this.views[k].debugStatus();
      }
    }
    if (overtarget.matches(':hover')) {
      setTimeout(() => this.updateProgress(overtarget, k), 100);
    }
  }

  bigurl(k, debug) {
    if (k >= this.views.length) return;
    let osize = this.views[k].sizes[0];
    let oexp = '';
    if (this.config.exponent != 2) {
      oexp = '&exponent=' + this.config.exponent;
    }
    let ore = this.views[k].sizes[1];
    let oim = this.views[k].sizes[2];
    return '?s=' + formatSize(osize) +
           (this.config.exponent != 2 ? '&exponent=' + this.config.exponent : '') +
           '&c=' + formatcomplex(k, ore, oim) +
           (this.config.theme != 'warm' ? '&theme=' + this.config.theme : '') +
           (debug ? '' : '&grid=1');
  }

  clearseq(k) {
    const overlayElement = this.overlay(k);
    if (overlayElement) {
      let ctx = overlayElement.getContext('2d');
      ctx.clearRect(0, 0, this.config.dims, this.config.dims);
    }
  }

  onurlchange(callback) {
    this.urlListeners.push(callback);
  }

  notifyurl() {
    for (let cb of this.urlListeners) {
      cb();
    }
  }

  onzoomchange(callback) {
    this.zoomListeners.push(callback);
  }

  notifyzoom() {
    for (let cb of this.zoomListeners) {
      cb();
    }
  }
}

class ZoomManager {
  constructor(config, grid) {
    this.config = config;
    this.grid = grid;
    this.grid.onzoomchange(() => this.updateZoomRectangles());
  }

  showZoomRect(k, x, y, zf) {
    let s = this.grid.rect(k).style;
    let border = 1;
    let cssClass = '';
    if (zf > 50) {
      // Switch from rectangle to circle if the zoom area is tiny.
      zf = 25;
      cssClass = 'circle';
    }
    this.grid.rect(k).parentElement.className = cssClass;
    s.top = (y * this.config.cssDims - this.config.cssDims / 2 / zf - border) + 'px';
    s.left = (x * this.config.cssDims - this.config.cssDims / 2 / zf - border) + 'px';
    s.width = (this.config.cssDims / zf + 2 * border) + 'px';
    s.height = (this.config.cssDims / zf + 2 * border) + 'px';
  }

  removeZoomRect(k) {
    let s = this.grid.rect(k).style;
    s.top = s.left = s.width = s.height = '';
    this.grid.rect(k).parentElement.className = 'hidemarks';
  }

  updateZoomRectangles() {
    let prevView = null;
    let prevK = 0;
    for (let k = 0; k < this.grid.views.length; k++) {
      if (this.grid.hiddencanvas(k)) { continue; }
      let currView = this.grid.views[k].sizes;
      if (prevView != null) {
        let x = qdSub(currView[1], prevView[1])[0] / prevView[0] + 0.5;
        let y = 0.5 - qdSub(currView[2], prevView[2])[0] / prevView[0];
        let zf = prevView[0] / currView[0];
        this.showZoomRect(prevK, x, y, zf);
      }
      prevView = currView;
      prevK = k;
    }
    if (prevView !== null) {
      this.removeZoomRect(prevK);
    }
  }

  zoomInAtCurrentPosition(hideCurrent) {
    let k = this.grid.views.length - 1;
    if (this.grid.views[k].uninteresting()) { return; }
    let osize = this.grid.views[k].sizes[0];
    let ore = this.grid.views[k].sizes[1];
    let oim = this.grid.views[k].sizes[2];
    let rre = 0.5;
    if (k == 0 && qdEq(ore, -0.5) && qdEq(oim, 0)) {
      // Myreberg / Feigenbaum point
      ore = [-1.4011551890920506, 1.196330130384937e-17];
      rre = (ore[0] - this.grid.views[0].sizes[1][0]) / this.grid.views[0].sizes[0] + 0.5;
    }
    this.showZoomRect(k, rre, 0.5, this.config.zoomfactor);
    let nsize = osize / this.config.zoomfactor;
    let newView = this.grid.makeView(k + 1, nsize, ore, oim);
    this.grid.makecanvas(k + 1);
    if (hideCurrent) {
      this.grid.canvas(k).parentElement.style.display = 'none';
      this.updateZoomRectangles();
    }
    this.grid.canvas(k + 1).parentElement.className = 'hidemarks';
    this.grid.canvas(k + 1).parentElement.scrollIntoView({ behavior: 'smooth' });
    newView.draw(this.grid.canvas(k + 1).getContext('2d'));
    this.grid.notifyurl();
  }

  cellclick(k, m, hideCurrent) {
    // Only accept clicks on cells with something computed in them.
    if (k >= this.grid.views.length || this.grid.views[k].uninteresting() ||
         this.grid.currentUpdateProcess) return;
    setTimeout(() => { this.cellclickdelay(k, m, hideCurrent); }, 1);
  }

  cellclickdelay(k, m, hideCurrent) {
    if (k >= this.grid.views.length || this.grid.currentUpdateProcess) return;
    let osize = this.grid.views[k].sizes[0];
    let ore = this.grid.views[k].sizes[1];
    let oim = this.grid.views[k].sizes[2];
    let cx = m % this.config.dims;
    let cy = (m - cx) / this.config.dims;
    this.showZoomRect(k, cx / this.config.dims, cy / this.config.dims, this.config.zoomfactor);
    this.grid.truncateviews(k + 1);
    let nsize = osize / this.config.zoomfactor;
    let nre = qdAdd(ore, [((cx / this.config.dims) - 0.5) * osize, 0]);
    let nim = qdAdd(oim, [(0.5 - (cy / this.config.dims)) * osize, 0]);
    let newView = this.grid.makeView(k + 1, nsize, nre, nim);
    this.grid.makecanvas(k + 1);
    if (hideCurrent) {
      this.grid.canvas(k).parentElement.style.display = 'none';
      this.updateZoomRectangles();
    }
    this.grid.canvas(k + 1).parentElement.className = 'hidemarks';
    this.grid.canvas(k + 1).parentElement.scrollIntoView({ behavior: 'smooth' });
    newView.draw(this.grid.canvas(k + 1).getContext('2d'));
    this.grid.showcanvas(k + 1);
    this.grid.notifyurl();
    setTimeout(() => {
      // Make sure the rectangles are visible
      document.body.className = '';
    }, 10);
  }

  centerViews(includeFirst) {
    let k = this.grid.views.length - 1;
    let ore = this.grid.views[k].sizes[1];
    let oim = this.grid.views[k].sizes[2];
    if (!includeFirst) {
      this.showZoomRect(
        0, 0.5 + (ore[0] - this.grid.views[0].sizes[1][0]) / this.grid.views[0].sizes[0],
           0.5 - (oim[0] - this.grid.views[0].sizes[2][0]) / this.grid.views[0].sizes[0],
           this.grid.views[0].sizes[0] / this.grid.views[1].sizes[0]);
    }
    for (k = includeFirst ? 0 : 1; k < this.grid.views.length - 1; k += 1) {
      this.showZoomRect(
          k, 0.5, 0.5, this.grid.views[k].sizes[0] / this.grid.views[k+1].sizes[0]);
      if (qdCompare(this.grid.views[k].sizes[1], ore) ||
          qdCompare(this.grid.views[k].sizes[2], oim)) {
        this.grid.scheduler.removeBoardFromWorker(k);
        let nsize = this.grid.views[k].sizes[0];
        this.grid.makeView(k, nsize, ore, oim);
        this.grid.views[k].clearcanvas(this.grid.canvas(k).getContext('2d'));
        this.grid.clearseq(k);
      }
    }
    this.grid.notifyurl();
  }
}

class URLHandler {
  constructor(config, grid) {
    this.config = config;
    this.grid = grid;
    this.grid.onurlchange(x => this.updateurl());
  }

  updateurl() {
    if (history.replaceState) {
      history.replaceState(null, '', this.currenturl());
    }
  }

  parseUrl() {
    let startstate = { hidden: [], sizes: [] };
    let opts = document.location.search.split('&');
    for (let j in opts) {
      let m;
      if (null !== (m = opts[j].match(/exponent=(\d+)/))) {
        this.config.exponent = Math.max(2, parseInt(m[1]));
        if (this.config.exponent > 2) { this.config.firstr = [0.0, 0]; }
        for (let el of document.getElementsByClassName('exponent')) {
          el.innerText = this.config.exponent;
        }
      }
      if (null !== (m = opts[j].match(/grid=(\d+)/))) {
        this.config.gridcols = Math.max(1, parseInt(m[1]));
      }
      if (null !== (m = opts[j].match(/s=([-+]?\d?\.?\d+(?:e[-+]\d+)?)/))) {
        this.config.firstsize = parseFloat(m[1]);
      }
      if (null !== (m = opts[j].match(/pixelratio=(\d+)/))) {
        this.config.pixelRatio = Math.max(1, parseInt(m[1]));
      }
      if (null !== (m = opts[j].match(/c=([-+\d\.ei,]+)/))) {
        for (let coords of m[1].split(',')) {
          m = coords.match(/([-+]?\d?\.?\d+(?:e[-+]\d+)?)(?:([-+]\d?\.?\d+(?:e[-+]\d+)?)i)?/);
          startstate.sizes.push([
            this.config.firstsize / Math.pow(this.config.zoomfactor, startstate.sizes.length),
            m != null && m[1] ? qdParse(m[1]) : (startstate.sizes.length > 0 ?
                startstate.sizes[startstate.sizes.length - 1][1] : this.config.firstr),
            m != null && m[2] ? qdParse(m[2]) : (startstate.sizes.length > 0 ?
                startstate.sizes[startstate.sizes.length - 1][2] : this.config.firstj)
          ]);
        }
      }
      if (null !== (m = opts[j].match(/h=([\d,]+)/))) {
        startstate.hidden = m[1].split(',').map(x=>parseInt(x));
      }
      if (null !== (m = opts[j].match(/theme=(\w+)/))) {
        if (this.config.colorThemes.all.includes(m[1])) {
          this.config.theme = m[1];
        }
      }
    }
    if (startstate.sizes.length == 0) {
      startstate.sizes = this.config.firststate().sizes;
    }

    return startstate;
  }

  currenturl() {
    let state = this.grid.currentGridState();
    let compactc = '';
    let commas = '';
    let prev = [this.config.firstr, this.config.firstj];
    let prevj = -1;
    for (let j = 0; j <= state.sizes.length; j++) {
      if (j < state.sizes.length &&
          !qdCompare(state.sizes[j][1], prev[0]) &&
          !qdCompare(state.sizes[j][2], prev[1])) {
        commas += ',';
      } else {
        if (prevj >= 0) {
          compactc += formatcomplex(j - 1, state.sizes[prevj][1], state.sizes[prevj][2]) + ',';
        }
        compactc += commas;
        if (j < state.sizes.length) {
          commas = '';
          prev = [state.sizes[j][1], state.sizes[j][2]];
          prevj = j;
        }
      }
    }
    compactc = compactc.slice(0, -1);
    let url =
           (state.sizes[0][0] != 3.0 ? '&s=' + formatSize(this.grid.views[0].sizes[0]) : '') +
           (this.config.exponent != 2 ? '&exponent=' + this.config.exponent : '') +
           (compactc.length ? '&c=' + compactc : '') +
           (this.config.gridcols != this.config.dgc ? '&grid=' + this.config.gridcols : '') +
           (state.hidden.length ? '&h=' + state.hidden : '') +
           (this.config.theme != 'warm' ? '&theme=' + this.config.theme : '') +
           (this.config.pixelRatio != 2 ? '&pixelratio=' + this.config.pixelRatio : '');
    return '?' + url.replace('&', '');
  }
}

class EventHandler {
  constructor(explorer) {
    this.explorer = explorer;
  }

  setup() {
    document.onmousedown = this.onmousedown.bind(this);
    document.onmousemove = this.onmousemove.bind(this);
    document.body.onkeydown = this.onkeydown.bind(this);
    document.body.onmouseover = this.onmouseover.bind(this);
    document.body.onmousedown = (e) => {
      if (e.target.className == 'closebox') {
        e.stopPropagation();
      }
    };
    document.body.onclick = (e) => {
      if (e.target.className == 'closebox' && !explorer.grid.currentUpdateProcess) {
        e.target.parentElement.style.display = 'none';
        this.explorer.grid.truncatehiddenviews();
        this.explorer.zoomManager.updateZoomRectangles();
        this.explorer.urlHandler.updateurl();
      }
    };
  }

  onmousedown(e) {
    let target = this.eventtarget(e);
    if (this.explorer.movieMode.active && (!target || target.id != 'moviescale')) {
      this.explorer.movieMode.toggle();
    }
    if (e.button != 0) { return true; }
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (e.target.tagName == 'A') {
        if (m && !this.explorer.config.mobile) {
          e.target.href = this.explorer.grid.bigurl(m[1], e.metaKey || e.ctrlKey);
        }
        return true;
      }
      if (m) {
        let p = this.pointInTarget(e, target);
        let k = parseInt(m[1]);
        // Clear orbit before creating new view
        this.explorer.orbitComputer.updateOrbit(k, -1, target);
        this.explorer.zoomManager.cellclick(k, p.x + p.y * this.explorer.config.dims,
          e.metaKey || e.ctrlKey);
        return false;
      }
    }
    return true;
  }

  onmousemove(e) {
    let target = this.eventtarget(e);
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (m) {
        let p = this.pointInTarget(e, target);
        let k = parseInt(m[1]);
        let j = p.x + p.y * this.explorer.config.dims;
        this.explorer.orbitComputer.updateOrbit(k, j, target);
      }
    }
  }

  onkeydown(e) {
    if (this.explorer.movieMode.active &&
        ['Shift', 'Alt', 'Control', 'Meta', 'CapsLock'].indexOf(e.key) == -1) {
      this.explorer.movieMode.toggle();
      return;
    }
    // Pressing backspace will delete the last zoom.
    if (e.key == 'Backspace' && this.explorer.grid.views.length > 1 &&
        !this.explorer.grid.currentUpdateProcess) {
      let k = this.explorer.grid.views.length - 1;
      this.explorer.grid.truncateviews(k);
      this.explorer.grid.truncatehiddenviews();
      this.explorer.urlHandler.updateurl();
    }
    // Pressing C will center all the zoom positions.
    if (e.key == 'c' && this.explorer.grid.views.length > 1) {
      this.explorer.zoomManager.centerViews(e.metaKey || e.ctrlKey);
    }
    // Pressing T will cycle through the color themes.
    if (e.key.toLowerCase() == 't') {
      this.explorer.cycleColorTheme(e.shiftKey);
    }
    // Pressing U will cycle through the uncomputed colors.
    if (e.key.toLowerCase() == 'u') {
      this.explorer.cycleUnknownColor(e.shiftKey);
    }
    // Pressing I will zoom in at the same position.
    if (e.key == 'i') {
      this.explorer.zoomManager.zoomInAtCurrentPosition(e.metaKey || e.ctrlKey);
    }
    // Pressing ? will show the help window
    if (e.key == '?') {
      document.getElementById('text').style.display = 'block';
    }
    // G reduces the grid column count
    if (e.key === 'g' && this.explorer.config.gridcols > 1) {
      this.explorer.config.gridcols -= 1;
      this.explorer.grid.updateLayout();
    }
    // H increases the grid column count
    if (e.key === 'h') {
      this.explorer.config.gridcols += 1;
      this.explorer.grid.updateLayout();
    }
    // R will restore any hidden views
    if (e.key === 'r') {
      this.explorer.grid.showAllViews();
      this.explorer.urlHandler.updateurl();
    }
    // Increase the exponent
    if (e.key === 'x') {
      this.explorer.config.updateExponent(this.explorer.config.exponent + 1);
      this.explorer.grid.updateLayout(this.explorer.config.firststate());
    }
    // Decrease the exponent
    if (e.key === 'z' && this.explorer.config.exponent > 2) {
      this.explorer.config.updateExponent(this.explorer.config.exponent - 1);
      this.explorer.grid.updateLayout(this.explorer.config.firststate());
    }
    // Increase the pixel ratio
    if (e.key === 'f') {
      this.explorer.config.pixelRatio += 1;
      this.explorer.grid.updateLayout();
    }
    // Decrease the pixel ratio
    if (e.key === 'd' && this.explorer.config.pixelRatio > 1) {
      this.explorer.config.pixelRatio -= 1;
      this.explorer.grid.updateLayout();
    }
    // Toggle movie mode
    if (e.key === 'm' && this.explorer.grid.views.length > 1) {
      this.explorer.movieMode.toggle();
    }
    // Toggle fullscreen mode
    if (e.key === 'Enter' || document.fullscreenElement && e.key === 'Escape') {
      e.preventDefault(); // Prevent default action of the Enter key
      this.explorer.toggleFullscreen();
    }
  }

  onmouseover(e) {
    document.body.className = 'hidemarks';
    this.explorer.grid.setFocusedView(null);
    let target = this.eventtarget(e);
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (m) {
        let k = parseInt(m[1]);
        this.explorer.grid.setFocusedView(k);
        if (this.explorer.grid.views.length <= k) return;
        document.body.className = '';
        let overtarget = e.target;
        if (overtarget.tagName == 'A') {
          overtarget.showDebug = e.ctrlKey || e.metaKey;
          this.explorer.grid.updateProgress(overtarget, k);
        }
      } else if (target.id.startsWith('movie') && (!e.target || e.target.id != 'movie')) {
        document.body.className = '';
      }
    }
    this.explorer.grid.updateHiddenViews();
  }

  eventtarget(e) {
    let target = (e.target ? e.target : e.srcElement ? e.srcElement : null);
    while (target) {
      if (target.id) { return target; }
      target = target.parentNode;
    }
    return null;
  }

  pointInTarget(ev, target) {
    let se = document.scrollingElement || document.body;
    let x = (ev.clientX + se.scrollLeft - this.absoluteLeft(target)) *
            this.explorer.config.pixelRatio;
    let y = (ev.clientY + se.scrollTop - this.absoluteTop(target)) *
            this.explorer.config.pixelRatio;
    return { x: Math.round(x), y: Math.round(y) };
  }

  absoluteLeft(target) {
    let left = 0;
    while (target) {
      left += target.offsetLeft;
      target = target.offsetParent;
    }
    return left;
  }

  absoluteTop(target) {
    let top = 0;
    while (target) {
      top += target.offsetTop;
      target = target.offsetParent;
    }
    return top;
  }
}

class MovieMode {
  constructor(explorer) {
    this.explorer = explorer;
    this.active = false;
    this.movieCanvas = null;
    this.movieCtx = null;
    this.animationFrame = null;
    this.preRenderTimer = null;
    this.frameCanvases = [];
    this.mediaRecorder = null;
    this.recordedChunks = [];
    this.isRecording = false;
    this.recordedBlob = null;
    this.recordingMimeType = null;
    this.recordingMimeTypes = [
      'video/webm; codecs="vp8"',
      'video/webm; codecs="avc1.640029"',
      'video/webm',
      'video/mp4; codecs="avc1.640029"',
      'video/mp4',
    ];
  }

  toggle() {
    this.active = !this.active;
    this.explorer.grid.scheduler.pauseComputation(this.active);
    if (this.active) {
      this.startMovie();
    } else {
      this.stopMovie();
    }
  }

  startMovie() {
    this.explorer.grid.grid().style.display = 'none';
    this.explorer.movieContainer.style.display = 'block';
    this.createMovieCanvas();
    this.explorer.movieContainer.scrollIntoView({ behavior: 'smooth' });
    this.preRenderTimer = setTimeout(() => {
      document.body.className = '';
      this.preRenderFrames(() => {
        this.startMovieAnimation();
      });
    }, 20);
  }

  stopMovie() {
    this.explorer.grid.grid().style.display = 'block';
    this.explorer.movieContainer.style.display = 'none';
    this.stopMovieAnimation();
    this.removeMovieCanvas();
  }

  createMovieCanvas() {
    this.explorer.movieContainer.innerHTML = '<div>' +
      `<canvas width=${this.explorer.config.dims} height=${this.explorer.config.dims} ` +
      `style="width:${this.explorer.config.cssDims}px;` +
      `height:${this.explorer.config.cssDims}px"></canvas>` +
      `<a id="moviescale" class="zoomnum">Rendering movie...</a></div>`;
    this.movieCanvas = this.explorer.movieContainer.firstElementChild.firstElementChild;
    this.movieCtx = this.movieCanvas.getContext('2d');
    this.movieCtx.drawImage(this.explorer.grid.canvas(0), 0, 0);
  }

  removeMovieCanvas() {
    while (this.explorer.movieContainer.firstChild) {
      this.explorer.movieContainer.removeChild(this.explorer.movieContainer.firstChild);
    }
    this.movieCanvas = null;
    this.movieCtx = null;
  }

  preRenderFrames(after) {
    this.frameCanvases = [];
    let queueOneFrame = (k, after) => {
      return () => {
        let status = document.getElementById('moviescale');
        if (status) {
          status.textContent =
            `Rendering ${formatScale(3.0 / this.explorer.grid.views[k].sizes[0])}`;
        }
        let canvas1 = null;
        let canvas2 = null;
        const n = this.explorer.grid.views[k].nn;
        // Render with k-1 palette
        if (k > 0) {
          canvas1 = document.createElement('canvas');
          canvas1.width = canvas1.height = this.explorer.config.dims;
          const ctx1 = canvas1.getContext('2d');
          this.explorer.grid.views[k].draw(ctx1, this.explorer.grid.views[k - 1]);
          if (this.explorer.config.unknowncolor != '#000') {
            ctx1.strokeStyle = 'yellow';
            ctx1.lineWidth = this.explorer.config.pixelRatio * this.explorer.config.zoomfactor;
            ctx1.strokeRect(0, 0, this.explorer.config.dims, this.explorer.config.dims);
          }
        }
        // Render with k+1 palette
        if (k < this.explorer.grid.views.length - 1) {
          canvas2 = document.createElement('canvas');
          canvas2.width = canvas2.height = this.explorer.config.dims;
          const ctx2 = canvas2.getContext('2d');
          this.explorer.grid.views[k].draw(ctx2, this.explorer.grid.views[k + 1]);
        }
        this.frameCanvases.push({ prev: canvas1, next: canvas2 });
        this.preRenderTimer = setTimeout(after, 1);
      };
    }
    for (let k = this.explorer.grid.views.length - 1; k >= 0; k--) {
      after = queueOneFrame(k, after);
    }
    this.preRenderTimer = setTimeout(after, 0);
  }

  startMovieAnimation() {
    let frame = 0;
    let framesteps = 300;
    let endpause = 180;
    let endrecord = 60;
    const totalFrames = (this.explorer.grid.views.length - 1) * framesteps;

    const scaleElement = document.getElementById('moviescale');
    scaleElement.removeAttribute('href');

    if (!this.isRecording) {
      this.recordedBlob = null;
      this.isRecording = true;
      this.startRecording();
    }

    const animate = () => {
      const kk = Math.min(frame, totalFrames) / framesteps;
      this.drawMovieFrame(kk);
      frame = (frame + 1) % (totalFrames + endpause);

      if (this.isRecording && frame > totalFrames + endrecord) {
        this.stopRecording();
        this.isRecording = false;
      }

      this.animationFrame = requestAnimationFrame(animate);
    };
    animate();
  }

  stopMovieAnimation() {
    if (this.preRenderTimer) {
      clearTimeout(this.preRenderTimer);
      this.preRenderTimer = null;
    }
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    this.recordedBlob = null;
  }

  startRecording() {
    const stream = this.movieCanvas.captureStream(30); // 30 FPS

    this.recordingMimeType = null;
    this.recordedChunks = [];
    for (let tryType of this.recordingMimeTypes) {
       if (MediaRecorder.isTypeSupported(tryType)) {
          this.recordingMimeType = tryType;
          break;
       }
    }
    if (this.recordingMimeType == null) {
      console.error('Neither MP4 nor WebM recording is supported');
      return;
    }

    this.mediaRecorder = new MediaRecorder(stream, {
      mimeType: this.recordingMimeType,
      videoBitsPerSecond: 10000000,
    });

    this.mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        this.recordedChunks.push(event.data);
      }
    };

    this.mediaRecorder.onstop = () => {
      this.recordedBlob = new Blob(this.recordedChunks, { type: this.recordingMimeType });
      this.recordedChunks = [];
      this.updateDownloadLink();
    };

    this.mediaRecorder.start(1000); // one-second blobs
  }

  stopRecording() {
    this.mediaRecorder.stop();
  }

  updateDownloadLink() {
    const scaleElement = document.getElementById('moviescale');
    const extension = (this.recordingMimeType.includes('mp4') ? 'mp4' : 'webm');
    scaleElement.textContent = 'Download ' + extension;
    scaleElement.href = URL.createObjectURL(this.recordedBlob);
    const k = this.explorer.grid.views.length - 1;
    const view = this.explorer.grid.views[k];
    scaleElement.download = 'mandelbrot' +
              formatcomplex(k, view.sizes[1], view.sizes[2]) +
              '-' + view.it + '.' + extension;
  }

  drawMovieFrame(kk) {
    if (this.movieCtx == null) { return; }
    const k = Math.floor(kk);
    const t = kk - k;
    const sourceView = this.explorer.grid.views[k];
    const targetView = k+1 < this.explorer.grid.views.length ?
                        this.explorer.grid.views[k+1] : sourceView;
    const sourceSize = sourceView.sizes[0];
    const targetSize = targetView.sizes[0];
    const zoomRatio = targetSize / sourceSize;

    // Use zoom ratio for exponential interpolation
    const mulT = Math.pow(zoomRatio, t);
    const expT = (zoomRatio == 1.0 ? t : (mulT - 1) / (zoomRatio - 1));
    const colorT = expT * expT;
    const interpolatedSize = sourceSize * mulT;

    // Use spline interpolation for center coordinates
    const sourceCenter = [sourceView.sizes[1], sourceView.sizes[2]];
    const targetCenter = [targetView.sizes[1], targetView.sizes[2]];

    const p0 = k > 0 ? [
        this.explorer.grid.views[k-1].sizes[1],
        this.explorer.grid.views[k-1].sizes[2]] : sourceCenter;
    const p1 = sourceCenter;
    const p2 = targetCenter
    const p3 = k+2 < this.explorer.grid.views.length ? [
        this.explorer.grid.views[k+2].sizes[1],
        this.explorer.grid.views[k+2].sizes[2]] : targetCenter;
    const interpolatedCenter = catmullRomSpline(p0, p1, p2, p3, t);

    // Clear the movie canvas
    this.movieCtx.fillStyle = this.explorer.grid.views[k].makecolor(1);
    this.movieCtx.fillRect(0, 0, this.explorer.config.dims, this.explorer.config.dims);

    // Draw the current frame
    const scale = sourceSize / interpolatedSize;
    const offsetX = qdMul(qdSub(interpolatedCenter[0], sourceCenter[0]),
                          [this.explorer.config.dims / sourceSize, 0])[0];
    const offsetY = qdMul(qdSub(sourceCenter[1], interpolatedCenter[1]),
                          [this.explorer.config.dims / sourceSize, 0])[0];
    this.movieCtx.save();
    this.movieCtx.imageSmoothingEnabled = true;
    this.movieCtx.imageSmoothingQuality = 'high';
    this.movieCtx.translate(this.explorer.config.dims / 2, this.explorer.config.dims / 2);
    this.movieCtx.scale(scale, scale);
    this.movieCtx.translate(-this.explorer.config.dims / 2 - offsetX,
                            -this.explorer.config.dims / 2 - offsetY);
    this.movieCtx.globalAlpha = 1;
    this.movieCtx.drawImage(this.explorer.grid.canvas(k), 0, 0);

    // Blend the color palette of the next frame
    if (this.frameCanvases[k].next) {
      this.movieCtx.globalAlpha = colorT;
      this.movieCtx.drawImage(this.frameCanvases[k].next, 0, 0);
    }
    this.movieCtx.restore();

    // Draw the next frame
    if (k < this.explorer.grid.views.length - 1) {
      const targetScale = targetSize / interpolatedSize;
      const targetOffsetX = qdMul(qdSub(interpolatedCenter[0], targetCenter[0]),
                                  [this.explorer.config.dims / targetSize, 0])[0];
      const targetOffsetY = qdMul(qdSub(targetCenter[1], interpolatedCenter[1]),
                                  [this.explorer.config.dims / targetSize, 0])[0];
      this.movieCtx.save();
      this.movieCtx.imageSmoothingEnabled = true;
      this.movieCtx.imageSmoothingQuality = 'high';
      this.movieCtx.translate(this.explorer.config.dims / 2, this.explorer.config.dims / 2);
      this.movieCtx.scale(targetScale, targetScale);
      this.movieCtx.translate(-this.explorer.config.dims / 2 - targetOffsetX,
                              -this.explorer.config.dims / 2 - targetOffsetY);
      this.movieCtx.globalAlpha = 1;
      this.movieCtx.drawImage(this.frameCanvases[k + 1].prev, 0, 0);
      this.movieCtx.globalAlpha = colorT;
      this.movieCtx.drawImage(this.explorer.grid.canvas(k + 1), 0, 0);
      this.movieCtx.restore();
    }

    // Update scale text
    if (!this.recordedBlob) {
      const currentScale = (3.0 / this.explorer.config.firstsize) *
          (Math.pow(this.explorer.config.zoomfactor, kk));
      document.getElementById('moviescale').textContent = formatScale(currentScale);
    }
  }
}

class Scheduler {
  constructor(grid) {
    this.grid = grid;
    this.workers = [];
    this.workerLoads = [];
    this.assignments = {};
    this.workerCount = Math.max(1, navigator.hardwareConcurrency || 1);
  }

  addWorker() {
    const workerCode = this.assembleWorkerCode();
    const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);
    const worker = new Worker(workerUrl, { name: `Worker ${this.workers.length}` });
    worker.onmessage = this.handleWorkerMessage.bind(this);
    this.workers.push(worker);
    this.workerLoads.push(0);
    URL.revokeObjectURL(workerUrl);
  }

  assembleWorkerCode() {
    const workerCode = document.getElementById('workerCode');
    const quadCode = document.getElementById('quadCode');
    return '// Linefeeds to align line numbers with HTML.\n' +
           ''.padStart(lastScriptLineNumber, '\n') +
           '// <script id="workerCode">' +
           workerCode.textContent +
           '// <\/script>\n' +
           '// <script id="quadCode">' +
           quadCode.textContent +
           '// <\/script>\n';
  }

  assignBoardToWorker(k, size, re, im, config, id) {
    let minLoad = Math.min(...this.workerLoads);
    if (this.workers.length == 0 || minLoad && this.workers.length < this.workerCount) {
      this.addWorker();
      minLoad = 0;
    }
    const workerNumber = this.workerLoads.indexOf(minLoad);
    const worker = this.workers[workerNumber];
    const estimatedWork = config.dims2 * ((size / config.dims < 1e-15) ? 7 : 1);
    this.assignments[k] = workerNumber;

    worker.postMessage({
      type: 'addBoard',
      data: {
        k,
        size,
        re,
        im,
        config: {
          dims: config.dims,
          dims2: config.dims2,
          exponent: config.exponent
        },
        id,
        workerNumber
      }
    });

    this.workerLoads[workerNumber] += estimatedWork;
  }

  removeBoardFromWorker(k) {
    this.workers.forEach(worker => {
      worker.postMessage({
        type: 'removeBoard',
        data: { k }
      });
    });
  }

  setFocusedBoard(k) {
    this.workers.forEach(worker => {
      worker.postMessage({
        type: 'setFocusedBoard',
        data: { k }
      });
    });
  }

  setHiddenBoards(hiddenBoards) {
    this.workers.forEach(worker => {
      worker.postMessage({
        type: 'setHiddenBoards',
        data: { hiddenBoards }
      });
    });
  }

  handleWorkerMessage(e) {
    const { type, data } = e.data;
    const workerIndex = this.workers.indexOf(e.target);

    switch (type) {
      case 'log':
        console.log(`Worker ${workerIndex}: ${data}`);
        break;
      case 'iterations':
        this.grid.updateViewFromWorkerResult(data.k, data, workerIndex);
        // fallthrough
      case 'update':
        this.workerLoads[workerIndex] = data.remainingWork;
        break;
    }
  }

  pauseComputation(pause) {
    this.workers.forEach(worker => worker.postMessage({ type: 'pause', data: { pause } }));
  }
}

class OrbitComputer {
  constructor(explorer) {
    this.explorer = explorer;
    this.orbitinterval = null;
    this.orbittimeout = null;
  }

  updateOrbit(k, j, target) {
    this.stopOrbitProcess();
    const orb = [];

    const updateorbit = () => {
      const [neworb, cyc, ongoing, title] = this.calculateOrbit(k, j, orb);
      this.displayOrbit(k, neworb, cyc, target, title, orb.length > 0);
      orb.push(...neworb);
      if (!ongoing) { this.stopOrbitInterval(); }
      return ongoing;
    };

    if (updateorbit()) {
      this.orbitinterval = setInterval(updateorbit, 53);
    }
  }

  stopOrbitInterval() {
    if (this.orbitinterval) {
      clearInterval(this.orbitinterval);
      this.orbitinterval = null;
    }
  }

  stopOrbitProcess() {
    this.stopOrbitInterval();
    if (this.orbittimeout) {
      clearTimeout(this.orbittimeout);
      this.orbittimeout = null;
    }
  }

  calculateOrbit(k, j, oldOrb) {
    let cyc = [];
    let orb = [];
    let ongoing = false;
    let title = '';
    let view = this.explorer.grid.views[k];

    if (view && j >= 0 && j < this.explorer.config.dims2) {
      let c = view.currentc(j);
      let z = view.currentz(j);

      // Calculate a further orbit beyond the old orbit.
      let finished = Math.max(view.currentp(j) || 0, Math.abs(view.nn[j] || 0));
      let whole = Math.min(finished || Math.max(view.it, 8));
      let more = Math.min(whole - oldOrb.length / 4, 53);
      if (oldOrb.length) {
        let s = oldOrb.slice(oldOrb.length - 4);
        orb = this.suborbit(s, c, more + 1);
        orb.splice(0, 4);
      } else {
        orb = this.suborbit(c, c, more);
      }
      if (!finished || (orb.length + oldOrb.length) / 4 < finished) {
        ongoing = true;
      }
      // Calculate a cycle and any messages
      title = 'c=' + formatcomplex(k, [c[0], c[1]], [c[2], c[3]]).replaceAll('-', '\u2212');
      if (view.nn[j]) {
        if (view.nn[j] > 0) {
          title += '\ndiverges in ' + view.nn[j];
        } else {
          let period = this.figureperiod(view.currentp(j));
          if (period == 1) {
            title += '\nconverges after ' + view.currentp(j);
          } else {
            title += '\nafter ' + view.currentp(j) + ', period ' + period;
          }
          let clen = this.figureperiod(view.currentp(j));
          cyc = this.suborbit(z, c, clen);
        }
      } else {
        ongoing = true;
      }
    }
    return [orb, cyc, ongoing, title];
  }

  displayOrbit(k, orb, cyc, target, title, preserve) {
    target.setAttribute('title', title);
    if (!preserve) {
      this.explorer.grid.clearseq(k);
    }
    this.showseq(k, orb, 'yellow');
    this.showseq(k, cyc, 'red');

    const orbitonallboards = () => {
      for (let i = 0; i < this.explorer.grid.views.length; i++) {
        if (!this.explorer.grid.hiddencanvas(i) && i != k) {
          if (!preserve) {
            this.explorer.grid.clearseq(i);
          }
          this.showseq(i, orb, 'yellow');
          this.showseq(i, cyc, 'red');
        }
      }
    };
    this.orbittimeout = setTimeout(orbitonallboards, 1);
  }

  suborbit(z, c, len) {
    let r = [z[0], z[1]];
    let j = [z[2], z[3]];
    const cr = [c[0], c[1]];
    const cj = [c[2], c[3]];

    let result = [r[0], r[1], j[0], j[1]];
    while (result.length < len * 4) {
      let j2 = qdSquare(j);
      let ja = qdMul(qdDouble(r), j);
      let r2 = qdSquare(r);
      let ra = qdSub(r2, j2);
      for (let ord = 2; ord < this.explorer.config.exponent; ord++) {
        let rt = qdSub(qdMul(r, ra), qdMul(j, ja));
        ja = qdAdd(qdMul(r, ja), qdMul(j, ra));
        ra = rt;
      }
      r = qdAdd(ra, cr);
      j = qdAdd(ja, cj);
      result.push(r[0], r[1], j[0], j[1]);
    }
    return result;
  }

  figureperiod(i) {
    // Reverse the computation that was done for exponential backoff.
    let head = i, tail = 1;
    while (head > tail) { head >>= 1; tail <<= 1; }
    return i - (head * tail) + 1;
  }

  showseq(k, seq, color) {
    if (k >= this.explorer.grid.views.length) { return; }
    let ctx = this.explorer.grid.overlay(k).getContext('2d');
    ctx.fillStyle = color;
    let [s, cr, cj] = this.explorer.grid.views[k].sizes;
    for (let i = 0; i < seq.length; i += 4) {
      let r = [seq[i], seq[i+1]];
      let j = [seq[i+2], seq[i+3]];
      let x = (qdSub(r, cr)[0] / s + 0.5) * this.explorer.config.dims;
      let y = (qdSub(cj, j)[0] / s + 0.5) * this.explorer.config.dims;
      if (x >= 0 && y >= 0 && x < this.explorer.config.dims && y < this.explorer.config.dims) {
        ctx.beginPath();
        ctx.arc(x, y, 1 * this.explorer.config.pixelRatio, 0, 2 * Math.PI, false);
        ctx.fill();
      }
    }
  }
}

class RedrawProcess {
  constructor(explorer) {
    this.views = explorer.grid.views;
    this.canvasGetter = (index) => explorer.grid.canvas(index);
    this.orderFactory = () => explorer.grid.views.map((b, i) => i).sort(
       (a, b) => (explorer.grid.hiddencanvas(a) * 1 - explorer.grid.hiddencanvas(b) * 1)
                 * explorer.grid.views.length + (b - a));
    this.timer = null;
  }
  start() {
    this.stop();  // Ensure any existing cycle is stopped
    this.canvasOrder = this.orderFactory();
    this.drawNext();
  }
  stop() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
  drawNext() {
    if (this.canvasOrder.length) {
      const index = this.canvasOrder.shift();
      const view = this.views[index];
      const canvas = this.canvasGetter(index);
      if (canvas && view) {
        const ctx = canvas.getContext('2d');
        view.draw(ctx);
      }
      this.currentIndex++;
      this.timer = setTimeout(() => this.drawNext(), 0);
    } else {
      this.stop();
    }
  }
}

class MandelbrotExplorer {
  constructor() {
    this.config = new Config();
    this.grid = new Grid(this.config);
    this.zoomManager = new ZoomManager(this.config, this.grid);
    this.urlHandler = new URLHandler(this.config, this.grid);
    this.eventHandler = new EventHandler(this);
    this.movieMode = new MovieMode(this);
    this.orbitComputer = new OrbitComputer(this);
    this.redrawProcess = new RedrawProcess(this);
    this.movieContainer = document.getElementById('movie');
  }

  start() {
    let startState = this.urlHandler.parseUrl();
    this.config.initSizes();
    this.initPlatform();
    this.grid.updateLayout(startState);
    this.eventHandler.setup();
    this.grid.updateHiddenViews(); // Initial update of hidden boards
  }

  cycleUnknownColor(backward) {
    const inc = backward ? this.config.ukcs.length - 1 : 1;
    const ind = (this.config.ukcs.indexOf(this.config.unknowncolor) + inc) % this.config.ukcs.length;
    this.config.unknowncolor = this.config.ukcs[ind];
    for (let k = 0; k < this.grid.views.length; ++k) {
      this.grid.views[k].drawcolor(this.grid.canvas(k).getContext('2d'), 0);
    }
  }

  cycleColorTheme(backward) {
    const inc = backward ? this.config.colorThemes.all.length - 1 : 1;
    const themes = this.config.colorThemes.all;
    const currentIndex = themes.indexOf(this.config.theme);
    const nextIndex = (currentIndex + inc) % themes.length;
    this.config.theme = themes[nextIndex];
    this.redrawProcess.start();
    this.urlHandler.updateurl();
  }

  toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        console.log(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  }

  initPlatform() {
    for (let el of document.querySelectorAll('#text')) {
      if (this.config.cssDims < 360) {
        // Two columns plus margin minus padding
        el.style.maxWidth = (this.config.cssDims * 2 + 20 - 16) + 'px';
      } else {
        // One column minus padding
        el.style.maxWidth = (this.config.cssDims - 16) + 'px';
      }
    }
    if (this.config.mac) {
      for (let el of document.querySelectorAll('[mac]')) {
        el.innerHTML = el.getAttribute('mac');
      }
    }
    if (this.config.mobile) {
      for (let el of document.querySelectorAll('[mobile]')) {
        el.innerHTML = el.getAttribute('mobile');
      }
    }
    for (let el of document.querySelectorAll('.moviemode')) {
      el.href = '#movie';
      el.onclick = (() => {
        if (this.grid.views.length > 1) {
          this.movieMode.toggle();
        }
        return true;
      });
    }
  }
}

// Utility functions
function formatScale(scale) {
  if (scale < 10) {
    return +scale.toFixed(1) + 'x';
  } else if (scale < 100000) {
    return +scale.toFixed(0) + 'x';
  } else {
    return scale.toExponential(2);
  }
}

function formatSize(s) {
  return parseFloat(s.toPrecision(
              Math.max(2, -Math.ceil(Math.log(s)/2.5))));
}

function formatcomplex(k, re, im) {
  let pix = explorer.grid.views[k].sizes[0] / explorer.config.dims;
  let digits = Math.max(0, -Math.floor(Math.log10(pix)));
  re = toQd(re);
  im = toQd(im);
  let rd = qdFixed(qdAbs(re), digits)
  let id = qdFixed(qdAbs(im), digits)
  let rs = re[0] < 0.0 ? '-' : '+';
  let is = im[0] < 0.0 ? '-' : '+';
  return rs + rd + is + id + 'i';
}

function catmullRom1D(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const c0 = (-t3 + 2*t2 - t) / 2;
  // c1 = (3*t3 - 5*t2 + 2) / 2; // unneeded since p1 = 0
  const c2 = (-3*t3 + 4*t2 + t) / 2;
  const c3 = (t3 - t2) / 2;
  // Compute offsets from p1 for numerical stability.
  const s0 = qdSub(p0, p1);
  const s2 = qdSub(p2, p1);
  const s3 = qdSub(p3, p1);
  return qdAdd(qdAdd(qdAdd(qdScale(s0, c0),
           qdScale(s3, c3)), qdScale(s2, c2)), p1);
}

function catmullRomSpline(p0, p1, p2, p3, t) {
  return [
    catmullRom1D(p0[0], p1[0], p2[0], p3[0], t),
    catmullRom1D(p0[1], p1[1], p2[1], p3[1], t)
  ];
}

function hclColor(h, c, l) {
  // Normalize hue to be between 0 and 360 degrees
  // Chroma and Luminance should be between 0 and 100.
  h = h % 360;
  if (h < 0) h += 360;
  c = Math.min(Math.max(c, 0), 100);
  l = Math.min(Math.max(l, 0), 100);

  // Convert to radians
  const hRad = h * Math.PI / 180;

  // Constants for conversion
  const u = Math.cos(hRad) * c;
  const v = Math.sin(hRad) * c;

  // Direct conversion from HCL to RGB
  let r = l + 0.09551990792716 * u + 0.05406649830715 * v;
  let g = l - 0.03947567534454 * u - 0.01829165033556 * v;
  let b = l - 0.19638676772419 * u - 0.45388640918783 * v;

  // Apply gamma correction and convert to eight-bit value
  [r, g, b] = [r, g, b].map((x) => {
    return intcolor(gammaCorrect(x / 100));
  });
  return `rgb(${r},${g},${b})`
}

function gammaCorrect(channel) {
  if (channel <= 0.0031308) {
    return 12.92 * channel;
  } else {
    return 1.055 * Math.pow(channel, 1/2.4) - 0.055;
  }
}

function intcolor(n) {
  if (n <= 0) { return "0"; }
  if (n >= 1) { return "255"; }
  return (n * 255).toString(10);
}

// Lineweaver-Burk estimate for how many pixels will be black
function estimateLimit(data) {
  // Transform data: x becomes 1/x
  const transformedData = data.map(point => ({
    x: 1 / (point.x ** 0.75),
    y: point.y,
    weight: point.weight || 1  // Default weight to 1 if not provided
  }));

  // Calculate weighted means
  let sumWeights = 0;
  let sumWeightedX = 0;
  let sumWeightedY = 0;

  for (let point of transformedData) {
    sumWeights += point.weight;
    sumWeightedX += point.weight * point.x;
    sumWeightedY += point.weight * point.y;
  }

  const meanX = sumWeightedX / sumWeights;
  const meanY = sumWeightedY / sumWeights;

  // Calculate slope and intercept
  let numerator = 0;
  let denominator = 0;
  for (let point of transformedData) {
    numerator += point.weight * (point.x - meanX) * (point.y - meanY);
    denominator += point.weight * Math.pow(point.x - meanX, 2);
  }
  const slope = numerator / denominator;
  const intercept = meanY - slope * meanX;

  // The intercept is our estimate of the limit as 1/x approaches 0 (i.e., as x approaches infinity)
  return intercept;
}

const lastScriptLineNumber = parseInt(new Error().stack.match(/(:[\d]+)/)[0].replace(':',''));
</script>
<script id="workerCode" type="text/worker">
class Board {
  constructor(k, size, re, im, config, id) {
    this.k = k;
    this.id = id;
    this.config = config;
    this.it = 0;
    this.zz = []; // current iterate for each pixel
    this.cc = []; // current constant for each pixel
    this.nn = []; // iterations when diverged / (neg) converged
    this.bb = []; // recent remembered z
    this.pp = []; // iteration at which converged within epsilon2
    this.ss = null; // sparse list of indexes to compute
    this.un = config.dims2; // count of unfinished points
    this.di = 0; // diverged points
    this.ch = 0; // potentially chaotic points in the spike
    this.hi = [[0, 1, 1, 0]];
    this.sizes = [size, toQd(re), toQd(im)];
    this.effort = 1;
    this.pix = this.sizes[0] / this.config.dims;
    this.epsilon = Math.min(1e-12, this.pix / 10);
    this.epsilon2 = Math.min(1e-9, this.pix * 10);
    this.lastTime = 0;
    this.changeList = [];
    this.updateSize = 0;
  }

  initboard(size, re, im) {
    this.it = 1;
    this.nn = new Array(this.config.dims2).fill(0);
    this.pp = new Array(this.config.dims2).fill(0);
    for (let y = 0; y < this.config.dims; y++) {
      const jFrac = (0.5 - (y / this.config.dims));
      const j = jFrac * size + im[0];
      for (let x = 0; x < this.config.dims; x++) {
        const rFrac = ((x / this.config.dims) - 0.5);
        const r = rFrac * size + re[0];
        this.cc.push(r, j);
        if (this.inspike(r, j)) {
          this.un -= 1;
          this.ch += 1;
        }
      }
    }
    this.ss = [];
    for (let m = 0; m < this.config.dims2; ++m) {
      this.ss.push(m);
    }
    this.zz = this.cc.slice();
    this.bb = this.cc.slice();
  }

  iterate() {
    let changes = null;

    const results = [0, 0, 0];
    let s = this.ss;    // speedy list of indexes to compute
    // head and tail factor i into an odd num and largest power of 2.
    let head = this.it, tail = 1;
    while ((head & 1) == 0) { head >>= 1; tail <<= 1; }
    if (s.length > this.un * 1.25) {
      let news = [];
      for (let t = 0; t < s.length; ++t) {
        if (this.nn[s[t]]) continue;
        news.push(s[t]);
      }
      s = this.ss = news;
    }
    if (head <= tail) {
      for (let t = 0; t < s.length; ++t) {
        let m = s[t];
        if (this.nn[m]) continue;
        this.bb[m * 2] = this.zz[m * 2];
        this.bb[m * 2 + 1] = this.zz[m * 2 + 1];
        this.pp[m] = 0;
      }
    }
    for (let t = 0; t < s.length; ++t) {
      const index = s[t];
      const computeResult = this.compute(index);
      results[computeResult + 1] += 1;

      if (computeResult !== 0) {
        if (!changes) {
          changes = { iter: this.it, nn: [], vv: [] };
        }
        if (computeResult < 0) {
          changes.vv.push({
            index: index,
            z: [this.zz[index * 2], this.zz[index * 2 + 1]],
            p: this.pp[index]
          });
        } else {
          changes.nn.push(index);
        }
      }
    }

    this.un -= results[2] + results[0]; // newly finished
    this.di += results[2]; // diverged

    this.it++;
    return changes;
  }

  compute(m) {
    if (this.nn[m]) return 0;
    const m2 = m * 2;
    const m2i = m2 + 1;
    const r = this.zz[m2];
    const j = this.zz[m2i];
    const r2 = r * r;
    const j2 = j * j;
    if (r2 + j2 > 4.0) {
      this.nn[m] = this.it;
      return 1;
    }
    let ra = r2 - j2;
    let ja = 2 * r * j;
    for (let ord = 2; ord < this.config.exponent; ord++) {
      let rt = r * ra - j * ja;
      ja = r * ja + j * ra;
      ra = rt;
    }
    ra += this.cc[m2];
    ja += this.cc[m2i];
    this.zz[m2] = ra;
    this.zz[m2i] = ja;
    const rb = this.bb[m2];
    const jb = this.bb[m2i];
    const db = Math.abs(rb - ra) + Math.abs(jb - ja);
    if (db <= this.epsilon2) {
      if (!this.pp[m]) { this.pp[m] = this.it; }
      if (db <= this.epsilon) {
        this.nn[m] = -this.it;
        if (this.inspike(this.cc[m2], this.cc[m2i]) && this.ch > 0) {
          this.ch -= 1;
          return 0;  // Points in spike are already counted
        }
        return -1;
      }
    }
    return 0;
  }

  inspike(re, im) {
    // We do not iterate infinitely for chaotic points in the spike.
    return (im == 0.0 && re > -2.0 && re < -1.401155 &&
            this.config.exponent == 2);
  }

  unfinished() {
    // Chaotic points in the spike counted as finished after 100000 iterations.
    const result = this.un + (this.it < 100000 ? this.ch : 0);
    return result;
  }

}

class PerturbationBoard extends Board {
  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);
    this.quadIndexes = [];
    this.pertIndexes = [];
    this.tt = [];
    // The 0.1 threshold is 2x faster than 0.01 but reveals some edge artfiacts
    // Bail when perturbation exceeds half the digits of precision
    this.perturbationThreshold = Math.min(0.1, Math.sqrt(1e15 * (size / config.dims)));
    // For scheduling: each step is about 7x effort of default board.
    this.effort = 7;
  }

  initboard(size, re, im) {
    this.it = 1;
    this.cc = new Array(this.config.dims2 * 4).fill(0);
    this.nn = new Array(this.config.dims2).fill(0);
    this.pp = new Array(this.config.dims2).fill(0);
    // Odd grid ensures that center point corresponds to a quad precision pixel
    const gridSize = Math.floor(this.config.dims / 17 / 2) * 2 + 1;
    const step = this.config.dims / gridSize;
    const offset = step / 2;
    const pix = size / this.config.dims;
    const cc = this.cc;
    re = toQd(re);
    im = toQd(im);

    for (let gy = 0; gy < gridSize; gy++) {
      const ry = Math.round(gy * step + offset);
      const jFrac = (0.5 - (ry / this.config.dims));
      const cj = qdAdd(im, qdScale(toQd(jFrac), size))
      for (let gx = 0; gx < gridSize; gx++) {
        const rx = Math.round(gx * step + offset);
        const rFrac = ((rx / this.config.dims) - 0.5);
        const refIndex = (ry * this.config.dims + rx);
        const ri = refIndex * 4;
        const cr = qdAdd(re, qdScale(toQd(rFrac), size));

        // Initialize reference point

        cc[ri] = cr[0];
        cc[ri+1] = cr[1];
        cc[ri+2] = cj[0];
        cc[ri+3] = cj[1];
        this.quadIndexes.push(refIndex);
        let refspike = this.inspikeQdA(cr[0], cr[1], cj[0], cj[1]);
        if (refspike) {
          this.un -= 1;
          this.ch += 1;
        }

        // Initialize perturbations around this reference point
        const minY = Math.max(0, Math.floor(ry - offset));
        const maxY = Math.min(this.config.dims - 1, Math.ceil(ry + offset));
        const minX = Math.max(0, Math.floor(rx - offset));
        const maxX = Math.min(this.config.dims - 1, Math.ceil(rx + offset));
        for (let py = minY; py <= maxY; py++) {
          const dci = (ry - py) * pix;
          for (let px = minX; px <= maxX; px++) {
            const dcr = (px - rx) * pix;
            const pertIndex = (py * this.config.dims + px);
            const pi = pertIndex * 4;
            if (cc[pi+3] === 0) {  // Avoid double-initialization
              cc[pi] = dcr;
              cc[pi+1] = dci;
              cc[pi+2] = refIndex;
              cc[pi+3] = Infinity;
              this.pertIndexes.push(pertIndex);
              if (refspike && py == ry) {
                this.un -= 1;
                this.ch += 1;
              }
            }
          }
        }
      }
    }
    this.zz = this.cc.slice();
    this.nz = this.cc.slice();
    this.bb = this.cc.slice();
  }

  inspikeQdA(re1, re2, im1, im2) {
    // We do not iterate infinitely for chaotic points in the spike.
    return (im1 + im2 == 0.0 && re1 >= -2.0 && re1 < -1.401155 &&
            this.config.exponent == 2);
  }

  iterate() {
    let changes = null;

    let i = this.it;
    let head = i, tail = 1;
    while ((head & 1) == 0) { head >>= 1; tail <<= 1; }
    let results = [0, 0, 0];

    // Precompute quad-precision point escape without updating z
    for (const index of this.quadIndexes) {
      if (head <= tail && !this.nn[index]) {
        AqdcCopy(this.bb, index*4, this.zz, index*4);
        this.pp[index] = 0;
      }
      let r = this.precomputeQuad(index);
      results[r + 1] += 1;
      if (r !== 0) {
        if (!changes) {
          changes = { iter: this.it, nn: [], vv: [] };
        }
        if (r < 0) {
          changes.vv.push({
            index: index,
            z: AqdcGet(this.nz, index*4),
            p: this.pp[index]
          });
        } else {
          changes.nn.push(index);
        }
      }
    }

    // Iterate perturbation points that use the old z
    const newQuadIndexes = [];
    let cache = { refIndex: null, binZpow: [] };
    for (const index of this.pertIndexes) {
      if (!this.computePerturbation(index, cache)) {
        this.convertToQuadPrecision(index);
        let r = this.precomputeQuad(index);
        results[r + 1] += 1;
        newQuadIndexes.push(index);
        if (r !== 0) {
          if (!changes) {
            changes = { iter: this.it, nn: [], vv: [] };
          }
          if (r < 0) {
            changes.vv.push({
              index: index,
              z: z,
              p: this.pp[index]
            });
          } else {
            changes.nn.push(index);
          }
        }
      }
    }

    // Update index arrays
    if (newQuadIndexes.length > 0) {
      const newPertIndexes = [];
      let qi = 0;
      for (const index of this.pertIndexes) {
        if (newQuadIndexes[qi] == index) {
          qi += 1;
        } else {
          newPertIndexes.push(index);
        }
      }
      this.quadIndexes = this.quadIndexes.concat(newQuadIndexes);
      this.pertIndexes = newPertIndexes;
    }

    // Finally update quad-precision z with precomputed values
    for (const index of this.quadIndexes) {
      AqdcCopy(this.zz, index*4, this.nz, index*4);
    }

    // Tally progress
    let diverged = results[2];
    let count = results[0] + diverged;
    this.un -= count;
    this.di += diverged;

    // Trim finished pixels from array.
    if (this.pertIndexes.length + this.quadIndexes.length > this.un * 1.25) {
      const trimmedQuadIndexes = []
      for (const index of this.quadIndexes) {
        if (this.nn[index]) continue;
        trimmedQuadIndexes.push(index);
      }
      // Switch to full quad when perturbations are a small fraction of the work
      if (this.pertIndexes.length < trimmedQuadIndexes.length * 0.5) {
        for (const index of this.pertIndexes) {
          this.convertToQuadPrecision(index);
          trimmedQuadIndexes.push(index);
        }
        this.pertIndexes = [];
      }
      this.quadIndexes = trimmedQuadIndexes;
    }

    this.it++;
    return changes;
  }

  precomputeQuad(m) {
    // Quad-precision compute
    if (this.nn[m]) return 0;
    const m4 = m * 4;
    const tt = this.tt;
    const nz = this.nz;
    const r1 = this.zz[m4];
    const r2 = this.zz[m4+1];
    const j1 = this.zz[m4+2];
    const j2 = this.zz[m4+3];
    const cr1 = this.cc[m4];
    const cr2 = this.cc[m4+1];
    const cj1 = this.cc[m4+2];
    const cj2 = this.cc[m4+3];
    const br1 = this.bb[m4];
    const br2 = this.bb[m4+1];
    const bj1 = this.bb[m4+2];
    const bj2 = this.bb[m4+3];

    AqdSquare(tt, 0, r1, r2);                    // 0: rsq = r**2
    AqdSquare(tt, 2, j1, j2);                    // 2: jsq = j**2
    AqdAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);   // 4: d = rsq+jsq
    if (tt[4] + tt[5] > 4) {
      this.nn[m] = this.it;
      return 1;
    }
    AqdMul(tt, 6, 2 * r1, 2 * r2, j1, j2);       // 6: ja = 2*r*j
    AqdAdd(tt, 8, tt[0], tt[1], -tt[2], -tt[3]); // 8: ra = rsq-jsq
    for (let ord = 2; ord < this.config.exponent; ord++) {
      AqdMul(tt, 0, j1, j2, tt[6], tt[7]);         // 0: j * ja
      AqdMul(tt, 2, r1, r2, tt[8], tt[9]);         // 2: r * ra
      AqdAdd(tt, 4, -tt[0], -tt[1], tt[2], tt[3]); // 4: rt = r*ra - j*ja
      AqdMul(tt, 0, r1, r2, tt[6], tt[7]);         // 0: r * ja
      AqdMul(tt, 2, j1, j2, tt[8], tt[9]);         // 2: j * ra
      AqdAdd(tt, 6, tt[0], tt[1], tt[2], tt[3]);   // 6: ja = r*ja + j*ra
      AqdSet(tt, 8, tt[4], tt[5]);                 // 8: ra = rt
    }
    AqdAdd(nz, m4, tt[8], tt[9], cr1, cr2);        // nz: nzr = ra + cr
    AqdAdd(nz, m4+2, tt[6], tt[7], cj1, cj2);      // nz+2: nzj = ja + cj
    AqdAbsSub(tt, 0, br1, br2, nz[m4], nz[m4+1]);  // 0: abs(nzr - br)
    AqdAbsSub(tt, 2, bj1, bj2, nz[m4+2], nz[m4+3]);// 2: abs(nzj - bj)
    AqdAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);     // 4: db = abs(nzr-br)+abs(nzj-bj)
    const db = tt[4] + tt[5]
    if (db <= this.epsilon2) {
      if (!this.pp[m]) { this.pp[m] = this.it; }
      if (db <= this.epsilon) {
        this.nn[m] = -this.it;
        if (this.inspikeQdA(cr1, cr2, cj1, cj2) && this.ch > 0) {
          this.ch -= 1;
          return 0;  // Already counted
        } else {
          return -1;
        }
      }
    }
    return 0;
  }

  computePerturbation(index, cache) {
    const m4 = index * 4;
    const cr = this.cc[m4]
    const ci = this.cc[m4+1]
    const refIndex = this.cc[m4+2]
    const ri4 = refIndex * 4;
    const dr = this.zz[m4];
    const di = this.zz[m4+1];

    // Switch to quad when approaching convergence.
    if (this.nn[refIndex] || this.pp[refIndex]) return false;

    // Compute binomial powers of z
    if (cache.refIndex !== refIndex) {
      cache.refIndex = refIndex;
      const ri4 = refIndex * 4;
      const zr = this.zz[ri4];
      const zi = this.zz[ri4+2];
      this.fillBinZpow(cache.binZpow, zr, zi);
    }
    const binZpow = cache.binZpow;

    // Compute in (z+d)^n - z^n = nz^(n-1) d + (n(n-1)/2)z^(n-2) d^2...
    let r = dr;
    let i = di;
    for (let ord = 0; ord < binZpow.length; ord += 2) {
      r += binZpow[ord];
      i += binZpow[ord+1];
      const rNew = r * dr - i * di;
      i = r * di + i * dr;
      r = rNew;
    }

    // Add perturbation in c
    r += cr;
    i += ci;

    if (this.isThresholdExceeded(r, i, refIndex)) {
      return false;
    }

    this.zz[m4] = r;
    this.zz[m4+1] = i;
    return true;
  }

  fillBinZpow(binZpow, zr, zi) {
    let zrCurrent = zr, ziCurrent = zi;
    let coeff = this.config.exponent;

    for (let k = 1; k < this.config.exponent - 1; k++) {
      binZpow[k*2-2] = coeff * zrCurrent;
      binZpow[k*2-2] = coeff * ziCurrent;

      // Update z power
      const zrNew = zrCurrent * zr - ziCurrent * zi;
      ziCurrent = zrCurrent * zi + ziCurrent * zr;
      zrCurrent = zrNew;

      // Update coefficient for next iteration
      coeff *= (this.config.exponent - k) / (k + 1);
    }

    // Add the last element without computing the next z power or coefficient
    if (this.config.exponent > 1) {
      binZpow[this.config.exponent*2 - 4] = coeff * zrCurrent;
      binZpow[this.config.exponent*2 - 3] = coeff * ziCurrent;
    }
  }

  isThresholdExceeded(dr, di, refIndex) {
    const mag = Math.max(Math.abs(dr), Math.abs(di));
    if (mag > this.perturbationThreshold) return true;
    // If orbit is getting large, then be more careful.
    if (mag * 10 < this.perturbationThreshold) return false;
    const zr = this.zz[refIndex * 4];
    const zi = this.zz[refIndex * 4 + 2];
    return ((dr + zr) ** 2 + (di + zi) ** 2 > 3);
  }

  convertToQuadPrecision(index) {
    const m4 = index * 4;
    const dr = this.zz[m4];
    const di = this.zz[m4+1];
    const cr = this.cc[m4];
    const ci = this.cc[m4+1];
    const refIndex = this.cc[m4+2];
    const ri4 = refIndex * 4;
    AqdAdd(this.zz, m4, dr, 0, this.zz[ri4], this.zz[ri4+1])
    AqdAdd(this.zz, m4+2, di, 0, this.zz[ri4+2], this.zz[ri4+3])
    AqdAdd(this.cc, m4, cr, 0, this.cc[ri4], this.cc[ri4+1])
    AqdAdd(this.cc, m4+2, ci, 0, this.cc[ri4+2], this.cc[ri4+3])
  }
}

function workerLog(message) {
  self.postMessage({
    type: 'log',
    data: message
  });
}

let workerNumber = null;
let boards = new Map();
let focusedBoardK = null;
let hiddenBoards = new Set();
let computationPaused = false;
let steps = 0;
let startTime = 0;
let endTime = -1;
let timer = null;

self.onmessage = function(e) {
  const { type, data } = e.data;
  switch (type) {
    case 'addBoard':
      workerNumber = data.workerNumber;
      // workerLog(`Board ${data.k} added to {${[...boards.keys()]}}`);
      const board = data.size / data.config.dims < 1e-15
        ? new PerturbationBoard(data.k, data.size, data.re, data.im, data.config, data.id)
        : new Board(data.k, data.size, data.re, data.im, data.config, data.id);
      board.initboard(data.size, data.re, data.im);
      boards.set(data.k, board);
      break;
    case 'removeBoard':
      boards.delete(data.k);
      break;
    case 'setFocusedBoard':
      focusedBoardK = data.k;
      break;
    case 'setHiddenBoards':
      hiddenBoards = new Set(data.hiddenBoards);
      break;
    case 'pause':
      computationPaused = data.pause;
      break;
  }
  if (!timer && boards.size && !computationPaused) {
    iterateBoards();
  } else {
    const remainingWork = Array.from(boards.values()).
        filter(board => !hiddenBoards.has(board.k)).
        map(b => b.unfinished() * b.effort).reduce((a, b) => a + b, 0);
    self.postMessage({
      type: 'update',
      data: {
        remainingWork,
      }
    });
  }
};

function iterateBoards() {
  timer = null;
  if (computationPaused) {
    return;
  }
  let pri = Array.from(boards.values())
        .filter(board => (board.unfinished() || board.updateSize))
        .filter(board => !hiddenBoards.has(board.k));
  if (pri.length) {
    // Start timer if it is not already running.
    if (endTime) {
      startTime = (new Date).getTime();
      endTime = 0;
    }
    if (steps % 2) {
      // Prioritize most unfinished half the time.
      pri = pri.sort((a, b) => b.unfinished() - a.unfinished());
    } else {
      // Prioritize the most recent half the time.
      pri = pri.sort((a, b) => b.k - a.k);
      // Allow the user to prioritize by pointing the mouse.
      if (focusedBoardK !== null) {
        pri.sort((a, b) => (a.k === focusedBoardK ? -1 : b.k === focusedBoardK ? 1 : 0));
      }
    }
    // Exponential scheduling policy
    let shift = Math.floor(steps++ / 2) + 1;
    let p = 0;
    while (shift & (1 << p)) { p += 1; }
    const board = pri[Math.min(p, pri.length) % pri.length];
    for (let workDone = 0; workDone < 50007 && board.unfinished(); ) {
      workDone += (board.un + board.ch) * board.effort;
      const changes = board.iterate();
      if (changes !== null) {
        board.changeList.push(changes);
        board.updateSize += changes.nn.length + changes.vv.length;
      }
    }
    const now = (new Date()).getTime();
    if (board.updateSize >= 1000 || now - board.lastTime >= 100) {
      const remainingWork = pri.map(b => b.unfinished() * b.effort).reduce((a, b) => a + b, 0);
      const workerInfo = `worker ${workerNumber}: ` + (board.unfinished() ?
           `boards {${[...boards.keys()]}}, work: ${remainingWork}` :
           `board finished`);
      self.postMessage({
        type: 'iterations',
        data: {
          k: board.k,
          id: board.id,
          it: board.it,
          un: board.un,
          di: board.di,
          ch: board.ch,
          changeList: board.changeList,
          remainingWork,
          workerInfo
        }
      });
      board.lastTime = now;
      board.updateSize = 0;
      board.changeList = [];
      if (!board.unfinished()) {
        // Delete board when done.
        boards.delete(board.k);
        // workerLog(`Board ${board.k} finished, leaving {${[...boards.keys()]}}`);
      }
    }
  } else {
    // End timer when there is no remaining work
    if (!endTime) {
       endTime = (new Date).getTime();
       workerLog(`Finished in ${((endTime - startTime) / 1000).toFixed(3)}s`);
    }
    return;
  }
  timer = setTimeout(iterateBoards, 0);
}

</script>
<script id="quadCode">
//////////// quad-precision (qd, double double) utilities ///////////

function toQd(x) {
  return Array.isArray(x) ? x : [x, 0];
}

function toQdc(c) {
  if (c.length == 4) { return c; }
  const r = toQd(c[0]);
  const j = toQd(c[1]);
  return [r[0], r[1], j[0], j[1]];
}

function fast2Sum(a, b) {
  let s = a + b;
  let t = b - (s - a);
  return [s, t];
}

function slow2Sum(a, b) {
  let s = a + b;
  let c = s - a;
  return [s, (a - (s - c)) + (b - c)];
}

function qdSplit(a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  return [x, y];
}

function twoProduct(a, b) {
  let p = a * b;
  let [ah, al] = qdSplit(a);
  let [bh, bl] = qdSplit(b);
  let err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  return [p, err];
}

function twoSquare(a) {
  let p = a * a;
  let [ah, al] = qdSplit(a);
  let err = ((ah * ah - p) + 2 * ah * al) + al * al;
  return [p, err];
}

function qdAdd(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [h1, h2] = slow2Sum(a1, b1);
  let [l1, l2] = slow2Sum(a0, b0);
  let [v1, v2] = fast2Sum(h1, h2 + l1);
  return fast2Sum(v1, v2 + l2);
}

function qdMul(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [p1, p2] = twoProduct(a1, b1);
  return fast2Sum(p1, p2 + a1 * b0 + b1 * a0);
}

function qdDouble(a) {
  return [a[0] * 2, a[1] * 2];
}

function qdScale(q, s) {
  let [q1, q0] = q;
  let [p1, p2] = twoProduct(q1, s);
  return fast2Sum(p1, p2 + s * q0);
}

function qdSquare(a) {
  let [a1, a0] = a;
  let [p1, p2] = twoSquare(a1);
  return fast2Sum(p1, p2 + 2 * a1 * a0);
}

function qdcPow(q, n) {
  if (n === 1) return q;
  if (n === 2) return qdcSquare(q);
  if (n === 3) return qdcMul(qdSquare(q), q);
  let result = [1, 0, 0, 0];
  let base = q;
  while (n > 0) {
    if (n % 2 === 1) { result = qdcMul(result, base); }
    base = qdcSquare(base);
    n = Math.floor(n / 2);
  }
  return result;
}

function qdNegate(a) {
  let [a1, a0] = a;
  return [-a1, -a0];
}

function qdSub(a, b) {
  return qdAdd(a, qdNegate(b));
}

function qdDiv(a, b) {
  let reciprocal = qdReciprocal(b);
  return qdMul(a, reciprocal);
}

function qdReciprocal(b, iters = 2) {
  if (b[0] === 0 && b[1] === 0) {
    return [NaN, 0];  // Return NaN for division by zero
  }
  // Refine the approximation using Newton-Raphson iteration
  let x = [1 / b[0], 0];
  for (let i = 0; i < iters; i++) {
    x = qdMul(x, qdSub([2, 0], qdMul(x, b)));
  }
  return x;
}

// Complex operations in quad precision
function qdcAdd(a, b) {
  let realSum = qdAdd([a[0], a[1]], [b[0], b[1]]);
  let imagSum = qdAdd([a[2], a[3]], [b[2], b[3]]);
  return [realSum[0], realSum[1], imagSum[0], imagSum[1]];
}

// Complex subtraction in quad precision
function qdcSub(a, b) {
  let realDiff = qdSub([a[0], a[1]], [b[0], b[1]]);
  let imagDiff = qdSub([a[2], a[3]], [b[2], b[3]]);
  return [realDiff[0], realDiff[1], imagDiff[0], imagDiff[1]];
}

// Complex multiplication in quad precision
function qdcMul(a, b) {
  let ac = qdMul([a[0], a[1]], [b[0], b[1]]);
  let bd = qdMul([a[2], a[3]], [b[2], b[3]]);
  let adbc = qdMul(qdAdd([a[0], a[1]], [a[2], a[3]]), qdAdd([b[0], b[1]], [b[2], b[3]]));
  let real = qdSub(ac, bd);
  let imag = qdSub(adbc, qdAdd(ac, bd));
  return [real[0], real[1], imag[0], imag[1]];
}

// Complex doubling in quad precision
function qdcDouble(a) {
  let realDouble = qdDouble([a[0], a[1]]);
  let imagDouble = qdDouble([a[2], a[3]]);
  return [realDouble[0], realDouble[1], imagDouble[0], imagDouble[1]];
}

// Complex squaring in quad precision
function qdcSquare(a) {
  let a0a0 = qdSquare([a[0], a[1]]);
  let a1a1 = qdSquare([a[2], a[3]]);
  let a0a1 = qdMul([a[0], a[1]], [a[2], a[3]]);
  let real = qdSub(a0a0, a1a1);
  let imag = qdDouble(a0a1);
  return [real[0], real[1], imag[0], imag[1]];
}

// Complex absolute value in quad precision
function qdcAbs(a) {
  let a0a0 = qdSquare([a[0], a[1]]);
  let a1a1 = qdSquare([a[2], a[3]]);
  return qdAdd(a0a0, a1a1);
}

function qdParse(s) {
  s = s.trim().toLowerCase();
  if (s === "infinity" || s === "+infinity") return [Infinity, 0];
  if (s === "-infinity") return [-Infinity, 0];
  if (s === "nan") return [NaN, 0];
  let sign = 1;
  if (s[0] === '-') {
    sign = -1;
    s = s.slice(1);
  } else if (s[0] === '+') {
    s = s.slice(1);
  }
  let e = 0;
  let parts = s.split('e');
  if (parts.length > 1) {
    s = parts[0];
    e = parseInt(parts[1]);
  }
  let decimalPos = s.indexOf('.');
  if (decimalPos !== -1) {
    s = s.replace('.', '');
    e -= s.length - decimalPos;
  }
  s = s.replace(/^0+/, '');
  if (s === '') return [0, 0];
  let result = [0, 0];
  for (let digit of s) {
    result = qdAdd(qdMul(result, [10, 0]), [parseInt(digit), 0]);
  }
  if (e !== 0) {
    result = qdMul(result, qdPow10(e));
  }
  if (sign === -1) {
    result = qdNegate(result);
  }
  return result;
}

function qdPow10(e) {
  if (e < 0) return qdReciprocal(qdPow10(-e));
  // Up to 1e16, the second component is zero.
  if (e <= 16) { return [10 ** e, 0]; }
  if (e % 2) { return qdMul([1e15, 0], qdPow10(e - 15)) };
  return qdSquare(qdPow10(e / 2));
}

function qdFloor(q) {
  let [a, b] = q;
  let fl = Math.floor(a);
  let [r0, r1] = qdAdd([a, b], [-fl, 0]);
  if (r0 < 0 || (r0 === 0 && r1 < 0)) {
    fl -= 1;
  }
  return [fl, 0];
}

function qdCompare(a, b) {
  if (a[0] < b[0]) return -1;
  if (a[0] > b[0]) return 1;
  if (a[1] < b[1]) return -1;
  if (a[1] > b[1]) return 1;
  return 0;
}

function qdLt(a, s) {
  return a[0] < s || (a[0] == s && a[1] < 0);
}

function qdEq(a, s) {
  return a[0] == s && a[1] == 0;
}

function qdAbs(q) {
  return (q[0] + q[1] < 0) ? qdNegate(q) : q;
}

function qdFixed(q, digits = 0) {
  // With fixed-point notation, digits specifies the number of digits after the decimal point.
  return qdFormat(q, digits, true);
}

const qdTen = [10, 0];

function qdFormat(q, digits = 'auto', useFixedPoint = false) {
  // With scientific notation, digits specifies the number of significant digits.
  let [a, b] = q;
  let s = a < 0 || (a === 0 && b < 0) ? '-' : '';
  let autoFormat = (digits == 'auto');
  if (autoFormat) {
     digits = 32;
  }
  q = qdAbs(q);
  if (!isFinite(a) || !isFinite(b)) return a.toString();
  if (a === 0 && b === 0) {
     if (autoFormat) return '0';
     if (useFixedPoint) digits += 1;
     return '0' + (digits > 1 ? '.' + '0'.repeat(digits - 1) : '');
  }
  // Scale q to be between 1 and 10
  let e = parseInt(q[0].toExponential().match(/e([+-]\d+)/)[1]);
  if (qdCompare(q, qdPow10(e)) < 0) { e -= 1; }
  if (qdCompare(q, qdPow10(1+e)) >= 0) { e += 1; }
  if (e) { q = qdMul(q, qdPow10(-e)); }
  if (!qdLt(q, 10)) { // Hit boundary condition
    q = qdDiv(q, qdTen);
    e += 1;
  }
  let result = '';
  let nonzeroDigits = digits;
  if (useFixedPoint && !autoFormat) {
     nonzeroDigits = nonzeroDigits + e + 1;
  }
  for (let i = 0; i < nonzeroDigits + 1; i++) {
    let floorQ = qdFloor(q);
    let digit = floorQ[0];
    result += digit;
    q = qdSub(q, floorQ);
    q = qdMul(q, qdTen);
  }
  // Rounding
  if (nonzeroDigits < 0) {
    // No nonzero signficant digits? Treat as zero.
    result = '?';
    nonzeroDigits = 0;
    e = 0;
  } else if (parseInt(result[nonzeroDigits]) >= 5) {
    result = result.slice(0, nonzeroDigits) + '?';
    let carry = 1;
    for (let i = nonzeroDigits - 1; i >= 0; i--) {
      let digit = parseInt(result[i]) + carry;
      if (digit < 10) {
        result = result.slice(0, i) + digit + result.slice(i + 1);
        carry = 0;
        break;
      } else {
        result = result.slice(0, i) + '0' + result.slice(i + 1);
        carry = 1;
      }
    }
    if (carry) {
      result = '1' + result;
      nonzeroDigits += 1;
      e++;
    }
  }
  result = result.slice(0, nonzeroDigits);
  epart = '';
  if (!useFixedPoint && (!autoFormat || e < -6 || e >= 32)) {
    // Scientific notation
    if (result.length > 1) {
      result = result[0] + '.' + result.slice(1);
    }
    if (e !== 0) {
      epart = 'e' + e;
    }
  } else {
    // Fixed-point notation
    if (e >= 0) {
      result = result.padEnd(e + 1, '0');
      result = result.slice(0, e + 1) + '.' + result.slice(e + 1);
    } else {
      result = '0.' + '0'.repeat(-e - 1) + result;
    }
    // Ensure the correct number of digits after the decimal point
    let [intPart, fracPart] = result.split('.');
    if (digits <= 0) {
      result = intPart;
    } else {
      fracPart = (fracPart || '').padEnd(digits, '0');
      result = intPart + '.' + fracPart;
    }
  }
  if (autoFormat) {
    // Auto digit selection: trim trailing zeros
    result = result.replace(/\.0+$|(\.\d*[1-9])0+$/, "$1");
  }
  return s + result + epart;
}

// Array in-place quad precision, allows fast computation
// by avoiding array constructors

function Afast2Sum(r, i, a, b) {
  let s = a + b;
  r[i] = s;
  r[i+1] = b - (s - a);
}

function Aslow2Sum(r, i, a, b) {
  let s = a + b;
  let c = s - a;
  r[i] = s;
  r[i+1] = (a - (s - c)) + (b - c);
}

function AqdSplit(r, i, a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  r[i] = x;
  r[i+1] = y;
}

function AtwoProduct(r, i, a, b) {
  const p = a * b;
  AqdSplit(r, i, a);
  const ah = r[i];
  const al = r[i+1];
  AqdSplit(r, i, b);
  const bh = r[i];
  const bl = r[i+1];
  const err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  r[i] = p;
  r[i+1] = err;
}

function AtwoSquare(r, i, a) {
  const p = a * a;
  AqdSplit(r, i, a);
  const ah = r[i];
  const al = r[i+1];
  const err = ((ah * ah - p) + 2 * ah * al) + al * al;
  r[i] = p;
  r[i+1] = err;
}

function AqdAdd(r, i, a1, a2, b1, b2) {
  Aslow2Sum(r, i, a1, b1);
  const h1 = r[i];
  const h2 = r[i+1];
  Aslow2Sum(r, i, a2, b2);
  const l1 = r[i];
  const l2 = r[i+1];
  Afast2Sum(r, i, h1, h2 + l1);
  const v1 = r[i];
  const v2 = r[i+1];
  Afast2Sum(r, i, v1, v2 + l2);
}

function AqdMul(r, i, a1, a2, b1, b2) {
  AtwoProduct(r, i, a1, b1);
  const p1 = r[i];
  const p2 = r[i+1];
  Afast2Sum(r, i, p1, p2 + a1 * b2 + b1 * a2);
}

function AqdSet(r, i, a1, a2) {
  r[i] = a1;
  r[i+1] = a2;
}

function AqdcCopy(r, i, s, si) {
  r[i] = s[si];
  r[i+1] = s[si+1];
  r[i+2] = s[si+2];
  r[i+3] = s[si+3];
}

function AqdcGet(s, si) {
  return s.slice(si, si+4);
}

function AqdSquare(r, i, a1, a2) {
  AtwoSquare(r, i, a1);
  const p1 = r[i];
  const p2 = r[i+1];
  Afast2Sum(r, i, p1, p2 + 2 * a1 * a2);
}

function AqdAbsSub(r, i, a1, a2, b1, b2) {
  AqdAdd(r, i, a1, a2, -b1, -b2);
  if (r[i] + r[i+1] < 0) {
    r[i] = -r[i];
    r[i+1] = -r[i+1];
  }
}
</script>
<script>
// Start the application
const explorer = new MandelbrotExplorer();
explorer.start();
</script>
</body>
<script src="https://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-242212-1";
urchinTracker();
</script>
</html>
