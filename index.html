<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>Mandelbrot Set Fractal Explorer</title>
<meta name="description" content="Beautiful, fast, and precise exploration of the Mandelbrot Set online. Click to zoom. Hover to see orbits. M makes a smooth movie of your zoom path.">
<meta name="viewport" content="width=device-width">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="shortcut icon" type="image/png" href="favicon-128x128.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="favicon-180x180.png">
<link rel="apple-touch-icon" type="image/png" sizes="192x192" href="favicon-192x192.png">
<link rel="apple-touch-icon" type="image/png" sizes="512x512" href="favicon-512x512.png">
<link rel="canonical" href="https://mandelbrot.page/">
<!--
Written by David Bau as a Javascript example in 2009; updated in 2020
to handle high device pixel ratios, show orbits, and report periodicity.
Keyboard controls added in 2022, and quad-precision perturbations,
additional exponents, movie generation and web workers added in 2024.
Claude code added GPU support in 2025.

URL options: use ?grid=3           to select 3-column view,
                    &c=-0.14-0.65i to set center (can chain: c=re+im,re+im,...),
                    &z=25          to set zoom (1.0=default, higher=more zoomed),
                    &a=16:9        to set aspect ratio (default is 1:1 square),
             &exponent=3           to set exponent (default is 2),
                &theme=fire        to set color theme (fire/ocean/forest/purple/grayscale),
                  &unk=000         to set unknown pixel color (hex color or CSS color name),
                    &h=1,2         to hide views by index (comma-separated),
           &pixelratio=2           to set subpixel resolution,
                 &lang=es          to set language (en/es/zh/zh-tw/ar/id/pt/fr/ja/ru/de),
                  &gpu=0           to disable GPU acceleration,
            and &board=gpuzhuoran  to force algorithm (cpu/gpu/gpuzhuoran/zhuoran/perturbation).

Implementation notes.  To minimize computation, the code identifies both
points that diverge and points that converge.  It uses a method that can
identify convergence to periodic cycles of arbitrarily long length.
After the number of unknown points is less than half the visual field,
it computes the remaining points sparsely, avoiding iterating over the
already-known points.
-->
<style>
body { font-family: Arial; background: #888; margin: 14px; text-align: center; }
canvas { vertical-align:bottom; cursor:crosshair; user-select: none; }
#grid > div, #text { display: inline-block; margin: 10px;
  position: relative; vertical-align: top; background: rgba(90, 90, 90, 0.5); }
#movie > div { display: inline-block; margin: 10px;
  position: relative; vertical-align: top; background: black; }
#grid { color: yellow; }
#grid > div:only-child .closebox { display: none; }
#grid:empty ~ #text { display: none; }
#text { text-align: left; width: auto; background:#aaa; margin: 10px;
  position:relative;padding:3px 8px;font-size: 11pt; }
.exponent { line-height: 0; }
.closebox { position: absolute; right: 3px; top: 0; cursor: pointer;
  transition: opacity 0.3s; user-select: none; }
.closebox:after { content: '\00d7'; font-size: 20px; }
.closebox:active:after { -webkit-text-stroke: 2px; opacity: 0.8; }
.closebox:hover { font-weight: bold; }
.rect { position: absolute; height: 0; width: 0;
  pointer-events: none; opacity: 0.7; transition: opacity 0.3s; }
.rect:after { content: ''; display: block; position: absolute;
  top: 0; bottom: 0; left: 0; right: 0; border: 1px solid yellow;
  box-shadow: 0px 0px 4px 1px #880; }
.circle .rect:after { border-radius: 100px; }
.hidemarks .rect { opacity: 0; }
.overlay { position: absolute; pointer-events: none; opacity: 0.8;
  top:0; left:0; z-index:1; transition: opacity 0.3s; }
.zoomnum { position:absolute; display:inline-block; right:0; bottom:-11pt;
  text-decoration: none; font-size: 11pt; color: yellow; min-width: 25%;
  text-align:right; transition: opacity 0.3s; z-index: 1; cursor: pointer;
  user-select: none; }
.zoomnum[href]:hover { text-decoration: underline; }
body.hidemarks .overlay { opacity: 0; }
body.hidemarks #grid .zoomnum { opacity: 0; }
body.hidemarks #grid .closebox { opacity: 0; }
div a div.status { /* tooltips */
  display: none; position: absolute; top: 17px; right: 0;
  width: auto; background-color: #ddd; color: #444;
  font: 11pt Arial; text-align: right; white-space: pre;
  padding: 3px 7px; box-shadow: 2px 2px 5px #777;
  /* pointer-events: none; */ z-index: 2;
  opacity: 0; transition: opacity 0.25s ease; }
#grid div:hover a div.status {
  display: block; }
div:hover a:focus div.status, div a:hover div.status {
  display: block;
  opacity: 0.95; }
body.starting div#b_0:after { display: flex; position: absolute;
  top: 0; left: 0; width: 100%; height: 100%; align-items: center;
  justify-content: center; content:"Starting..."; color: white;
  z-index: -1; background: rgb(32,16,64); }
#moviestatus { position: absolute; left: 0; bottom: -11pt; font-size: 11pt; color: yellow; }
#fullscreen-button { position: fixed; bottom: 20px; right: 20px; font-size: 36px;
  cursor: pointer; user-select: none; opacity: 0.7; transition: opacity 0.3s;
  color: white; font-weight: bold; z-index: 10; display: none; }
#fullscreen-button:hover { opacity: 1; }
:fullscreen #fullscreen-button { display: none !important; }
/* Fullscreen mode adjustments */
:fullscreen { margin: 0; padding: 0; scroll-snap-type: y proximity; overflow-y: scroll; }
:fullscreen body { margin: 0; padding: 0; }
:fullscreen #grid { margin: 0; padding: 0; }
:fullscreen #grid > div { margin: 0; padding: 0; background: transparent; scroll-snap-align: start; scroll-snap-stop: normal; }
:fullscreen #movie > div { margin: 0; padding: 0; background: black; scroll-snap-align: start; }
:fullscreen #text { scroll-snap-align: start; }
:fullscreen canvas { display: block; }
:fullscreen .zoomnum { bottom: 0; }
:fullscreen #moviestatus { bottom: 0; }
:fullscreen div a div.status { top: auto; bottom: 100%; }
</style>
</head>
<body class="starting">
<div id=movie></div>
<div id=grid></div>
<div id=fullscreen-button title="Enter fullscreen (Enter)">â›¶</div>
<div id=text style="max-width: 442px">
<div class=closebox></div>

<div lang="en">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Mandelbrot Set Fractal Explorer
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Tap">Click</span> to zoom.</b>  <span mobile="">Right-click to save images, <b>M</b> to make and save a movie of your zoom path.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> is iterated for each <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">complex number</a> <em>c</em>.  Colors show <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iterations</a> to divergence; black points <a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">converge or cycle</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Yellow dots show <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbits</a></b>.  Red dots show limit cycles.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>About iterations.</b> This viewer shows more fractal detail over time by refining iterations to infinity as you explore. The longer you wait, the more detail is shown.
After thousands or millions of iterations, you can resolve the finest details in the most complex parts of the fractal.
See information on iterations, progress, and coordinates by <span mobile="tapping">hovering over</a> the yellow zoom number under each window.
<span mobile="Holding your fingertip">Moving your mouse</span> over fractal content will animate the orbit of <em>z</em> values for each location <em>c</em>, revealing the complex boundary dynamics that have fascinated mathematicians.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Exploring a zoom path.</b>
Each <span mobile="tap">click</span> on the fractal opens a higher zoom level at the selected location, computed on your GPU if available.
After you zoom beyond trillion-fold magnification, we use a quad-precision perturbation algorithm that resolves fine details to more than 30 digits of accuracy.
Once you have crafted an interesting path that shows the detail you want, you can <a class="moviemode">create and download your own Mandelbrot deep zoom video</a> or bookmark your URL to save and share your exploration.
To create high-quality images and videos, this viewer computes subpixels with a <span class="pixelratio">2</span>:1 ratio<span mobile="">, and that can be increased to create more precise displays</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>More commands:</b>
<b>I</b> zooms in;
<b mac="&#8984;">Ctrl</b>-click to zoom in-place;
<b>H</b> shrinks and <b>G</b> grows each window;
<b>R</b> reopens midway windows;
<b>C</b> recenters all;
<b>T</b> changes color theme;
<b>U</b> highlights unfinished pixels;
<b mac="Return">Enter</b> toggles full-screen;
<b>X</b> increases and <b>Z</b> decreases the <em>z</em> exponent;
<b>F</b> increases and <b>D</b> decreases the pixel ratio;
<b>A</b> toggles aspect ratio;
<b>M</b> makes a movie that follows your path;
<nobr><b>?</b> shows this help.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<script>
class Config {
  constructor() {
    document.body.style.overflowY = 'scroll';
    this.vw = document.documentElement.clientWidth || (
       window.innerWidth - 20);
    document.body.style.overflowY = '';
    this.dgc = Math.min(2, Math.ceil(this.vw / 501));
    this.gridcols = this.dgc;
    this.exponent = 2;
    this.enableGPU = true;
    this.forceBoard = null;  // Explicit board type: 'cpu', 'zhuoran', 'perturbation', 'gpu', 'gpuzhuoran'
    this.firstr = [-0.5, 0];
    this.firstj = [0.0, 0];
    this.firstsize = 3.0;
    this.pixelRatio = Math.max(Math.ceil(window.devicePixelRatio || 1), 2);
    this.zoomfactor = 5;
    this.aspectRatio = 1.0;  // 1.0 for square, 16/9 for widescreen
    this.cssDims = 0;
    this.cssDimsWidth = 0;
    this.cssDimsHeight = 0;
    this.dims = 0;  // Deprecated: use dimsWidth
    this.dimsWidth = 0;
    this.dimsHeight = 0;
    this.dims2 = 0;
    this.ukcs = ["#000", "#888", "#fff", "yellow", "red", "rgb(32,16,64)"];
    this.theme = 'warm';
    this.unknowncolor = "#000";
    this.mobile = ('ontouchstart' in document.documentElement);
    this.mac = (navigator.platform.indexOf('Mac') == 0);
    this.defineColorThemes();
  }

  defineColorThemes() {
    this.colorThemes = {
      warm: (i, frac, fracD, fracL, s) => {
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        let hue = (Math.log(i + 20) * 200) % 360;
        let chroma = 100;
        let light = 15 * frac + 85 * frac ** 5;
        return hclColor(hue, chroma, light);
      },
      iceblue: (i, frac, fracD, fracL, s) => {
        // Current implementation
        let ff = Math.pow(frac, 2);
        let fr = Math.pow(frac, 0.333);
        let fg = Math.pow(frac, 3);
        let g = intcolor(Math.max(fg, Math.min(fr, i * Math.pow(s, 0.33) / 64)));
        let r = intcolor(Math.min(fr, i * Math.pow(s, 0.22) / 64));
        let b = intcolor(ff / 3 + 0.667);
        return `rgb(${r},${g},${b})`;
      },
      tiedye: (i, frac, fracD, fracL, s) => {
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        let hue = (Math.log(i + 20) * 1000) % 360;
        let chroma = 100;
        let light = 25 * frac + 75 * frac ** 5;
        return hclColor(hue, chroma, light);
      },
      gray: (i, frac, fracD, fracL, s) => {
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        let value = intcolor(0.15 + 0.85 * frac ** 5);
        return `rgb(${value},${value},${value})`;
      },
      // Add more color themes here
    };
    this.colorThemes.all = Object.keys(this.colorThemes);
  }

  initSizes() {
    // In fullscreen, use full window dimensions with no margins
    if (document.fullscreenElement) {
      const availWidth = window.innerWidth;
      const availHeight = window.innerHeight;

      // Directly set width and height to fill the viewport
      this.cssDimsWidth = availWidth;
      this.cssDimsHeight = availHeight;
      this.cssDims = this.cssDimsWidth;  // For compatibility
    } else {
      this.cssDims = Math.max(32, Math.floor((this.vw - 28) / this.gridcols) - 20);

      // Calculate width and height based on aspect ratio
      if (this.aspectRatio >= 1.0) {
        // Wider than tall
        this.cssDimsWidth = this.cssDims;
        this.cssDimsHeight = Math.floor(this.cssDims / this.aspectRatio);
      } else {
        // Taller than wide
        this.cssDimsHeight = this.cssDims;
        this.cssDimsWidth = Math.floor(this.cssDims * this.aspectRatio);
      }
    }

    this.dimsWidth = Math.floor(this.cssDimsWidth * this.pixelRatio);
    this.dimsHeight = Math.floor(this.cssDimsHeight * this.pixelRatio);
    this.dims = this.dimsWidth;  // Deprecated: for backward compatibility
    this.dims2 = this.dimsWidth * this.dimsHeight;

    // Calculate firstsize to ensure we fit width extent of 3 and height extent of 2.5
    // Width constraint: size must be at least 3.0
    // Height constraint: size / aspectRatio must be at least 2.5, so size >= 2.5 * aspectRatio
    this.firstsize = Math.max(3.0, 2.5 * this.aspectRatio);
    for (let el of document.getElementsByClassName('pixelratio')) {
      el.innerText = this.pixelRatio;
    }
    for (let el of document.querySelectorAll('#text')) {
      const minHelpWidth = 390;
      const helpColumns = Math.ceil((minHelpWidth + 36) / (this.cssDims + 20));
      // Columns plus margin minus padding
      el.style.maxWidth = ((this.cssDims + 20) * helpColumns - 20 - 16) + 'px';
    }
  }

  updateExponent(newExponent) {
    if (newExponent < 2) { return; }
    this.exponent = newExponent;
    for (let el of document.getElementsByClassName('exponent')) {
      el.innerText = this.exponent;
    }
    // Update default center based on exponent
    this.firstr = [this.exponent > 2 ? 0.0 : -0.5, 0];
    this.firstj = [0.0, 0];
  }

  firststate() {
    return {sizes:[[this.firstsize, this.firstr, this.firstj]], hidden:[]};
  }
}

class View {
  constructor(k, size, re, im, config, id, grid = null) {
    this.k = k;
    this.id = id;
    this.config = config;
    this.grid = grid;
    this.convergedData = new Map();

    // Multi-resolution compositing
    this.parentView = null;
    this.childView = null;

    this.initview(size, re, im);
    this.workerInfo = 'no worker';
    this.boardType = null;
  }

  // Static helper: lookup histogram fractions for a given iteration count
  static lookupHistogram(i, histogram) {
    let j = 0;
    for (; j < histogram.length - 1 && i < histogram[j][0]; j += 1) {}
    // Clamp to last valid index if iteration exceeds histogram range
    j = Math.min(j, histogram.length - 1);
    return {
      fracK: 1 - histogram[j][1],  // Fraction known
      fracD: 1 - histogram[j][2],  // Fraction diverged
      fracL: 1 - histogram[j][3]   // Estimated limit on fracD
    };
  }

  initview(size, re, im) {
    this.sizes = [size, toQd(re), toQd(im)];
    this.nn = new Array(this.config.dims2).fill(0);
    this.un = this.config.dims2;
    this.di = 0;
    this.ch = 0;
    this.it = 0;
    this.hi = [[0, 1, 1, 0]];
    this.convergedData.clear();
  }

  setParentView(parentView) {
    this.parentView = parentView;
    if (parentView) {
      parentView.childView = this;
    }
  }

  updateFromWorkerResult(data) {
    const changedIndices = [];

    for (let change of data.changeList) {
      for (let index of change.nn) {
        this.nn[index] = change.iter;
        changedIndices.push(index);
      }
      for (let v of change.vv) {
        this.nn[v.index] = -change.iter;
        this.convergedData.set(v.index, { z: toQdc(v.z), p: v.p });
        changedIndices.push(v.index);
      }
      this.di += change.nn.length;
      this.un -= change.nn.length + change.vv.length;
      this.updateHistogram(this.un, this.di, change.iter);
    }
    this.un = data.un;
    this.di = data.di;
    this.ch = data.ch;
    this.it = data.it;
    this.workerInfo = data.workerInfo;
    if (data.boardType) {
      this.boardType = data.boardType;
    }

    // Propagate updates to child view
    if (this.childView && changedIndices.length > 0) {
      this.updateChildPixels(changedIndices);
    }
  }

  updateChildPixels(parentIndices) {
    // No-op: child computes its own pixels, no need for parent updates
  }

  currentc(j) {
    const x = j % this.config.dimsWidth;
    const y = Math.floor(j / this.config.dimsWidth);
    const rFrac = (x / this.config.dimsWidth) - 0.5;
    const jFrac = 0.5 - (y / this.config.dimsHeight);
    // Scale real coordinate by full size, imaginary by size/aspectRatio
    const r = qdAdd(this.sizes[1], qdScale(toQd(rFrac), this.sizes[0]));
    const heightScale = this.sizes[0] / this.config.aspectRatio;
    const i = qdAdd(this.sizes[2], qdScale(toQd(jFrac), heightScale));
    return [r[0], r[1], i[0], i[1]];
  }

  currentz(j) {
    const data = this.convergedData.get(j);
    return data ? data.z : null;
  }

  currentp(j) {
    const data = this.convergedData.get(j);
    return data ? data.p : null;
  }

  updateHistogram(un, di, i) {
    if (this.hi[0][1] - un / this.config.dims2 >= 1 / 256) {
      const uFrac = un / this.config.dims2;
      const dFrac = 1 - di / this.config.dims2;
      this.hi.unshift([i, uFrac, dFrac, 0]);
      if (this.hi.length > 10) {
        // Estimate the limit of di as i goes to infinity.
        const sample = this.hi.slice(0, this.hi.length - 2).map(
           (e, i) => ({ x: e[0], y: e[2], weight: (e[0] - this.hi[i+1][0]) ** 4 })
        ).reverse();
        const estimate = Math.min(1, Math.max(0, estimateLimit(sample)));
        // Smooth the estimate.
        const avg = (estimate + this.hi[1][3] * 4) / 5;
        this.hi[0][3] = avg;
      }
    }
  }

  draw(ctx, colorview = null, unknownColor = 'transparent') {
    if (colorview === null) {
      colorview = this;
    }

    // Draw composite: parent pixels + local pixels
    if (this.parentView) {
      this.drawComposite(ctx, colorview, unknownColor);
    } else {
      // No parent, just draw normally
      this.drawLocal(ctx, colorview, unknownColor);
    }
  }

  drawLocal(ctx, colorview = null, unknownColor = 'transparent') {
    // Draw only locally computed pixels
    if (colorview === null) {
      colorview = this;
    }
    const n = this.nn;
    const msort = n.map((v, i) => i).sort((a, b) => n[a] - n[b]);
    let prev = null;
    for (let m of msort) {
      const x = m % this.config.dimsWidth;
      const y = (m - x) / this.config.dimsWidth;
      const cur = n[m];
      if (prev !== cur) {
        ctx.fillStyle = colorview.makecolor(cur, null, null, unknownColor);
        prev = cur;
      }
      ctx.fillRect(x, y, 1, 1);
    }
  }

  drawComposite(ctx, colorview = null, unknownColor = 'transparent') {
    // Draw parent canvas scaled as background, then local pixels on top
    if (colorview === null) {
      colorview = this;
    }

    // Clear canvas
    ctx.clearRect(0, 0, this.config.dimsWidth, this.config.dimsHeight);

    // Draw scaled parent canvas as background, but inflate unknown parent pixels
    // to avoid showing fuzzy boundary pixels
    if (this.parentView && this.grid) {
      const parent = this.parentView;
      const parentCanvas = this.grid.canvas(parent.k);

      if (parentCanvas) {
        // Calculate which portion of parent canvas maps to this child view
        const childCenter = this.sizes.slice(1);
        const childSize = this.sizes[0];
        const parentCenter = parent.sizes.slice(1);
        const parentSize = parent.sizes[0];

        const childLeft = childCenter[0][0] - childSize / 2;
        const childTop = childCenter[1][0] + (childSize / this.config.aspectRatio) / 2;
        const parentLeft = parentCenter[0][0] - parentSize / 2;
        const parentTop = parentCenter[1][0] + (parentSize / this.config.aspectRatio) / 2;

        const sx = ((childLeft - parentLeft) / parentSize) * this.config.dimsWidth;
        const sy = ((parentTop - childTop) / (parentSize / this.config.aspectRatio)) * this.config.dimsHeight;
        const sw = (childSize / parentSize) * this.config.dimsWidth;
        const sh = (childSize / parentSize) * this.config.dimsHeight;

        // Create a temporary canvas at 3x parent resolution for finer inflation control
        const upsample = 3;

        // Calculate source dimensions in parent pixels (integer + 2px padding)
        const srcW = Math.ceil(sw) + 2;
        const srcH = Math.ceil(sh) + 2;

        // Dest must be exactly 3x source for proper pixel alignment
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = srcW * upsample;
        tempCanvas.height = srcH * upsample;
        const tempCtx = tempCanvas.getContext('2d');

        // Draw parent region upsampled 3x (with 1px padding at parent resolution)
        tempCtx.drawImage(parentCanvas,
          Math.floor(sx) - 1, Math.floor(sy) - 1,
          srcW, srcH,
          0, 0, srcW * upsample, srcH * upsample);

        // Inflate unknown parent pixels and diverged/converged boundaries
        const parentData = parent.nn;
        for (let py = Math.floor(sy) - 1; py < Math.ceil(sy + sh) + 1; py++) {
          for (let px = Math.floor(sx) - 1; px < Math.ceil(sx + sw) + 1; px++) {
            if (px >= 0 && px < this.config.dimsWidth && py >= 0 && py < this.config.dimsHeight) {
              const parentIdx = py * this.config.dimsWidth + px;
              const val = parentData[parentIdx];
              let shouldClear = false;

              // Clear if unknown
              if (val === 0) {
                shouldClear = true;
              } else {
                // Check for diverged/converged boundary
                const isDiverged = val > 0;
                const isConverged = val < 0;

                // Check 4-connected neighbors for opposite type
                const neighbors = [
                  py > 0 ? parentData[(py - 1) * this.config.dimsWidth + px] : null,
                  py < this.config.dimsHeight - 1 ? parentData[(py + 1) * this.config.dimsWidth + px] : null,
                  px > 0 ? parentData[py * this.config.dimsWidth + (px - 1)] : null,
                  px < this.config.dimsWidth - 1 ? parentData[py * this.config.dimsWidth + (px + 1)] : null,
                ];

                for (const n of neighbors) {
                  if (n !== null && n !== 0) {
                    if ((isDiverged && n < 0) || (isConverged && n > 0)) {
                      shouldClear = true;
                      break;
                    }
                  }
                }
              }

              if (shouldClear) {
                // Clear pixel and 1-pixel margin at upsampled resolution
                // Each parent pixel maps to a 3x3 block, plus 1px inflation = 5x5 area
                const tx = (px - Math.floor(sx) + 1) * upsample;
                const ty = (py - Math.floor(sy) + 1) * upsample;
                for (let dy = -1; dy < upsample + 1; dy++) {
                  for (let dx = -1; dx < upsample + 1; dx++) {
                    tempCtx.clearRect(tx + dx, ty + dy, 1, 1);
                  }
                }
              }
            }
          }
        }

        // Draw the masked parent pixels scaled to child canvas (faded)
        // Account for fractional pixel offset within the temp canvas
        // sx, sy may be fractional (e.g., 10.3), so child's edge isn't at an integer parent pixel
        const fracX = sx - Math.floor(sx);  // Fractional part (e.g., 0.3)
        const fracY = sy - Math.floor(sy);
        const tempSrcX = upsample + fracX * upsample;  // e.g., 3 + 0.3*3 = 3.9
        const tempSrcY = upsample + fracY * upsample;

        ctx.globalAlpha = 0.5;  // 50% opacity for parent pixels
        ctx.drawImage(tempCanvas,
          tempSrcX, tempSrcY,
          (srcW - 2) * upsample, (srcH - 2) * upsample,
          0, 0, this.config.dimsWidth, this.config.dimsHeight);
        ctx.globalAlpha = 1.0;  // Restore full opacity
      }
    }

    // Draw local computed pixels on top (using child's palette)
    this.drawLocal(ctx, colorview, unknownColor);
  }

  clearcanvas(ctx) {
    // For views with parents, use composite drawing
    // For root views, just clear (div background shows through)
    if (this.parentView) {
      this.drawComposite(ctx);
    } else {
      ctx.clearRect(0, 0, this.config.dimsWidth, this.config.dimsHeight);
    }
  }

  drawchange(ctx, change) {
    if (change.nn.length) {
      ctx.fillStyle = this.makecolor(change.iter);
      for (let m of change.nn) {
        const x = m % this.config.dimsWidth;
        const y = (m - x) / this.config.dimsWidth;
        ctx.fillRect(x, y, 1, 1);
      }
    }
    if (change.vv.length) {
      ctx.fillStyle = this.makecolor(-change.iter);
      for (let v of change.vv) {
        const x = v.index % this.config.dimsWidth;
        const y = (v.index - x) / this.config.dimsWidth;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  }

  drawcolor(ctx, i) {
    let color = this.makecolor(i);
    let converged = this.makecolor(-i);
    let n = this.nn;
    for (let m = 0; m < this.config.dims2; ++m) {
      if (n[m] == i || n[m] == -i) {
        let x = m % this.config.dimsWidth;
        let y = (m - x) / this.config.dimsWidth;
        ctx.fillStyle = n[m] > 0 ? color : converged;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  }

  makecolor(i, histogram = null, scale = null, unknownColor = 'transparent') {
    if (i == 0) return unknownColor;  // Color for uncomputed pixels
    if (i < 0) return 'black';
    // Use own histogram for consistent palette at this resolution
    const hi = histogram || this.hi;
    const size = scale || this.sizes[0];
    const fracs = View.lookupHistogram(i, hi);
    return this.config.colorThemes[this.config.theme](
       i, fracs.fracK, fracs.fracD, fracs.fracL, size);
  }

  uninteresting() {
    // Boring: nothing computed, or done with less than 5 colors
    return this.di <= 0 || (this.un == 0 && this.hi.length <= 5);
  }

  unfinished() {
    // Chaotic points in the spike counted as finished after 100000 iterations.
    const result = Math.max(0, this.un + (this.it < 100000 ? 0 : -this.ch));
    return result;
  }


  debugStatus() {
    const debugGraph = this.renderHiGraph(600, 300);
    const maxPeriod = this.convergedData.values().map(
        d => fibonacciPeriod(d.p)).reduce((a, b) => Math.max(a, b), 0);
    const maxEscape = this.nn.reduce((a, b) => Math.max(a, b), 0)
    this.nn.reduce((iMin, x, i, arr) => x < arr[iMin] ? i : iMin, 0);
    const boardName = this.boardType || 'Board';
    return `${boardName} ${this.id}:\n` +
           `${this.di} diverged, ${this.un} unfinished, ${this.ch} chaotic\n` +
           `max period ${maxPeriod}, max escape ${maxEscape}\n` +
           `${this.workerInfo}\n` +
           `<img src="${debugGraph}" style="width:300px;height:150px">`;
  }

  renderHiGraph(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    const hi = this.hi;
    const scale = [
      (y) => y / hi[Math.floor(hi.length / 8)][0] / 2,
      (y) => y,
      (y) => y,
      (y) => y,
    ];
    const barWidth = width / (hi.length * scale.length);

    // Background
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);

    // Draw bars
    const colors = ['blue', 'red', 'green', 'purple'];
    hi.forEach((row, i) => {
      row.forEach((value, j) => {
        const x = i * scale.length * barWidth + j * barWidth;
        const barHeight = scale[j](value) * (height - 20);
        ctx.fillStyle = colors[j];
        ctx.fillRect(x, height - barHeight - 10, barWidth, barHeight);
      });
    });

    // Draw x-axis
    ctx.strokeStyle = 'black';
    ctx.beginPath();
    ctx.moveTo(0, height - 10);
    ctx.lineTo(width, height - 10);
    ctx.stroke();

    // Add labels
    ctx.font = '20px Arial';
    ctx.shadowColor = 'white';
    ctx.shadowBlur = 8;
    ctx.fillStyle = 'red';
    ctx.fillText(`Undone: ${this.hi[0][1]}`, 5, 30);
    ctx.fillStyle = 'green';
    ctx.fillText(`Dark: ${this.hi[0][2]}`, 5, 60);
    ctx.fillStyle = 'purple';
    ctx.fillText(`Est: ${this.hi[0][3]}`, 5, 90);

    return canvas.toDataURL();
  }
}

class Grid {
  constructor(config) {
    this.config = config;
    this.views = [];
    this.canvascount = 0;
    this.focusk = null;
    this.urlListeners = [];
    this.zoomListeners = [];
    this.scheduler = new Scheduler(this);
  }

  makeView(k, size, re, im, deferComputation = false) {
    const id = k + Math.random();
    const view = new View(k, size, re, im, this.config, id, this);
    this.views[k] = view;

    // Set up parent-child relationship for multi-resolution compositing
    if (k > 0 && this.views[k - 1]) {
      view.setParentView(this.views[k - 1]);
    }

    if (!deferComputation) {
      this.scheduler.assignBoardToWorker(k, size, re, im, this.config, id);
    }
    return view;
  }

  startViewComputation(k) {
    // Start computation for a view (stage 3)
    const view = this.views[k];
    if (!view) return;
    this.scheduler.assignBoardToWorker(k, view.sizes[0], view.sizes[1], view.sizes[2], this.config, view.id);
  }

  removeView(k) {
    this.views[k] = null;
    let i = this.views.length - 1;
    for (i = this.views.length - 1; i >= 0; i -= 1) {
      if (this.views[i] !== null) { break; }
    }
    this.views.length = i + 1;
    this.scheduler.removeBoardFromWorker(k);
  }

  setFocusedView(k) {
    if (k != this.focusk) {
      this.focusk = k;
      this.scheduler.setFocusedBoard(k);
    }
  }

  getHiddenViews() {
    return this.views.map((v, i) =>
            this.hiddencanvas(i) ? i : -1).filter(i => i !== -1);
  }

  updateHiddenViews() {
    this.scheduler.setHiddenBoards(this.getHiddenViews());
  }

  updateViewFromWorkerResult(k, data, workerIndex) {
    if (this.views[k]) {
      if (this.views[k].id != data.id) {
        return;
      }
      this.views[k].updateFromWorkerResult(data);
      this.updateCanvas(k, data);
    }
  }

  updateCanvas(k, data) {
    const canvas = this.canvas(k);
    if (canvas && data.changeList.length) {
      const ctx = canvas.getContext('2d');
      for (let change of data.changeList) {
        this.views[k].drawchange(ctx, change);
      }
    }
  }

  currentGridState() {
    let state = { hidden: [], sizes: [] };
    for (let k = 0; k < this.views.length; k++) {
      if (this.hiddencanvas(k)) {
        state.hidden.push(k);
      }
      state.sizes.push(this.views[k].sizes);
    }
    return state;
  }

  updateLayout(state = null, skipInitSizes = false) {
    if (this.currentUpdateProcess) {
      this.currentUpdateProcess.abort();
    }
    if (state === null) {
      state = this.currentGridState();
    }
    if (!skipInitSizes) {
      this.config.initSizes();
    }

    // Recreate the grid
    let gridElement = document.getElementById('grid');
    gridElement.innerHTML = '';
    this.canvascount = 0;
    this.truncateviews(0);

    // Recreate all canvases
    for (let k = 0; k < state.sizes.length; k++) {
      this.makecanvas(k, state.sizes[k]);
      if (state.hidden.indexOf(k) >= 0) { this.hidecanvas(k); }
    }
    // Update workers with hidden boards BEFORE creating boards to prevent hidden boards from computing
    this.updateHiddenViews();
    this.currentUpdateProcess = this.createUpdateProcess(state);
    this.currentUpdateProcess.start();
  }

  createUpdateProcess(state) {
    let aborted = false;
    let currentIndex = 0;

    const processNext = () => {
      if (aborted || currentIndex >= state.sizes.length) {
        if (!aborted) {
          this.notifyurl();
          this.notifyzoom();
        }
        this.currentUpdateProcess = null;
        return;
      }

      const k = currentIndex;
      if (!this.views[k]) {
        this.views[k] = this.makeView(k, state.sizes[k][0], state.sizes[k][1], state.sizes[k][2]);
      } else {
        // View exists - generate new ID and assign new board with new dimensions
        this.views[k].id = k + Math.random();
        this.views[k].initview(state.sizes[k][0], state.sizes[k][1], state.sizes[k][2]);
        this.scheduler.assignBoardToWorker(k, state.sizes[k][0], state.sizes[k][1], state.sizes[k][2], this.config, this.views[k].id);
      }
      this.views[k].draw(this.canvas(k).getContext('2d'));
      if (state.hidden.indexOf(k) >= 0) { this.hidecanvas(k); }
      this.updateFullscreenButton();
      currentIndex++;
      setTimeout(processNext, 200);
    };

    return {
      start: () => {
        if (this.config.gridcols == 1) {
          setTimeout(processNext, 100);
        } else {
          processNext();
        }
      },
      abort: () => { aborted = true; }
    };
  }

  makecanvas(k, sizeInfo = null) {
    let gd = document.getElementById('grid');
    while (this.canvascount <= k) {
      let dd = document.createElement('div');
      dd.id = 'b_' + this.canvascount;
      dd.innerHTML = this.canvasstring(this.canvascount, sizeInfo);
      dd.className = 'hidemarks';
      dd.style.backgroundColor = this.config.unknowncolor;
      gd.appendChild(dd);
      this.canvascount += 1;
    }
  }

  canvasstring(k, sizeInfo = null) {
    // Use firstsize (which varies with aspect ratio) for display consistency
    let viewSize;
    if (k < this.views.length) {
      viewSize = this.views[k].sizes[0];
    } else if (sizeInfo && sizeInfo[0] !== null) {
      viewSize = sizeInfo[0];
    } else {
      viewSize = this.config.firstsize / Math.pow(this.config.zoomfactor, k);
    }
    let factor = this.config.firstsize / viewSize;
    factor = formatScale(factor);
    return `<canvas width="${this.config.dimsWidth}" height="${this.config.dimsHeight}"` +
           ` style="height:${this.config.cssDimsHeight}px;width:${this.config.cssDimsWidth}px;">` +
           '</canvas>' +
           '<div class="closebox"></div>' +
           '<div class="rect"></div>' +
           `<canvas class=overlay width=${this.config.dimsWidth} height="${this.config.dimsHeight}"` +
           ` style="height:${this.config.cssDimsHeight}px;width:${this.config.cssDimsWidth}px;">` +
           '</canvas>' +
           `<a class="zoomnum" target="_blank" href="?">${factor}` +
           '<div class="status"></div></a>';
  }

  hidecanvas(k) {
    this.canvas(k).parentElement.style.display = 'none';
  }

  showcanvas(k) {
    this.canvas(k).parentElement.style.display = '';
  }

  hiddencanvas(k) {
    let b = this.canvas(k);
    return b && b.parentElement.style.display == 'none';
  }

  grid() {
    return document.getElementById('grid');
  }

  canvas(k) {
    let b = document.getElementById("b_" + k);
    return b && b.firstElementChild;
  }

  closebutton(k) {
      const view = this.canvas(k);
      return view && view.nextElementSibling;
  }

  rect(k) {
      const closeBtn = this.closebutton(k);
      return closeBtn && closeBtn.nextElementSibling;
  }

  overlay(k) {
      const rect = this.rect(k);
      return rect && rect.nextElementSibling;
  }

  truncateviews(k) {
    while (this.views.length > k) {
      let removeIndex = this.views.length - 1;
      this.removeView(removeIndex);
    }
    while (this.canvascount > k) {
      let removeIndex = this.canvascount - 1;
      this.canvas(removeIndex)?.parentElement?.remove();
      this.canvascount -= 1;
    }
  }

  showAllViews() {
    for (let j = 0; j < this.canvascount; ++j) {
      this.showcanvas(j);
    }
    this.notifyzoom();
  }

  truncatehiddenviews() {
    let j = this.canvascount - 1;
    for (; j > 0; j--) {
      if (!this.hiddencanvas(j)) {
        break;
      }
    }
    this.truncateviews(j + 1);
    if (j == 0) {
      this.showcanvas(j);
    }
  }

  updateProgress(overtarget, k) {
    if (overtarget.tagName == 'A' && overtarget.classList.contains('zoomnum')) {
      if (this.config.mobile) {
        overtarget.removeAttribute('href');
      } else {
        overtarget.href = this.bigurl(k, overtarget.showDebug);
      }

      let statusDiv = overtarget.querySelector('.status');
      if (!statusDiv) return;

      if (!overtarget.matches(':hover')) {
        // (Clear text after animation transition)
        setTimeout(() => { statusDiv.textContent = ''; }, 300);
        return;
      }

      // Regular status
      // Use this.un directly for percentage (not unfinished() which subtracts chaotic pixels)
      let percentDone = Math.floor(1000 * (1.0 - this.views[k].un / this.config.dims2))/10.0;
      // Cap at 99.9% until truly complete to avoid showing 100% while still computing
      if (this.views[k].un > 0 && percentDone >= 99.9) {
        percentDone = 99.9;
      }
      let regularStatus = MSG.center_at_ +
        formatcomplex(k, this.views[k].sizes[1], this.views[k].sizes[2])
          .replaceAll('-', '\u2212') + '\n' +
        percentDone + MSG.percent_done_after_ + formatLargeInt(this.views[k].it) + MSG.iters;
      statusDiv.textContent = regularStatus;

      // Debug status
      if (overtarget.showDebug) {
        statusDiv.innerHTML += '\n' + this.views[k].debugStatus();
      }

      setTimeout(() => this.updateProgress(overtarget, k), 100);
    }
  }

  bigurl(k, debug) {
    if (k >= this.views.length) return;
    let osize = this.views[k].sizes[0];
    let zoomFactor = this.config.firstsize / osize;  // Zoom factor (1.0 = default)
    let oexp = '';
    if (this.config.exponent != 2) {
      oexp = '&exponent=' + this.config.exponent;
    }
    let ore = this.views[k].sizes[1];
    let oim = this.views[k].sizes[2];
    return '?z=' + formatSize(zoomFactor) +
           (this.config.exponent != 2 ? '&exponent=' + this.config.exponent : '') +
           '&c=' + formatcomplex(k, ore, oim) +
           (this.config.theme != 'warm' ? '&theme=' + this.config.theme : '');
  }

  clearseq(k) {
    const overlayElement = this.overlay(k);
    if (overlayElement) {
      let ctx = overlayElement.getContext('2d');
      ctx.clearRect(0, 0, this.config.dimsWidth, this.config.dimsHeight);
    }
  }

  onurlchange(callback) {
    this.urlListeners.push(callback);
  }

  notifyurl() {
    for (let cb of this.urlListeners) {
      cb();
    }
  }

  onzoomchange(callback) {
    this.zoomListeners.push(callback);
  }

  notifyzoom() {
    for (let cb of this.zoomListeners) {
      cb();
    }
  }

  updateFullscreenButton() {
    const button = document.getElementById('fullscreen-button');
    if (button && !document.fullscreenElement) {
      const gridElement = document.getElementById('grid');
      const visibleCanvases = gridElement ?
        Array.from(gridElement.children).filter(child => child.style.display !== 'none').length : 0;
      button.style.display = (visibleCanvases === 1) ? 'block' : 'none';
    }
  }
}

class ZoomManager {
  constructor(config, grid) {
    this.config = config;
    this.grid = grid;
    this.grid.onzoomchange(() => this.updateZoomRectangles());
  }

  showZoomRect(k, x, y, zf) {
    let s = this.grid.rect(k).style;
    let border = 1;
    let cssClass = '';
    if (zf > 50) {
      // Switch from rectangle to circle if the zoom area is tiny.
      zf = 25;
      cssClass = 'circle';
    }
    this.grid.rect(k).parentElement.className = cssClass;
    s.top = (y * this.config.cssDimsHeight - this.config.cssDimsHeight / 2 / zf - border) + 'px';
    s.left = (x * this.config.cssDimsWidth - this.config.cssDimsWidth / 2 / zf - border) + 'px';
    s.width = (this.config.cssDimsWidth / zf + 2 * border) + 'px';
    s.height = (this.config.cssDimsHeight / zf + 2 * border) + 'px';
  }

  removeZoomRect(k) {
    let s = this.grid.rect(k).style;
    s.top = s.left = s.width = s.height = '';
    this.grid.rect(k).parentElement.className = 'hidemarks';
  }

  updateZoomRectangles() {
    let prevView = null;
    let prevK = 0;
    for (let k = 0; k < this.grid.views.length; k++) {
      if (this.grid.hiddencanvas(k)) { continue; }
      let currView = this.grid.views[k].sizes;
      if (prevView != null) {
        let x = qdSub(currView[1], prevView[1])[0] / prevView[0] + 0.5;
        let y = 0.5 - qdSub(currView[2], prevView[2])[0] / prevView[0];
        let zf = prevView[0] / currView[0];
        this.showZoomRect(prevK, x, y, zf);
      }
      prevView = currView;
      prevK = k;
    }
    if (prevView !== null) {
      this.removeZoomRect(prevK);
    }
  }

  zoomInAtCurrentPosition(hideCurrent) {
    let k = this.grid.views.length - 1;
    if (this.grid.views[k].uninteresting()) { return; }
    let osize = this.grid.views[k].sizes[0];
    let ore = this.grid.views[k].sizes[1];
    let oim = this.grid.views[k].sizes[2];
    let rre = 0.5;
    if (k == 0 && qdEq(ore, -0.5) && qdEq(oim, 0)) {
      // Myreberg / Feigenbaum point
      ore = [-1.4011551890920506, 1.196330130384937e-17];
      rre = (ore[0] - this.grid.views[0].sizes[1][0]) / this.grid.views[0].sizes[0] + 0.5;
    }
    this.showZoomRect(k, rre, 0.5, this.config.zoomfactor);
    let nsize = osize / this.config.zoomfactor;

    // Stage 1: Create DOM and scroll immediately
    this.grid.makecanvas(k + 1);
    if (hideCurrent) {
      this.grid.canvas(k).parentElement.style.display = 'none';
      this.updateZoomRectangles();
      this.grid.updateHiddenViews();
    }
    this.grid.canvas(k + 1).parentElement.className = 'hidemarks';
    const canvas = this.grid.canvas(k + 1);
    canvas.parentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Force browser to render stage 1 before continuing
    canvas.offsetHeight; // Trigger reflow

    // Stage 2: Create view structure
    setTimeout(() => {
      let newView = this.grid.makeView(k + 1, nsize, ore, oim, true);
      this.grid.notifyurl();

      // Stage 3: Draw and start computation
      setTimeout(() => {
        newView.draw(canvas.getContext('2d'));
        this.grid.startViewComputation(k + 1);
      }, 0);
    }, 0);
  }

  cellclick(k, m, hideCurrent) {
    // Only accept clicks on cells with something computed in them.
    if (k >= this.grid.views.length || this.grid.views[k].uninteresting() ||
         this.grid.currentUpdateProcess) return;
    setTimeout(() => { this.cellclickdelay(k, m, hideCurrent); }, 1);
  }

  cellclickdelay(k, m, hideCurrent) {
    if (k >= this.grid.views.length || this.grid.currentUpdateProcess) return;
    let osize = this.grid.views[k].sizes[0];
    let ore = this.grid.views[k].sizes[1];
    let oim = this.grid.views[k].sizes[2];
    let cx = m % this.config.dimsWidth;
    let cy = (m - cx) / this.config.dimsWidth;
    this.showZoomRect(k, cx / this.config.dimsWidth, cy / this.config.dimsHeight, this.config.zoomfactor);
    this.grid.truncateviews(k + 1);
    let nsize = osize / this.config.zoomfactor;
    let nre = qdAdd(ore, [((cx / this.config.dimsWidth) - 0.5) * osize, 0]);
    let nim = qdAdd(oim, [(0.5 - (cy / this.config.dimsHeight)) * (osize / this.config.aspectRatio), 0]);

    // Stage 1: Create DOM and scroll immediately (instant visual feedback)
    this.grid.makecanvas(k + 1);
    this.grid.updateFullscreenButton();
    if (hideCurrent) {
      this.grid.canvas(k).parentElement.style.display = 'none';
      this.updateZoomRectangles();
      this.grid.updateHiddenViews();
    }
    this.grid.canvas(k + 1).parentElement.className = 'hidemarks';
    const canvas = this.grid.canvas(k + 1);
    canvas.parentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Force browser to render stage 1 before continuing
    canvas.offsetHeight; // Trigger reflow

    // Stage 2: Create view structure
    setTimeout(() => {
      let newView = this.grid.makeView(k + 1, nsize, nre, nim, true);
      this.grid.showcanvas(k + 1);
      this.grid.notifyurl();
      document.body.className = '';

      // Stage 3: Draw and start computation
      setTimeout(() => {
        newView.draw(canvas.getContext('2d'));
        this.grid.startViewComputation(k + 1);
      }, 0);
    }, 0);
  }

  centerViews(includeFirst) {
    let k = this.grid.views.length - 1;
    let ore = this.grid.views[k].sizes[1];
    let oim = this.grid.views[k].sizes[2];
    if (!includeFirst) {
      this.showZoomRect(
        0, 0.5 + (ore[0] - this.grid.views[0].sizes[1][0]) / this.grid.views[0].sizes[0],
           0.5 - (oim[0] - this.grid.views[0].sizes[2][0]) / this.grid.views[0].sizes[0],
           this.grid.views[0].sizes[0] / this.grid.views[1].sizes[0]);
    }
    for (k = includeFirst ? 0 : 1; k < this.grid.views.length - 1; k += 1) {
      this.showZoomRect(
          k, 0.5, 0.5, this.grid.views[k].sizes[0] / this.grid.views[k+1].sizes[0]);
      if (qdCompare(this.grid.views[k].sizes[1], ore) ||
          qdCompare(this.grid.views[k].sizes[2], oim)) {
        this.grid.scheduler.removeBoardFromWorker(k);
        let nsize = this.grid.views[k].sizes[0];
        this.grid.makeView(k, nsize, ore, oim);
        this.grid.views[k].clearcanvas(this.grid.canvas(k).getContext('2d'));
        this.grid.clearseq(k);
      }
    }
    this.grid.notifyurl();
  }
}

class URLHandler {
  constructor(config, grid) {
    this.config = config;
    this.grid = grid;
    this.grid.onurlchange(x => this.updateurl());
  }

  updateurl() {
    if (history.replaceState) {
      history.replaceState(null, '', this.currenturl());
    }
  }

  parseUrl() {
    let startstate = { hidden: [], sizes: [] };
    let opts = document.location.search.split('&');
    for (let j in opts) {
      let m;
      if (null !== (m = opts[j].match(/exponent=(\d+)/))) {
        this.config.exponent = Math.max(2, parseInt(m[1]));
        if (this.config.exponent > 2) { this.config.firstr = [0.0, 0]; }
        for (let el of document.getElementsByClassName('exponent')) {
          el.innerText = this.config.exponent;
        }
      }
      if (null !== (m = opts[j].match(/gpu=(\d+)/))) {
        this.config.enableGPU = parseInt(m[1]) !== 0;
      }
      if (null !== (m = opts[j].match(/board=([a-z]+)/))) {
        const boardType = m[1].toLowerCase();
        const validTypes = ['cpu', 'zhuoran', 'perturbation', 'gpu', 'gpuzhuoran'];
        if (validTypes.includes(boardType)) {
          this.config.forceBoard = boardType;
        } else {
          console.warn(`Invalid board type: ${boardType}. Valid types: ${validTypes.join(', ')}`);
        }
      }
      if (null !== (m = opts[j].match(/grid=(\d+)/))) {
        this.config.gridcols = Math.max(1, parseInt(m[1]));
      }
      if (null !== (m = opts[j].match(/a=(\d+):(\d+)/))) {
        // Parse aspect ratio from URL (e.g., a=16:9, a=3:2)
        const width = parseInt(m[1]);
        const height = parseInt(m[2]);
        if (width > 0 && height > 0) {
          this.config.aspectRatio = width / height;
        }
      }
      if (null !== (m = opts[j].match(/z=([-+]?\d?\.?\d+(?:e[-+]\d+)?)/))) {
        // z is the zoom factor (1.0 = default zoom)
        // Store the zoom factor temporarily; will convert to absolute size after initSizes()
        this.config.zoomFromUrl = parseFloat(m[1]);
      }
      if (null !== (m = opts[j].match(/s=([-+]?\d?\.?\d+(?:e[-+]\d+)?)/))) {
        // Legacy parameter: s is the actual size in complex plane
        // Convert to zoom factor: z = 3.0 / s
        this.config.zoomFromUrl = 3.0 / parseFloat(m[1]);
      }
      if (null !== (m = opts[j].match(/pixelratio=(\d+)/))) {
        this.config.pixelRatio = Math.max(1, parseInt(m[1]));
      }
      if (null !== (m = opts[j].match(/c=([-+\d\.ei,]+)/))) {
        for (let coords of m[1].split(',')) {
          m = coords.match(/([-+]?\d?\.?\d+(?:e[-+]\d+)?)(?:([-+]\d?\.?\d+(?:e[-+]\d+)?)i)?/);
          // Store coordinates; size will be calculated later after relativeScale is applied
          startstate.sizes.push([
            null,  // Placeholder - will be filled in after initSizes()
            m != null && m[1] ? qdParse(m[1]) : (startstate.sizes.length > 0 ?
                startstate.sizes[startstate.sizes.length - 1][1] : this.config.firstr),
            m != null && m[2] ? qdParse(m[2]) : (startstate.sizes.length > 0 ?
                startstate.sizes[startstate.sizes.length - 1][2] : this.config.firstj)
          ]);
        }
      }
      if (null !== (m = opts[j].match(/h=([\d,]+)/))) {
        startstate.hidden = m[1].split(',').map(x=>parseInt(x));
      }
      if (null !== (m = opts[j].match(/theme=(\w+)/))) {
        if (this.config.colorThemes.all.includes(m[1])) {
          this.config.theme = m[1];
        }
      }
      if (null !== (m = opts[j].match(/unk=([^&]+)/))) {
        // Allow any CSS color (e.g., 000, rgb(32,16,64), yellow, etc.)
        let color = decodeURIComponent(m[1]);
        // Auto-prepend # for hex colors (e.g., 888 -> #888)
        if (/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$/.test(color)) {
          color = '#' + color;
        }
        this.config.unknowncolor = color;
      }
    }
    // Don't fill in default sizes yet - wait until after initSizes()
    // so that firstsize accounts for aspect ratio
    return startstate;
  }

  currenturl() {
    let state = this.grid.currentGridState();
    let compactc = '';
    let commas = '';
    let prev = [this.config.firstr, this.config.firstj];
    let prevj = -1;
    for (let j = 0; j <= state.sizes.length; j++) {
      if (j < state.sizes.length &&
          !qdCompare(state.sizes[j][1], prev[0]) &&
          !qdCompare(state.sizes[j][2], prev[1])) {
        commas += ',';
      } else {
        if (prevj >= 0) {
          compactc += formatcomplex(j - 1, state.sizes[prevj][1], state.sizes[prevj][2]) + ',';
        }
        compactc += commas;
        if (j < state.sizes.length) {
          commas = '';
          prev = [state.sizes[j][1], state.sizes[j][2]];
          prevj = j;
        }
      }
    }
    compactc = compactc.slice(0, -1);
    // Calculate zoom factor for URL (z parameter)
    let zoomFactor = this.config.firstsize / this.grid.views[0].sizes[0];

    // Format aspect ratio for URL (only if not 1:1)
    let aspectRatioParam = '';
    if (this.config.aspectRatio !== 1.0) {
      const [num, den] = toSimpleFraction(this.config.aspectRatio);
      aspectRatioParam = `&a=${num}:${den}`;
    }

    let url =
           (Math.abs(zoomFactor - 1.0) > 0.01 ? '&z=' + formatSize(zoomFactor) : '') +
           aspectRatioParam +
           (this.config.exponent != 2 ? '&exponent=' + this.config.exponent : '') +
           (!this.config.enableGPU ? '&gpu=0' : '') +
           (this.config.forceBoard ? '&board=' + this.config.forceBoard : '') +
           (compactc.length ? '&c=' + compactc : '') +
           (this.config.gridcols != this.config.dgc ? '&grid=' + this.config.gridcols : '') +
           (state.hidden.length ? '&h=' + state.hidden : '') +
           (this.config.theme != 'warm' ? '&theme=' + this.config.theme : '') +
           (this.config.unknowncolor != '#000' ? '&unk=' + encodeURIComponent(
             /^#[0-9a-fA-F]{3}$|^#[0-9a-fA-F]{6}$/.test(this.config.unknowncolor)
               ? this.config.unknowncolor.substring(1)
               : this.config.unknowncolor
           ) : '') +
           (this.config.pixelRatio != 2 ? '&pixelratio=' + this.config.pixelRatio : '') +
           (LANG_FROM_URL ? '&lang=' + SELECTED_LANG : '');
    return '?' + url.replace('&', '');
  }
}

class EventHandler {
  constructor(explorer) {
    this.explorer = explorer;
  }

  setup() {
    document.onmousedown = this.onmousedown.bind(this);
    document.onmousemove = this.onmousemove.bind(this);
    document.body.onkeydown = this.onkeydown.bind(this);
    document.body.onmouseover = this.onmouseover.bind(this);
    document.body.onmousedown = (e) => {
      if (e.target.className == 'closebox') {
        e.stopPropagation();
      }
    };
    document.body.onclick = (e) => {
      if (e.target.className == 'closebox' && !explorer.grid.currentUpdateProcess) {
        e.target.parentElement.style.display = 'none';
        this.explorer.grid.truncatehiddenviews();
        this.explorer.zoomManager.updateZoomRectangles();
        this.explorer.grid.updateHiddenViews();
        this.explorer.grid.updateFullscreenButton();
        this.explorer.urlHandler.updateurl();
      }
    };
  }

  onmousedown(e) {
    let target = this.eventtarget(e);
    if (this.explorer.movieMode.active && (!target || target.id != 'moviescale')) {
      this.explorer.movieMode.toggle();
    }
    if (e.button != 0) { return true; }
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (e.target.tagName == 'A') {
        if (m && !this.explorer.config.mobile) {
          e.target.href = this.explorer.grid.bigurl(m[1], e.metaKey || e.ctrlKey);
        }
        return true;
      }
      if (m) {
        let p = this.pointInTarget(e, target);
        let k = parseInt(m[1]);
        // Clear orbit before creating new view
        this.explorer.orbitComputer.updateOrbit(k, -1, target);
        this.explorer.zoomManager.cellclick(k, p.x + p.y * this.explorer.config.dimsWidth,
          e.metaKey || e.ctrlKey);
        return false;
      }
    }
    return true;
  }

  onmousemove(e) {
    let target = this.eventtarget(e);
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (m) {
        let p = this.pointInTarget(e, target);
        let k = parseInt(m[1]);
        let j = p.x + p.y * this.explorer.config.dimsWidth;
        this.explorer.orbitComputer.updateOrbit(k, j, target);
      }
    }
  }

  onkeydown(e) {
    if (this.explorer.movieMode.active &&
        ['Shift', 'Alt', 'Control', 'Meta', 'CapsLock'].indexOf(e.key) == -1) {
      this.explorer.movieMode.toggle();
      return;
    }
    // Pressing backspace will delete the last zoom.
    if (e.key == 'Backspace' && this.explorer.grid.views.length > 1 &&
        !this.explorer.grid.currentUpdateProcess) {
      let k = this.explorer.grid.views.length - 1;
      this.explorer.grid.truncateviews(k);
      this.explorer.grid.truncatehiddenviews();
      this.explorer.urlHandler.updateurl();
    }
    // Pressing C will center all the zoom positions.
    if (e.key == 'c' && this.explorer.grid.views.length > 1) {
      this.explorer.zoomManager.centerViews(e.metaKey || e.ctrlKey);
    }
    // Pressing A will toggle aspect ratio between square and 16:9
    if (e.key.toLowerCase() == 'a' && !this.explorer.grid.currentUpdateProcess) {
      const oldFirstsize = this.explorer.config.firstsize;
      this.explorer.config.aspectRatio = this.explorer.config.aspectRatio === 1.0 ? 16/9 : 1.0;
      this.explorer.config.initSizes();  // Recalculate sizes including firstsize
      const newFirstsize = this.explorer.config.firstsize;

      // Scale all existing view sizes proportionally
      const state = this.explorer.grid.currentGridState();
      const scaleFactor = newFirstsize / oldFirstsize;
      for (let i = 0; i < state.sizes.length; i++) {
        state.sizes[i][0] *= scaleFactor;
      }

      this.explorer.grid.updateLayout(state);  // Update with rescaled views
      this.explorer.urlHandler.updateurl();
    }
    // Pressing T will cycle through the color themes.
    if (e.key.toLowerCase() == 't') {
      this.explorer.cycleColorTheme(e.shiftKey);
    }
    // Pressing U will cycle through the uncomputed colors.
    if (e.key.toLowerCase() == 'u') {
      this.explorer.cycleUnknownColor(e.shiftKey);
    }
    // Pressing I will zoom in at the same position.
    if (e.key == 'i') {
      this.explorer.zoomManager.zoomInAtCurrentPosition(e.metaKey || e.ctrlKey);
    }
    // Pressing ? will show the help window
    if (e.key == '?') {
      document.getElementById('text').style.display = 'block';
      document.getElementById('text').scrollIntoView({ behavior: 'smooth' });
    }
    // G reduces the grid column count
    if (e.key === 'g' && this.explorer.config.gridcols > 1 &&
        !this.explorer.grid.currentUpdateProcess) {
      this.explorer.config.gridcols -= 1;
      this.explorer.grid.updateLayout();
    }
    // H increases the grid column count
    if (e.key === 'h' && !this.explorer.grid.currentUpdateProcess) {
      this.explorer.config.gridcols += 1;
      this.explorer.grid.updateLayout();
    }
    // R will restore any hidden views
    if (e.key === 'r' && !this.explorer.grid.currentUpdateProcess) {
      this.explorer.grid.showAllViews();
      this.explorer.urlHandler.updateurl();
      this.explorer.grid.updateHiddenViews();
    }
    // Increase the exponent
    if (e.key === 'x') {
      this.explorer.config.updateExponent(this.explorer.config.exponent + 1);
      this.explorer.grid.updateLayout(this.explorer.config.firststate());
    }
    // Decrease the exponent
    if (e.key === 'z' && this.explorer.config.exponent > 2) {
      this.explorer.config.updateExponent(this.explorer.config.exponent - 1);
      this.explorer.grid.updateLayout(this.explorer.config.firststate());
    }
    // Increase the pixel ratio
    if (e.key === 'f') {
      this.explorer.config.pixelRatio += 1;
      this.explorer.grid.updateLayout();
    }
    // Decrease the pixel ratio
    if (e.key === 'd' && this.explorer.config.pixelRatio > 1) {
      this.explorer.config.pixelRatio -= 1;
      this.explorer.grid.updateLayout();
    }
    // Toggle movie mode
    if (e.key === 'm' && this.explorer.grid.views.length > 1) {
      this.explorer.movieMode.toggle();
    }
    // Toggle fullscreen mode
    if (e.key === 'Enter' || document.fullscreenElement && e.key === 'Escape') {
      e.preventDefault(); // Prevent default action of the Enter key
      this.explorer.toggleFullscreen();
    }
  }

  onmouseover(e) {
    document.body.className = 'hidemarks';
    this.explorer.grid.setFocusedView(null);
    let target = this.eventtarget(e);
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (m) {
        let k = parseInt(m[1]);
        this.explorer.grid.setFocusedView(k);
        if (this.explorer.grid.views.length <= k) return;
        document.body.className = '';
        let overtarget = e.target;
        if (overtarget.tagName == 'A') {
          overtarget.showDebug = e.ctrlKey || e.metaKey;
          this.explorer.grid.updateProgress(overtarget, k);
          const statusDiv = overtarget.querySelector('.status');
          if (statusDiv) { statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
        }
      } else if (target.id.startsWith('movie') && (!e.target || e.target.id != 'movie')) {
        document.body.className = '';
      }
    }
  }

  eventtarget(e) {
    let target = (e.target ? e.target : e.srcElement ? e.srcElement : null);
    while (target) {
      if (target.id) { return target; }
      target = target.parentNode;
    }
    return null;
  }

  pointInTarget(ev, target) {
    let se = document.scrollingElement || document.body;
    let x = (ev.clientX + se.scrollLeft - this.absoluteLeft(target)) *
            this.explorer.config.pixelRatio;
    let y = (ev.clientY + se.scrollTop - this.absoluteTop(target)) *
            this.explorer.config.pixelRatio;
    return { x: Math.round(x), y: Math.round(y) };
  }

  absoluteLeft(target) {
    let left = 0;
    while (target) {
      left += target.offsetLeft;
      target = target.offsetParent;
    }
    return left;
  }

  absoluteTop(target) {
    let top = 0;
    while (target) {
      top += target.offsetTop;
      target = target.offsetParent;
    }
    return top;
  }
}

class MovieMode {
  constructor(explorer) {
    this.explorer = explorer;
    this.active = false;
    this.movieCanvas = null;
    this.movieCtx = null;
    this.animationTimer = null;
    this.preRenderTimer = null;
    this.frameCanvases = [];
    this.capturedFrames = [];  // Array to store VideoFrames for WebCodecs
    this.videoEncoder = null;
    this.muxer = null;
    this.recordedBlob = null;
    this.isRecording = false;
  }

  toggle() {
    this.active = !this.active;
    this.explorer.grid.scheduler.pauseComputation(this.active);
    if (this.active) {
      this.startMovie();
    } else {
      this.stopMovie();
    }
  }

  startMovie() {
    this.explorer.grid.grid().style.display = 'none';
    this.explorer.movieContainer.style.display = 'block';
    this.createMovieCanvas();
    this.explorer.movieContainer.scrollIntoView({ behavior: 'smooth' });
    this.preRenderTimer = setTimeout(() => {
      document.body.className = '';
      this.preRenderFrames(() => {
        this.startMovieAnimation();
      });
    }, 20);
  }

  stopMovie() {
    this.explorer.grid.grid().style.display = 'block';
    this.explorer.movieContainer.style.display = 'none';
    this.stopMovieAnimation();
    this.removeMovieCanvas();
  }

  createMovieCanvas() {
    // Recalculate dimensions in case fullscreen state has changed
    this.explorer.config.initSizes();

    this.explorer.movieContainer.innerHTML = '<div>' +
      `<canvas width=${this.explorer.config.dimsWidth} height=${this.explorer.config.dimsHeight} ` +
      `style="width:${this.explorer.config.cssDimsWidth}px;` +
      `height:${this.explorer.config.cssDimsHeight}px"></canvas>` +
      `<span id="moviestatus"></span>` +
      `<a id="moviescale" class="zoomnum">${MSG.pre_rendering_movie}</a></div>`;
    this.movieCanvas = this.explorer.movieContainer.firstElementChild.firstElementChild;
    this.movieCtx = this.movieCanvas.getContext('2d');
    this.movieCtx.drawImage(this.explorer.grid.canvas(0), 0, 0);
  }

  removeMovieCanvas() {
    while (this.explorer.movieContainer.firstChild) {
      this.explorer.movieContainer.removeChild(this.explorer.movieContainer.firstChild);
    }
    this.movieCanvas = null;
    this.movieCtx = null;
  }

  preRenderFrames(after) {
    this.frameCanvases = [];
    this.isPreRendering = true;
    let queueOneFrame = (k, after) => {
      return () => {
        // Abort if movie mode was stopped
        if (!this.isPreRendering) {
          return;
        }
        let status = document.getElementById('moviescale');
        if (status) {
          const scale = this.explorer.config.firstsize / this.explorer.grid.views[k].sizes[0];
          status.textContent = `${MSG.pre_rendering_}${formatScale(scale)}`;
        }
        let canvasPrev = null;
        let canvasCurrent = null;
        let canvasNext = null;

        // Render with k-1 palette (unknown = transparent)
        if (k > 0) {
          canvasPrev = document.createElement('canvas');
          canvasPrev.width = this.explorer.config.dimsWidth;
          canvasPrev.height = this.explorer.config.dimsHeight;
          const ctxPrev = canvasPrev.getContext('2d');
          this.explorer.grid.views[k].draw(ctxPrev, this.explorer.grid.views[k - 1], 'transparent');
          if (this.explorer.config.unknowncolor != '#000') {
            ctxPrev.strokeStyle = 'yellow';
            ctxPrev.lineWidth = this.explorer.config.pixelRatio * this.explorer.config.zoomfactor;
            ctxPrev.strokeRect(0, 0, this.explorer.config.dimsWidth, this.explorer.config.dimsHeight);
          }
        }

        // Render with k palette (unknown = black)
        canvasCurrent = document.createElement('canvas');
        canvasCurrent.width = this.explorer.config.dimsWidth;
        canvasCurrent.height = this.explorer.config.dimsHeight;
        const ctxCurrent = canvasCurrent.getContext('2d');
        this.explorer.grid.views[k].draw(ctxCurrent, this.explorer.grid.views[k], 'black');

        // Render with k+1 palette (unknown = black)
        if (k < this.explorer.grid.views.length - 1) {
          canvasNext = document.createElement('canvas');
          canvasNext.width = this.explorer.config.dimsWidth;
          canvasNext.height = this.explorer.config.dimsHeight;
          const ctxNext = canvasNext.getContext('2d');
          this.explorer.grid.views[k].draw(ctxNext, this.explorer.grid.views[k + 1], 'black');
        }
        this.frameCanvases.push({ prev: canvasPrev, current: canvasCurrent, next: canvasNext });
        this.preRenderTimer = setTimeout(after, 1);
      };
    }
    for (let k = this.explorer.grid.views.length - 1; k >= 0; k--) {
      after = queueOneFrame(k, after);
    }
    this.preRenderTimer = setTimeout(after, 0);
  }

  startMovieAnimation() {
    let frame = 0;
    let framesteps = 400;  // 60 FPS: 400 frames = 6.67 seconds (50% faster than 10 sec)
    let endpause = 120;    // Scaled for 60 FPS (was 180 for 30 FPS = 6 sec)
    let endrecord = 60;    // Keep 1 second end recording
    const totalFrames = (this.explorer.grid.views.length - 1) * framesteps;

    const scaleElement = document.getElementById('moviescale');
    const statusElement = document.getElementById('moviestatus');
    scaleElement.removeAttribute('href');
    statusElement.textContent = 'Capturing frames...';

    this.capturedFrames = [];
    this.recordedBlob = null;
    this.isRecording = true;

    const animate = () => {
      // Abort if movie mode was stopped
      if (!this.isRecording) {
        return;
      }

      const kk = Math.min(frame, totalFrames) / framesteps;
      this.drawMovieFrame(kk);

      // Capture frame for encoding (only during recording period)
      if (frame <= totalFrames + endrecord) {
        try {
          // Create VideoFrame from canvas with duration for 60 FPS
          const videoFrame = new VideoFrame(this.movieCanvas, {
            timestamp: this.capturedFrames.length * 16667,  // 60 FPS in microseconds
            duration: 16667  // Frame duration: 1/60 second = 16667 microseconds
          });
          this.capturedFrames.push(videoFrame);

          // Update status
          if (this.capturedFrames.length % 60 === 0) {
            statusElement.textContent = `Captured ${this.capturedFrames.length} frames...`;
          }
        } catch (e) {
          console.error('Error capturing frame:', e);
          statusElement.textContent = 'Error: ' + e.message;
        }
      }

      frame++;

      // Check if we're done capturing
      if (frame > totalFrames + endrecord) {
        this.isRecording = false;
        statusElement.textContent = 'Encoding video...';
        // Start encoding after a brief delay to update UI
        setTimeout(() => this.encodeVideo(statusElement), 100);
      } else if (frame <= totalFrames + endpause) {
        // Continue animation
        this.animationTimer = requestAnimationFrame(() => animate());
      }
    };
    animate();
  }

  stopMovieAnimation() {
    this.isPreRendering = false;
    this.isRecording = false;
    if (this.preRenderTimer) {
      clearTimeout(this.preRenderTimer);
      this.preRenderTimer = null;
    }
    if (this.animationTimer) {
      cancelAnimationFrame(this.animationTimer);
      this.animationTimer = null;
    }
    // Clean up prerendered frame canvases
    if (this.frameCanvases) {
      this.frameCanvases = [];
    }
    // Clean up captured frames
    if (this.capturedFrames) {
      for (let frame of this.capturedFrames) {
        frame.close();
      }
      this.capturedFrames = [];
    }
    this.recordedBlob = null;
  }

  async encodeVideo(statusElement) {
    try {
      // Check WebCodecs support
      if (!window.VideoEncoder) {
        statusElement.textContent = 'WebCodecs not supported in this browser';
        console.error('WebCodecs API not available');
        return;
      }

      if (!window.Mp4Muxer) {
        statusElement.textContent = 'mp4-muxer library not loaded';
        console.error('mp4-muxer not available');
        return;
      }

      const width = this.movieCanvas.width;
      const height = this.movieCanvas.height;

      // Calculate appropriate H.264 level based on resolution
      // H.264 uses 16x16 macroblocks, so round up to multiples of 16
      let codedWidth = Math.ceil(width / 16) * 16;
      let codedHeight = Math.ceil(height / 16) * 16;
      let codedArea = codedWidth * codedHeight;

      // H.264 level limits (format: level hex code, max coded area, level name)
      const levels = [
        ['1E', 414720, '3.0'],      // 720x576
        ['1F', 921600, '3.1'],      // 1280x720
        ['2A', 2073600, '4.2'],     // 1920x1080
        ['34', 8912896, '5.2'],     // 4096x2304 (4K)
        ['3E', 35651584, '6.2']     // 7680x4320 (8K)
      ];

      const maxArea = levels[levels.length - 1][1]; // 8K limit
      let encodingWidth = width;
      let encodingHeight = height;
      let downscaled = false;

      // If exceeds maximum, downscale to fit
      if (codedArea > maxArea) {
        const scaleFactor = Math.sqrt(maxArea * 0.95 / codedArea); // 0.95 for safety margin
        encodingWidth = Math.floor(width * scaleFactor);
        encodingHeight = Math.floor(height * scaleFactor);
        codedWidth = Math.ceil(encodingWidth / 16) * 16;
        codedHeight = Math.ceil(encodingHeight / 16) * 16;
        codedArea = codedWidth * codedHeight;
        downscaled = true;
        const msg = `Resolution ${width}x${height} exceeds H.264 limit, downscaling to ${encodingWidth}x${encodingHeight}`;
        console.warn(msg);
        statusElement.textContent = msg;
      }

      // Select minimum level that supports this resolution
      let levelCode = '3E'; // Default to 6.2 (highest)
      let levelName = '6.2';
      for (const [code, levelMaxArea, name] of levels) {
        if (codedArea <= levelMaxArea) {
          levelCode = code;
          levelName = name;
          break;
        }
      }

      const codecString = `avc1.42E0${levelCode}`;
      console.log(`Video resolution: ${encodingWidth}x${encodingHeight}, coded: ${codedWidth}x${codedHeight} (${codedArea} pixels), using H.264 level ${levelName}`);

      // Initialize MP4 muxer
      this.muxer = new window.Mp4Muxer.Muxer({
        target: new window.Mp4Muxer.ArrayBufferTarget(),
        video: {
          codec: 'avc',
          width: encodingWidth,
          height: encodingHeight
        },
        fastStart: 'in-memory'
      });

      let encodedCount = 0;
      const totalFrames = this.capturedFrames.length;

      // Initialize video encoder
      this.videoEncoder = new VideoEncoder({
        output: (chunk, metadata) => {
          // Ensure metadata has decoderConfig with colorSpace for Safari compatibility
          if (metadata?.decoderConfig && !metadata.decoderConfig.colorSpace) {
            metadata.decoderConfig.colorSpace = {
              primaries: 'bt709',
              transfer: 'bt709',
              matrix: 'bt709',
              fullRange: false
            };
          }
          this.muxer.addVideoChunk(chunk, metadata);
          encodedCount++;
          if (encodedCount % 60 === 0) {
            statusElement.textContent = `Encoding: ${Math.round(100 * encodedCount / totalFrames)}%`;
          }
        },
        error: (e) => {
          console.error('Encoding error:', e);
          statusElement.textContent = 'Encoding error: ' + e.message;
        }
      });

      // Configure encoder for H.264 with dynamically calculated level
      this.videoEncoder.configure({
        codec: codecString,  // H.264 baseline profile with appropriate level
        width: encodingWidth,
        height: encodingHeight,
        bitrate: 30_000_000,  // 30 Mbps for high quality
        framerate: 60,
        // Provide colorSpace to ensure Safari includes it in metadata
        colorSpace: {
          primaries: 'bt709',
          transfer: 'bt709',
          matrix: 'bt709',
          fullRange: false
        }
      });

      // Create a temporary canvas for downscaling if needed
      let tempCanvas, tempCtx;
      if (downscaled) {
        tempCanvas = document.createElement('canvas');
        tempCanvas.width = encodingWidth;
        tempCanvas.height = encodingHeight;
        tempCtx = tempCanvas.getContext('2d');
      }

      // Encode all frames
      for (let i = 0; i < this.capturedFrames.length; i++) {
        const frame = this.capturedFrames[i];
        const keyFrame = i % 200 === 0;  // Keyframe every 3.33 seconds (200 frames at 60 FPS)

        if (downscaled) {
          // Scale frame to tempCanvas, then create new VideoFrame
          tempCtx.drawImage(frame, 0, 0, encodingWidth, encodingHeight);
          const scaledFrame = new VideoFrame(tempCanvas, {
            timestamp: frame.timestamp,
            duration: frame.duration
          });
          this.videoEncoder.encode(scaledFrame, { keyFrame });
          scaledFrame.close();
        } else {
          this.videoEncoder.encode(frame, { keyFrame });
        }

        frame.close();  // Release VideoFrame resources
      }

      // Wait for encoding to complete
      await this.videoEncoder.flush();
      this.videoEncoder.close();

      // Finalize muxer and get the video file
      this.muxer.finalize();
      const buffer = this.muxer.target.buffer;
      this.recordedBlob = new Blob([buffer], { type: 'video/mp4' });

      // Clean up
      this.capturedFrames = [];
      this.videoEncoder = null;
      this.muxer = null;

      // Update download link
      statusElement.textContent = '';  // Clear status
      this.updateDownloadLink();

      // Start looping animation
      this.startLoopAnimation();

    } catch (e) {
      console.error('Error encoding video:', e);
      statusElement.textContent = 'Encoding failed: ' + e.message;
    }
  }

  startLoopAnimation() {
    const framesteps = 400;  // Same as recording
    const totalFrames = (this.explorer.grid.views.length - 1) * framesteps;
    const pauseFrames = 120;  // 2 second pause at 60 FPS
    let frame = 0;

    const animate = () => {
      // During main animation
      if (frame <= totalFrames) {
        const kk = Math.min(frame, totalFrames) / framesteps;
        this.drawMovieFrame(kk);
      }
      // During pause at end - keep showing last frame

      frame++;

      // Loop back to start after pause
      if (frame > totalFrames + pauseFrames) {
        frame = 0;
      }

      // Continue animation indefinitely
      this.animationTimer = requestAnimationFrame(() => animate());
    };

    animate();
  }

  updateDownloadLink() {
    const scaleElement = document.getElementById('moviescale');
    scaleElement.textContent = 'Download mp4';
    scaleElement.href = URL.createObjectURL(this.recordedBlob);
    const k = this.explorer.grid.views.length - 1;
    const view = this.explorer.grid.views[k];
    scaleElement.download = 'mandelbrot' +
              formatcomplex(k, view.sizes[1], view.sizes[2]) +
              '-' + view.it + '.mp4';
  }

  drawMovieFrame(kk) {
    if (this.movieCtx == null) { return; }
    const k = Math.floor(kk);
    const t = kk - k;
    const sourceView = this.explorer.grid.views[k];
    const targetView = k+1 < this.explorer.grid.views.length ?
                        this.explorer.grid.views[k+1] : sourceView;
    const sourceSize = sourceView.sizes[0];
    const targetSize = targetView.sizes[0];
    const zoomRatio = targetSize / sourceSize;

    // Use zoom ratio for exponential interpolation
    const mulT = Math.pow(zoomRatio, t);
    const expT = (zoomRatio == 1.0 ? t : (mulT - 1) / (zoomRatio - 1));
    const colorT = expT * expT;
    const interpolatedSize = sourceSize * mulT;

    // Use spline interpolation for center coordinates
    const sourceCenter = [sourceView.sizes[1], sourceView.sizes[2]];
    const targetCenter = [targetView.sizes[1], targetView.sizes[2]];

    const p0 = k > 0 ? [
        this.explorer.grid.views[k-1].sizes[1],
        this.explorer.grid.views[k-1].sizes[2]] : sourceCenter;
    const p1 = sourceCenter;
    const p2 = targetCenter
    const p3 = k+2 < this.explorer.grid.views.length ? [
        this.explorer.grid.views[k+2].sizes[1],
        this.explorer.grid.views[k+2].sizes[2]] : targetCenter;
    const interpolatedCenter = catmullRomSpline(p0, p1, p2, p3, t);

    // Clear the movie canvas with black (so unfinished pixels appear black)
    this.movieCtx.fillStyle = 'black';
    this.movieCtx.fillRect(0, 0, this.explorer.config.dimsWidth, this.explorer.config.dimsHeight);

    // Draw the current frame
    const scale = sourceSize / interpolatedSize;
    const offsetX = qdMul(qdSub(interpolatedCenter[0], sourceCenter[0]),
                          [this.explorer.config.dimsWidth / sourceSize, 0])[0];
    const offsetY = qdMul(qdSub(sourceCenter[1], interpolatedCenter[1]),
                          [this.explorer.config.dimsHeight / (sourceSize / this.explorer.config.aspectRatio), 0])[0];
    this.movieCtx.save();
    this.movieCtx.imageSmoothingEnabled = true;
    this.movieCtx.imageSmoothingQuality = 'high';
    this.movieCtx.translate(this.explorer.config.dimsWidth / 2, this.explorer.config.dimsHeight / 2);
    this.movieCtx.scale(scale, scale);
    this.movieCtx.translate(-this.explorer.config.dimsWidth / 2 - offsetX,
                            -this.explorer.config.dimsHeight / 2 - offsetY);
    this.movieCtx.globalAlpha = 1;
    // Use pre-rendered current canvas with black unknown pixels
    this.movieCtx.drawImage(this.frameCanvases[k].current, 0, 0);

    // Blend the color palette of the next frame (unknown = black)
    if (this.frameCanvases[k].next) {
      this.movieCtx.globalAlpha = colorT;
      this.movieCtx.drawImage(this.frameCanvases[k].next, 0, 0);
    }
    this.movieCtx.restore();

    // Draw the next frame
    if (k < this.explorer.grid.views.length - 1) {
      const targetScale = targetSize / interpolatedSize;
      const targetOffsetX = qdMul(qdSub(interpolatedCenter[0], targetCenter[0]),
                                  [this.explorer.config.dimsWidth / targetSize, 0])[0];
      const targetOffsetY = qdMul(qdSub(targetCenter[1], interpolatedCenter[1]),
                                  [this.explorer.config.dimsHeight / (targetSize / this.explorer.config.aspectRatio), 0])[0];
      this.movieCtx.save();
      this.movieCtx.imageSmoothingEnabled = true;
      this.movieCtx.imageSmoothingQuality = 'high';
      this.movieCtx.translate(this.explorer.config.dimsWidth / 2, this.explorer.config.dimsHeight / 2);
      this.movieCtx.scale(targetScale, targetScale);
      this.movieCtx.translate(-this.explorer.config.dimsWidth / 2 - targetOffsetX,
                              -this.explorer.config.dimsHeight / 2 - targetOffsetY);
      this.movieCtx.globalAlpha = 1;
      // Draw prev palette version (unknown = transparent, shows lower res through)
      this.movieCtx.drawImage(this.frameCanvases[k + 1].prev, 0, 0);
      this.movieCtx.globalAlpha = colorT;
      // Draw current palette version (unknown = black)
      this.movieCtx.drawImage(this.frameCanvases[k + 1].current, 0, 0);
      this.movieCtx.restore();
    }

    // Update scale text
    if (!this.recordedBlob) {
      const currentScale = Math.pow(this.explorer.config.zoomfactor, kk);
      document.getElementById('moviescale').textContent = formatScale(currentScale);
    }
  }
}

class Scheduler {
  constructor(grid) {
    this.grid = grid;
    this.workers = [];
    this.boardEfforts = new Map();
    this.assignments = {};
    this.gpuBoards = new Set(); // Track GPU boards that cannot be transferred
    this.lastBalanceTime = 0;
    this.lastReportTime = 0;
    this.balanceInterval = 5000; // Move jobs to load-balance every 5 seconds
    this.reportInterval = 60000; // Report no more than once every 1 minute
    this.workerCount = Math.max(1, Math.ceil(navigator.hardwareConcurrency * 0.75) || 1);
    this.webGPUWarningShown = false;
  }

  addWorker() {
    // Show WebGPU warning once when first worker is created
    if (this.workers.length === 0 && this.grid.config.enableGPU &&
        typeof navigator.gpu === 'undefined' && !this.webGPUWarningShown) {
      console.log('WebGPU not available in this browser, falling back to CPU boards');
      this.webGPUWarningShown = true;
    }

    try {
      const workerCode = this.assembleWorkerCode();
      const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
      const workerUrl = URL.createObjectURL(workerBlob);
      const workerNum = this.workers.length;
      const worker = new Worker(workerUrl, { name: `Worker ${workerNum}` });
      URL.revokeObjectURL(workerUrl);
      worker.onmessage = this.handleWorkerMessage.bind(this);
      this.workers.push(worker);
      window[`worker${workerNum}`] = worker;

      // Initialize new worker with current hidden boards state
      worker.postMessage({
        type: 'setHiddenBoards',
        data: { hiddenBoards: this.grid.getHiddenViews() }
      });

      return true;
    } catch (e) {
      console.log('Failed to start webworker', e);
      return false;
    }
  }

  assembleWorkerCode() {
    const workerCode = document.getElementById('workerCode');
    const quadCode = document.getElementById('quadCode');
    return '// Linefeeds to align line numbers with HTML.\n' +
           ''.padStart(lastScriptLineNumber, '\n') +
           '// <script id="workerCode">' +
           workerCode.textContent +
           '// <\/script>\n' +
           '// <script id="quadCode">' +
           quadCode.textContent +
           '// <\/script>\n';
  }

  assignBoardToWorker(k, size, re, im, config, id) {
    let [workerNumber, minLoad] = this.findLeastLoadedWorker();
    if (workerNumber == -1 || (minLoad > 0 && this.workers.length < this.workerCount)) {
      if (this.addWorker()) {
        workerNumber = this.workers.length - 1;
      }
    }
    const worker = this.workers[workerNumber];
    const estimatedWork = config.dims2 * ((size / config.dims < 1e-15) ? 7 : 1);
    this.boardEfforts.set(k, estimatedWork);
    this.assignments[k] = workerNumber;

    worker.postMessage({
      type: 'addBoard',
      data: {
        k,
        size,
        re,
        im,
        config: {
          dims: config.dims,
          dims2: config.dims2,
          dimsWidth: config.dimsWidth,
          dimsHeight: config.dimsHeight,
          aspectRatio: config.aspectRatio,
          exponent: config.exponent,
          enableGPU: config.enableGPU,
          forceBoard: config.forceBoard
        },
        id,
        workerNumber
      }
    });
  }

  removeBoardFromWorker(k) {
    this.boardEfforts.set(k, 0);
    this.gpuBoards.delete(k);
    this.workers.forEach(worker => {
      worker.postMessage({
        type: 'removeBoard',
        data: { k }
      });
    });
  }

  setFocusedBoard(k) {
    this.workers.forEach(worker => {
      worker.postMessage({
        type: 'setFocusedBoard',
        data: { k }
      });
    });
  }

  setHiddenBoards(hiddenBoards) {
    this.workers.forEach(worker => {
      worker.postMessage({
        type: 'setHiddenBoards',
        data: { hiddenBoards }
      });
    });
  }

  pauseComputation(pause) {
    this.workers.forEach(worker => worker.postMessage({ type: 'pause', data: { pause } }));
  }

  handleWorkerMessage(e) {
    const { type, data } = e.data;
    const workerIndex = this.workers.indexOf(e.target);

    switch (type) {
      case 'log':
        console.log(`Worker ${workerIndex}: ${data}`);
        break;
      case 'boardCreated':
        if (data.isGPUBoard) {
          this.gpuBoards.add(data.k);
        }
        break;
      case 'iterations':
        this.grid.updateViewFromWorkerResult(data.k, data, workerIndex);
        // fallthrough
      case 'update':
        if ('boardEffort' in data) { this.boardEfforts.set(data.k, data.boardEffort); }
        this.checkAndBalance(); // Check if we need to balance the load
        explorer.checkAllViewsComplete();
        break;
      case 'downloadTransfer':
        this.handleDownloadTransfer(data, workerIndex);
        break;
    }
  }

  checkAndBalance() {
    // Only apply load balancing periodically.
    const now = Date.now();
    if (now - this.lastBalanceTime < this.balanceInterval) { return; }
    this.lastBalanceTime = now;

    const workerLoads = this.workers.map((_, index) => this.getWorkerLoad(index));
    const lowEffort = Math.min(...workerLoads);
    const highEffort = Math.max(...Array.from(this.boardEfforts.values()));

    if (lowEffort * 2 < highEffort) {
      const transferCandidates = [];
      const sortedLoad = workerLoads.map((load, index) => [index, load]).sort((a, b) => b[1] - a[1]);
      for (let [workerIndex, load] of sortedLoad) {
        if (load > 2 * lowEffort) {
          const workerBoards = this.getWorkerBoards(workerIndex);
          if (workerBoards.length > 1) {
            // Filter out GPU boards which cannot be transferred
            const transferableBoards = workerBoards.filter(k => !this.gpuBoards.has(k));
            if (transferableBoards.length < 2) {
              continue; // Skip this worker - need at least 2 transferable boards
            }
            const sortedBoards = transferableBoards.sort(
                (a, b) => this.boardEfforts.get(b) + b/1000 - this.boardEfforts.get(a) - a/1000);
            if (now - this.lastReportTime > this.reportInterval) {
              console.log(this.report());
              this.lastReportTime = now;
            }
            /*
            console.log(`requesting transfer of board ${sortedBoards[1]} ` +
                        `(effort ${this.boardEfforts.get(sortedBoards[1])}) ` +
                        `from worker ${workerIndex} (load ${load}) ` +
                        `sharing board ${sortedBoards[0]} ` +
                        `(effort ${this.boardEfforts.get(sortedBoards[0])}), ` +
                        `low=${lowEffort}, high=${highEffort}`);
            */
            transferCandidates.push(sortedBoards[1]);
            break;
          }
        }
      }
      if (transferCandidates.length > 0) {
        this.requestTransfers(transferCandidates);
      }
    }
  }

  report() {
    if (!this.workers.length) { return 'no workers'; }
    const workerLoads = this.workers.map(() => 0);
    const workerBoards = this.workers.map(() => []);
    for (const [boardK, workerIndex] of Object.entries(this.assignments)) {
      const effort = this.boardEfforts.get(parseInt(boardK));
      if (effort) {
        workerBoards[workerIndex].push([parseInt(boardK), effort]);
        workerLoads[workerIndex] += effort;
      }
    }
    let result = '';
    for (let i = 0; i < workerLoads.length; i++) {
      result += `worker ${i} (load ${workerLoads[i]}): `;
      workerBoards[i].sort((a, b) => b[1] + b[0]/1000 - a[1] - a[0]/1000);
      for (let j = 0; j < workerBoards[i].length; j++) {
        result += `${workerBoards[i][j][0]}->${workerBoards[i][j][1]} `;
      }
      result += '\n';
    }
    return result;
  }

  findLeastLoadedWorker() {
    if (!this.workers.length) { return [-1, 0]; }
    const workerLoads = new Array(this.workers.length).fill(0);
    for (const [boardK, workerIndex] of Object.entries(this.assignments)) {
      workerLoads[workerIndex] += this.boardEfforts.get(parseInt(boardK)) || 0;
    }
    const minLoad = Math.min(...workerLoads);
    return [workerLoads.indexOf(minLoad), minLoad];
  }

  getWorkerLoad(workerIndex) {
    return Object.entries(this.assignments)
      .filter(([_, assignedWorker]) => assignedWorker === workerIndex)
      .reduce((sum, [k, _]) => sum + (this.boardEfforts.get(parseInt(k)) || 0), 0);
  }

  getWorkerBoards(workerIndex) {
    return Object.entries(this.assignments)
      .filter(([k, assignedWorker]) =>
           this.boardEfforts.get(parseInt(k)) > 0 && assignedWorker === workerIndex)
      .map(([k, _]) => parseInt(k));
  }

  requestTransfers(boardKeys) {
    // Group transfer requests by worker
    for (const [workerIndex, worker] of this.workers.entries()) {
      const workerBoards = boardKeys.filter(k => this.assignments[k] === workerIndex);
      if (workerBoards.length > 0) {
        worker.postMessage({
          type: 'requestTransfer',
          data: { boardKeys: workerBoards }
        });
      }
    }
  }

  handleDownloadTransfer(data, sourceWorkerIndex) {
    const { transferredBoards } = data;
    for (const boardData of transferredBoards) {
      // Remove the board from its original worker
      delete this.assignments[boardData.k];

      // Find the least loaded worker and assign the board to it
      const [targetWorkerIndex, minLoad] = this.findLeastLoadedWorker();
      this.uploadTransferredBoard(boardData, targetWorkerIndex);
      console.log(`transferred ${boardData.type} ${boardData.k} ` +
                  `from worker ${sourceWorkerIndex} ` +
                  `to ${targetWorkerIndex} (load ${minLoad})`);
    }
  }

  uploadTransferredBoard(boardData, targetWorkerIndex) {
    // Send the board to its new worker
    this.workers[targetWorkerIndex].postMessage({
      type: 'uploadTransfer',
      data: { boardData }
    });

    // Update assignments and worker loads
    this.assignments[boardData.k] = targetWorkerIndex;
  }
}

class OrbitComputer {
  constructor(explorer) {
    this.explorer = explorer;
    this.orbitinterval = null;
    this.orbittimeout = null;
  }

  updateOrbit(k, j, target) {
    this.stopOrbitProcess();
    const orb = [];

    const updateorbit = () => {
      const [neworb, cyc, ongoing, title] = this.calculateOrbit(k, j, orb);
      this.displayOrbit(k, neworb, cyc, target, title, orb.length > 0);
      orb.push(...neworb);
      if (!ongoing) { this.stopOrbitInterval(); }
      return ongoing;
    };

    if (updateorbit()) {
      this.orbitinterval = setInterval(updateorbit, 53);
    }
  }

  stopOrbitInterval() {
    if (this.orbitinterval) {
      clearInterval(this.orbitinterval);
      this.orbitinterval = null;
    }
  }

  stopOrbitProcess() {
    this.stopOrbitInterval();
    if (this.orbittimeout) {
      clearTimeout(this.orbittimeout);
      this.orbittimeout = null;
    }
  }

  calculateOrbit(k, j, oldOrb) {
    let cyc = [];
    let orb = [];
    let ongoing = false;
    let title = '';
    let view = this.explorer.grid.views[k];

    if (view && j >= 0 && j < this.explorer.config.dims2) {
      let c = view.currentc(j);
      let z = view.currentz(j);

      // Calculate a further orbit beyond the old orbit.
      let finished = Math.max(view.currentp(j) || 0, Math.abs(view.nn[j] || 0));
      let whole = Math.min(finished || Math.max(view.it, 8));
      let more = Math.min(whole - oldOrb.length / 4, 53);
      if (oldOrb.length) {
        let s = oldOrb.slice(oldOrb.length - 4);
        orb = this.suborbit(s, c, more + 1);
        orb.splice(0, 4);
      } else {
        orb = this.suborbit(c, c, more);
      }
      if (!finished || (orb.length + oldOrb.length) / 4 < finished) {
        ongoing = true;
      }
      // Calculate a cycle and any messages
      title = 'c=' + formatcomplex(k, [c[0], c[1]], [c[2], c[3]]).replaceAll('-', '\u2212');
      if (view.nn[j]) {
        if (view.nn[j] > 0) {
          title += MSG.diverges_in_ + view.nn[j];
        } else {
          let period = fibonacciPeriod(view.currentp(j));
          if (period == 1) {
            title += MSG.converges_after_ + formatLargeInt(view.currentp(j));
          } else {
            title += MSG.after_ + formatLargeInt(view.currentp(j)) + MSG.period_ + formatLargeInt(period);
          }
          let clen = fibonacciPeriod(view.currentp(j));
          cyc = z ? this.suborbit(z, c, clen) : [];
        }
      } else {
        ongoing = true;
      }
    }
    return [orb, cyc, ongoing, title];
  }

  displayOrbit(k, orb, cyc, target, title, preserve) {
    // Don't set title if the zoom number's custom tooltip is showing
    const zoomnum = target.querySelector('.zoomnum');
    const isZoomnumHovered = zoomnum && zoomnum.matches(':hover');
    if (!isZoomnumHovered) {
      target.setAttribute('title', title);
    }
    if (!preserve) {
      this.explorer.grid.clearseq(k);
    }
    this.showseq(k, orb, 'yellow');
    this.showseq(k, cyc, 'red');

    const orbitonallboards = () => {
      for (let i = 0; i < this.explorer.grid.views.length; i++) {
        if (!this.explorer.grid.hiddencanvas(i) && i != k) {
          if (!preserve) {
            this.explorer.grid.clearseq(i);
          }
          this.showseq(i, orb, 'yellow');
          this.showseq(i, cyc, 'red');
        }
      }
    };
    this.orbittimeout = setTimeout(orbitonallboards, 1);
  }

  suborbit(z, c, len) {
    let r = [z[0], z[1]];
    let j = [z[2], z[3]];
    const cr = [c[0], c[1]];
    const cj = [c[2], c[3]];

    let result = [r[0], r[1], j[0], j[1]];
    while (result.length < len * 4) {
      let j2 = qdSquare(j);
      let ja = qdMul(qdDouble(r), j);
      let r2 = qdSquare(r);
      let ra = qdSub(r2, j2);
      for (let ord = 2; ord < this.explorer.config.exponent; ord++) {
        let rt = qdSub(qdMul(r, ra), qdMul(j, ja));
        ja = qdAdd(qdMul(r, ja), qdMul(j, ra));
        ra = rt;
      }
      r = qdAdd(ra, cr);
      j = qdAdd(ja, cj);
      result.push(r[0], r[1], j[0], j[1]);
    }
    return result;
  }

  showseq(k, seq, color) {
    if (k >= this.explorer.grid.views.length) { return; }
    const overlay = this.explorer.grid.overlay(k);
    if (!overlay) { return; }
    let ctx = overlay.getContext('2d');
    ctx.fillStyle = color;
    let [s, cr, cj] = this.explorer.grid.views[k].sizes;
    for (let i = 0; i < seq.length; i += 4) {
      let r = [seq[i], seq[i+1]];
      let j = [seq[i+2], seq[i+3]];
      let x = (qdSub(r, cr)[0] / s + 0.5) * this.explorer.config.dimsWidth;
      let y = (qdSub(cj, j)[0] / (s / this.explorer.config.aspectRatio) + 0.5) * this.explorer.config.dimsHeight;
      if (x >= 0 && y >= 0 && x < this.explorer.config.dimsWidth && y < this.explorer.config.dimsHeight) {
        ctx.beginPath();
        ctx.arc(x, y, 1 * this.explorer.config.pixelRatio, 0, 2 * Math.PI, false);
        ctx.fill();
      }
    }
  }
}

class RedrawProcess {
  constructor(explorer) {
    this.views = explorer.grid.views;
    this.canvasGetter = (index) => explorer.grid.canvas(index);
    this.orderFactory = () => explorer.grid.views.map((b, i) => i).sort(
       (a, b) => (explorer.grid.hiddencanvas(a) * 1 - explorer.grid.hiddencanvas(b) * 1)
                 * explorer.grid.views.length + (b - a));
    this.timer = null;
  }
  start() {
    this.stop();  // Ensure any existing cycle is stopped
    this.canvasOrder = this.orderFactory();
    this.drawNext();
  }
  stop() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
  drawNext() {
    if (this.canvasOrder.length) {
      const index = this.canvasOrder.shift();
      const view = this.views[index];
      const canvas = this.canvasGetter(index);
      if (canvas && view) {
        const ctx = canvas.getContext('2d');
        view.draw(ctx);
      }
      this.currentIndex++;
      this.timer = setTimeout(() => this.drawNext(), 0);
    } else {
      this.stop();
    }
  }
}

class MandelbrotExplorer {
  constructor() {
    this.config = new Config();
    this.grid = new Grid(this.config);
    this.zoomManager = new ZoomManager(this.config, this.grid);
    this.urlHandler = new URLHandler(this.config, this.grid);
    this.eventHandler = new EventHandler(this);
    this.movieMode = new MovieMode(this);
    this.orbitComputer = new OrbitComputer(this);
    this.redrawProcess = new RedrawProcess(this);
    this.movieContainer = document.getElementById('movie');
    this.allViewsCompleted = false;

    // Listen for fullscreen changes
    document.addEventListener('fullscreenchange', () => this.onFullscreenChange());

    // Clear native tooltip when hovering over zoom numbers to show custom tooltip
    document.addEventListener('mouseover', (e) => {
      if (e.target.classList.contains('zoomnum') || e.target.closest('.zoomnum')) {
        const zoomnum = e.target.classList.contains('zoomnum') ? e.target : e.target.closest('.zoomnum');
        const gridDiv = zoomnum.closest('#grid > div');
        if (gridDiv) {
          gridDiv.setAttribute('title', '');
        }
      }
    });
  }

  start() {
    this.startTime = Date.now();
    console.log(new Date);
    let startState = this.urlHandler.parseUrl();
    this.config.initSizes();

    // Fill in default sizes if none were specified in URL
    if (startState.sizes.length === 0) {
      startState.sizes = this.config.firststate().sizes;
    }

    // Convert zoom factor from URL to absolute size
    if (this.config.zoomFromUrl !== undefined) {
      const actualSize = this.config.firstsize / this.config.zoomFromUrl;
      delete this.config.zoomFromUrl;
      // Fill in sizes with the zoom-adjusted value
      for (let i = 0; i < startState.sizes.length; i++) {
        if (startState.sizes[i][0] === null) {
          startState.sizes[i][0] = actualSize / Math.pow(this.config.zoomfactor, i);
        }
      }
    } else {
      // Fill in sizes with default firstsize
      for (let i = 0; i < startState.sizes.length; i++) {
        if (startState.sizes[i][0] === null) {
          startState.sizes[i][0] = this.config.firstsize / Math.pow(this.config.zoomfactor, i);
        }
      }
    }

    this.initPlatform();
    this.grid.updateLayout(startState);
    this.eventHandler.setup();
    this.grid.updateHiddenViews(); // Initial update of hidden boards
  }

  checkAllViewsComplete() {
    if (this.allViewsCompleted) return;

    // Check if all views are done
    const allDone = this.grid.views.every(view => view && view.un === 0);

    if (allDone && this.grid.views.length > 0) {
      this.allViewsCompleted = true;
      const elapsed = Date.now() - this.startTime;
      console.log(`All views completed in ${(elapsed / 1000).toFixed(2)}s`);
    }
  }

  cycleUnknownColor(backward) {
    const inc = backward ? this.config.ukcs.length - 1 : 1;
    const ind = (this.config.ukcs.indexOf(this.config.unknowncolor) + inc) % this.config.ukcs.length;
    this.config.unknowncolor = this.config.ukcs[ind];
    // Update div backgrounds instead of redrawing canvases
    for (let k = 0; k < this.grid.views.length; ++k) {
      const canvas = this.grid.canvas(k);
      if (canvas && canvas.parentElement) {
        canvas.parentElement.style.backgroundColor = this.config.unknowncolor;
      }
    }
    this.urlHandler.updateurl();
  }

  cycleColorTheme(backward) {
    const inc = backward ? this.config.colorThemes.all.length - 1 : 1;
    const themes = this.config.colorThemes.all;
    const currentIndex = themes.indexOf(this.config.theme);
    const nextIndex = (currentIndex + inc) % themes.length;
    this.config.theme = themes[nextIndex];
    this.redrawProcess.start();
    this.urlHandler.updateurl();
  }

  toggleFullscreen() {
    if (!document.fullscreenElement) {
      // Save pre-fullscreen settings
      this.preFullscreenGridcols = this.config.gridcols;
      this.preFullscreenAspectRatio = this.config.aspectRatio;

      document.documentElement.requestFullscreen().catch(err => {
        console.log(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  }

  onFullscreenChange() {
    // Exit movie mode if active
    if (this.movieMode.active) {
      this.movieMode.toggle();
    }

    if (document.fullscreenElement) {
      // Entering fullscreen
      // Only process if grid has views
      if (!this.grid.views || this.grid.views.length === 0) {
        return;
      }

      // Delay to allow browser to fully transition to fullscreen
      setTimeout(() => {
        // Calculate fullscreen aspect ratio from actual window dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const viewportAspectRatio = viewportWidth / viewportHeight;

        const oldFirstsize = this.config.firstsize;

        // Set grid to 1 column and aspect ratio to match viewport
        this.config.gridcols = 1;
        this.config.aspectRatio = viewportAspectRatio;

        // Get current state before recalculating sizes
        const state = this.grid.currentGridState();

        // Call initSizes to recalculate dimensions for fullscreen
        this.config.initSizes();
        const newFirstsize = this.config.firstsize;

        // Scale all existing view sizes proportionally
        const scaleFactor = newFirstsize / oldFirstsize;
        for (let i = 0; i < state.sizes.length; i++) {
          state.sizes[i][0] *= scaleFactor;
        }

        // Skip initSizes in updateLayout since we already called it
        this.grid.updateLayout(state, true);

        // Only update URL if we have views
        if (this.grid.views && this.grid.views.length > 0) {
          this.urlHandler.updateurl();
        }

        // Scroll to top immediately
        window.scrollTo(0, 0);
      }, 100);  // 100ms delay to allow fullscreen transition
    } else {
      // Exiting fullscreen - restore pre-fullscreen settings
      if (this.preFullscreenGridcols !== undefined && this.grid.views && this.grid.views.length > 0) {
        const oldFirstsize = this.config.firstsize;

        this.config.gridcols = this.preFullscreenGridcols;
        this.config.aspectRatio = this.preFullscreenAspectRatio;

        // Get current state before recalculating sizes
        const state = this.grid.currentGridState();

        // Call initSizes to recalculate dimensions
        this.config.initSizes();
        const newFirstsize = this.config.firstsize;

        // Scale all existing view sizes proportionally
        const scaleFactor = newFirstsize / oldFirstsize;
        for (let i = 0; i < state.sizes.length; i++) {
          state.sizes[i][0] *= scaleFactor;
        }

        // Skip initSizes in updateLayout since we already called it
        this.grid.updateLayout(state, true);
        this.urlHandler.updateurl();
      }
    }
  }

  initPlatform() {
    if (this.config.mac) {
      for (let el of document.querySelectorAll('[mac]')) {
        el.innerHTML = el.getAttribute('mac');
      }
    }
    if (this.config.mobile) {
      for (let el of document.querySelectorAll('[mobile]')) {
        el.innerHTML = el.getAttribute('mobile');
      }
    }
    for (let el of document.querySelectorAll('.moviemode')) {
      el.href = '#movie';
      el.onclick = (() => {
        if (this.grid.views.length > 1) {
          this.movieMode.toggle();
        }
        return true;
      });
    }
    // Set up fullscreen button
    const fullscreenButton = document.getElementById('fullscreen-button');
    if (fullscreenButton) {
      fullscreenButton.onclick = () => {
        this.toggleFullscreen();
      };
    }
  }
}

// Utility functions
function formatScale(scale) {
  if (scale < 10) {
    return +scale.toFixed(1) + 'x';
  } else if (scale < 100000) {
    return +scale.toFixed(0) + 'x';
  } else {
    return scale.toExponential(2);
  }
}

function formatSize(s) {
  return parseFloat(s.toPrecision(
              Math.max(2, -Math.ceil(Math.log(s)/2.5))));
}

function toSimpleFraction(decimal, maxDenominator = 100) {
  // Use continued fractions to find the best rational approximation
  // Returns [numerator, denominator]
  let bestNum = 1, bestDen = 1;
  let bestError = Math.abs(decimal - 1);

  // Continued fractions algorithm
  let h1 = 1, h2 = 0;
  let k1 = 0, k2 = 1;
  let x = decimal;

  for (let i = 0; i < 20; i++) {  // Limit iterations
    const a = Math.floor(x);
    const h = a * h1 + h2;
    const k = a * k1 + k2;

    if (k > maxDenominator) break;

    const error = Math.abs(decimal - h/k);
    if (error < bestError) {
      bestNum = h;
      bestDen = k;
      bestError = error;
    }

    if (error < 1e-10) break;  // Close enough

    x = 1 / (x - a);
    h2 = h1; h1 = h;
    k2 = k1; k1 = k;
  }

  return [bestNum, bestDen];
}

function formatcomplex(k, re, im) {
  let pix = explorer.grid.views[k].sizes[0] / explorer.config.dimsWidth;
  let digits = Math.max(0, -Math.floor(Math.log10(pix)));
  re = toQd(re);
  im = toQd(im);
  let rd = qdFixed(qdAbs(re), digits)
  let id = qdFixed(qdAbs(im), digits)
  let rs = re[0] < 0.0 ? '-' : '+';
  let is = im[0] < 0.0 ? '-' : '+';
  return rs + rd + is + id + 'i';
}

function formatLargeInt(i) {
  // Put a comma or period between thousands.
  return Intl.NumberFormat().format(i);
}

function catmullRom1D(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const c0 = (-t3 + 2*t2 - t) / 2;
  // c1 = (3*t3 - 5*t2 + 2) / 2; // unneeded since p1 = 0
  const c2 = (-3*t3 + 4*t2 + t) / 2;
  const c3 = (t3 - t2) / 2;
  // Compute offsets from p1 for numerical stability.
  const s0 = qdSub(p0, p1);
  const s2 = qdSub(p2, p1);
  const s3 = qdSub(p3, p1);
  return qdAdd(qdAdd(qdAdd(qdScale(s0, c0),
           qdScale(s3, c3)), qdScale(s2, c2)), p1);
}

function catmullRomSpline(p0, p1, p2, p3, t) {
  return [
    catmullRom1D(p0[0], p1[0], p2[0], p3[0], t),
    catmullRom1D(p0[1], p1[1], p2[1], p3[1], t)
  ];
}

function hclColor(h, c, l) {
  // Normalize hue to be between 0 and 360 degrees
  // Chroma and Luminance should be between 0 and 100.
  h = h % 360;
  if (h < 0) h += 360;
  c = Math.min(Math.max(c, 0), 100);
  l = Math.min(Math.max(l, 0), 100);

  // Convert to radians
  const hRad = h * Math.PI / 180;

  // Constants for conversion
  const u = Math.cos(hRad) * c;
  const v = Math.sin(hRad) * c;

  // Direct conversion from HCL to RGB
  let r = l + 0.09551990792716 * u + 0.05406649830715 * v;
  let g = l - 0.03947567534454 * u - 0.01829165033556 * v;
  let b = l - 0.19638676772419 * u - 0.45388640918783 * v;

  // Apply gamma correction and convert to eight-bit value
  [r, g, b] = [r, g, b].map((x) => {
    return intcolor(gammaCorrect(x / 100));
  });
  return `rgb(${r},${g},${b})`
}

function gammaCorrect(channel) {
  if (channel <= 0.0031308) {
    return 12.92 * channel;
  } else {
    return 1.055 * Math.pow(channel, 1/2.4) - 0.055;
  }
}

function intcolor(n) {
  if (n <= 0) { return "0"; }
  if (n >= 1) { return "255"; }
  return (n * 255).toString(10);
}

// Lineweaver-Burk estimate for how many pixels will be black
function estimateLimit(data) {
  // Transform data: x becomes 1/x
  const transformedData = data.map(point => ({
    x: 1 / (point.x ** 0.75),
    y: point.y,
    weight: point.weight || 1  // Default weight to 1 if not provided
  }));

  // Calculate weighted means
  let sumWeights = 0;
  let sumWeightedX = 0;
  let sumWeightedY = 0;

  for (let point of transformedData) {
    sumWeights += point.weight;
    sumWeightedX += point.weight * point.x;
    sumWeightedY += point.weight * point.y;
  }

  const meanX = sumWeightedX / sumWeights;
  const meanY = sumWeightedY / sumWeights;

  // Calculate slope and intercept
  let numerator = 0;
  let denominator = 0;
  for (let point of transformedData) {
    numerator += point.weight * (point.x - meanX) * (point.y - meanY);
    denominator += point.weight * Math.pow(point.x - meanX, 2);
  }
  const slope = numerator / denominator;
  const intercept = meanY - slope * meanX;

  // The intercept is our estimate of the limit as 1/x approaches 0 (i.e., as x approaches infinity)
  return intercept;
}

const lastScriptLineNumber = parseInt(new Error().stack.match(/(:[\d]+)/)[0].replace(':',''));
</script>
<script id="workerCode" type="text/javascript">
class Board {
  constructor(k, size, re, im, config, id) {
    this.k = k;    // Number in explorer
    this.sizes = [size, toQd(re), toQd(im)];
    this.id = id;  // Random ID
    this.config = config;  // Global config

    this.it = 1;            // Current iteration
    this.un = config.dims2; // Unfinished pixels
    this.di = 0;            // Diverged pixels
    this.ch = 0;            // Chaotic pixels
    this.effort = 1;        // Work-per pixel

    this.pix = this.sizes[0] / this.config.dimsWidth;
    this.epsilon = Math.min(1e-12, this.pix / 10);
    this.epsilon2 = Math.min(1e-9, this.pix * 10);

    this.lastTime = 0;      // Time last message sent out
    this.changeList = [];   // List of new data to send
    this.updateSize = 0;    // Amount of data to send

    // Initialize arrays
    this.nn = new Array(this.config.dims2).fill(0);
    this.pp = new Array(this.config.dims2).fill(0);
    this.cc = [];
    this.zz = [];
    this.bb = [];
    this.hasCheckpoint = new Array(this.config.dims2).fill(false);  // Track if bb checkpoint is valid
    this.checkpointIter = new Array(this.config.dims2).fill(0);  // Iteration when checkpoint was saved
  }

  serialize() {
    return {
      type: this.constructor.name,
      k: this.k,
      sizes: this.sizes,
      id: this.id,
      config: this.config,
      it: this.it,
      un: this.un,
      di: this.di,
      ch: this.ch,
      lastTime: this.lastTime,
      changeList: this.changeList,
      updateSize: this.updateSize
    };
  }

  compact() {
  }

  queueChanges(changes) {
    if (changes !== null) {
      this.changeList.push(changes);
      this.updateSize += changes.nn.length + changes.vv.length;
    }
  }

  static fromSerialized(serialized) {
    const subclasses = new Map([
      ['CpuBoard', CpuBoard],
      ['PerturbationBoard', PerturbationBoard],
      ['ZhuoranBoard', ZhuoranBoard],
      ['GpuBoard', GpuBoard],
      ['GpuZhuoranBoard', GpuZhuoranBoard]
    ]);
    return subclasses.get(serialized.type).fromSerialized(serialized);
  }

  inspike(re, im) {
    // We do not iterate infinitely for chaotic points in the spike.
    return (im == 0.0 && re > -2.0 && re < -1.401155 &&
            this.config.exponent == 2);
  }

  inspikeQdA(re1, re2, im1, im2) {
    // We do not iterate infinitely for chaotic points in the spike.
    return (im1 + im2 == 0.0 && re1 >= -2.0 && re1 < -1.401155 &&
            this.config.exponent == 2);
  }

  unfinished() {
    // Chaotic points in the spike counted as finished after 100000 iterations.
    const result = Math.max(0, this.un + (this.it < 100000 ? 0 : -this.ch));
    return result;
  }
}

class CpuBoard extends Board {
  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);
    // Convert re and im to quad-double if they're scalars
    if (typeof re === 'number') re = toQd(re);
    if (typeof im === 'number') im = toQd(im);
    // Initialize board: cc = c values, zz = current z, bb = checkpoint z, ss = active pixel indices
    for (let y = 0; y < this.config.dimsHeight; y++) {
      const jFrac = (0.5 - (y / this.config.dimsHeight));
      const j = jFrac * (size / this.config.aspectRatio) + im[0];  // Scale by height
      for (let x = 0; x < this.config.dimsWidth; x++) {
        const rFrac = ((x / this.config.dimsWidth) - 0.5);
        const r = rFrac * size + re[0];  // Scale by width
        this.cc.push(r, j);
        if (this.inspike(r, j)) {
          this.ch += 1;
        }
      }
    }
    this.zz = this.cc.slice();  // Start with z = c
    this.bb = this.cc.slice();  // Initial checkpoint = c
    this.ss = Array(this.config.dims2).fill(null).map((_, i) => i);  // All pixels active
  }

  static fromSerialized(serialized) {
    const board = new CpuBoard(
      serialized.k,
      serialized.sizes[0],
      serialized.sizes[1],
      serialized.sizes[2],
      serialized.config,
      serialized.id
    );

    // Override initialized values with serialized data
    Object.assign(board, serialized);

    // Reconstruct sparse arrays from serialized data
    const cc = board.cc;
    board.cc = [];
    board.zz = [];
    board.bb = [];
    board.pp = [];
    for (let i = 0; i < serialized.ss.length; i++) {
      const index = serialized.ss[i];
      board.cc[index * 2] = cc[index * 2];
      board.cc[index * 2 + 1] = cc[index * 2 + 1];
      board.zz[index * 2] = serialized.zz[i * 2];
      board.zz[index * 2 + 1] = serialized.zz[i * 2 + 1];
      board.bb[index * 2] = serialized.bb[i * 2];
      board.bb[index * 2 + 1] = serialized.bb[i * 2 + 1];
      board.pp[index] = serialized.pp[i];
    }

    return board;
  }

  serialize() {
    return {
      ...super.serialize(),
      ss: this.ss,
      zz: this.ss.flatMap(i => [this.zz[i*2], this.zz[i*2+1]]),
      bb: this.ss.flatMap(i => [this.bb[i*2], this.bb[i*2+1]]),
      pp: this.ss.map(index => this.pp[index]),
    }
  }

  iterate() {
    let changes = null;
    const results = [0, 0, 0];
    let s = this.ss;    // speedy list of active pixel indices to compute
    // Update checkpoints at fibonacciPeriod intervals (returns 1 at Fibonacci points)
    if (fibonacciPeriod(this.it) == 1) {
      for (let t = 0; t < s.length; ++t) {
        let m = s[t];
        if (this.nn[m]) continue;
        this.bb[m * 2] = this.zz[m * 2];      // bb = checkpoint z position
        this.bb[m * 2 + 1] = this.zz[m * 2 + 1];
        this.pp[m] = 0;  // Reset pp (period = iter when convergence first detected)
      }
    }
    for (let t = 0; t < s.length; ++t) {
      const index = s[t];
      const computeResult = this.compute(index);
      if (computeResult !== 0) {
        if (!changes) {
          changes = { iter: this.it, nn: [], vv: [] };
        }
        if (computeResult < 0) {
          changes.vv.push({
            index: index,
            z: [this.zz[index * 2], this.zz[index * 2 + 1]],
            p: this.pp[index]  // period
          });
        } else {
          changes.nn.push(index);
        }
      }
    }
    if (changes) {
      this.un -= changes.nn.length + changes.vv.length; // newly finished
      this.di += changes.nn.length; // diverged
    }
    if (s.length > this.un * 1.25) {
      this.compact();
      if (this.ss.length > this.un + this.ch) {
        // Debug: Check for overlap between ss and changes
        if (changes) {
          const ssSet = new Set(this.ss);
          const changedIndexes = new Set([...changes.nn, ...changes.vv.map(v => v.index)]);
          const overlap = [...ssSet].filter(x => changedIndexes.has(x));
          if (overlap.length > 0) {
            console.warn(`Overlap detected between ss and changes: ${overlap.length} items`);
            console.warn(`Overlap indexes: ${overlap}`);
            console.warn(`ss length: ${this.ss.length}, un: ${this.un}`);
            console.warn(`changes: nn ${changes.nn.length}, vv ${changes.vv.length}`);
          }
        }

        // Additional checks
        const uniqueSS = new Set(this.ss);
        if (uniqueSS.size !== this.ss.length) {
          console.warn(`Duplicate entries in ss detected. ss length: ${this.ss.length}, unique entries: ${uniqueSS.size}`);
        }

        const invalidIndexes = this.ss.filter(i => this.nn[i]);
        if (invalidIndexes.length > 0) {
          console.warn(`Found ${invalidIndexes.length} indexes in ss that are already marked as finished in nn`);
        }

        if (this.ss.length !== this.un + this.ch) {
          console.warn(`Mismatch between ss length (${this.ss.length}) and un (${this.un})`);
        }
        throw new Error(`excess ss ${s.length}, ${this.ss.length}, ${this.un}`);
      }
    }

    this.it++;
    this.queueChanges(changes);
  }

  compact() {
    this.ss = this.ss.filter(i => !this.nn[i]);
  }

  compute(m) {
    if (this.nn[m]) return 0;
    const m2 = m * 2;
    const m2i = m2 + 1;
    const r = this.zz[m2];
    const j = this.zz[m2i];
    const r2 = r * r;
    const j2 = j * j;
    if (r2 + j2 > 4.0) {
      this.nn[m] = this.it;
      return 1;  // Diverged
    }
    // Mandelbrot iteration: z = z^exponent + c
    let ra = r2 - j2;
    let ja = 2 * r * j;
    for (let ord = 2; ord < this.config.exponent; ord++) {
      let rt = r * ra - j * ja;
      ja = r * ja + j * ra;
      ra = rt;
    }
    ra += this.cc[m2];
    ja += this.cc[m2i];
    this.zz[m2] = ra;
    this.zz[m2i] = ja;
    // Check convergence: compare current z to checkpoint
    const rb = this.bb[m2];
    const jb = this.bb[m2i];
    const db = Math.abs(rb - ra) + Math.abs(jb - ja);  // distance from checkpoint
    if (db <= this.epsilon2) {
      if (!this.pp[m]) { this.pp[m] = this.it; }  // Record iter when first detected
      if (db <= this.epsilon) {
        this.nn[m] = -this.it;
        if (this.inspike(this.cc[m2], this.cc[m2i]) && this.ch > 0) {
          this.ch -= 1;
        }
        return -1;  // Converged
      }
    }
    return 0;  // Continue iterating
  }

}

class PerturbationBoard extends Board {
  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);
    this.quadIndexes = [];   // Pixels computed in quad-double precision
    this.pertIndexes = [];   // Pixels computed as perturbations from quad points
    this.tt = [];            // Working array for quad-double operations
    this.perturbationThreshold = Math.min(0.1, Math.sqrt(1e15 * (size / config.dimsWidth)));
    this.effort = 3;
    this.initPerturbationBoard(size, re, im);
  }

  initPerturbationBoard(size, re, im) {
    this.cc = new Array(this.config.dims2 * 4).fill(NaN);
    // Odd grid ensures that center point corresponds to a quad precision pixel
    const gridSizeX = Math.floor(this.config.dimsWidth / 17 / 2) * 2 + 1;
    const gridSizeY = Math.floor(this.config.dimsHeight / 17 / 2) * 2 + 1;
    const stepX = this.config.dimsWidth / gridSizeX;
    const stepY = this.config.dimsHeight / gridSizeY;
    const offsetX = stepX / 2;
    const offsetY = stepY / 2;
    const pixW = size / this.config.dimsWidth;
    const pixH = (size / this.config.aspectRatio) / this.config.dimsHeight;
    const cc = this.cc;
    re = toQd(re);
    im = toQd(im);

    // Initialize reference points and perturbations
    for (let gy = 0; gy < gridSizeY; gy++) {
      const ry = Math.round(gy * stepY + offsetY);
      const jFrac = (0.5 - (ry / this.config.dimsHeight));
      const cj = qdAdd(im, qdScale(toQd(jFrac), size / this.config.aspectRatio))
      for (let gx = 0; gx < gridSizeX; gx++) {
        const rx = Math.round(gx * stepX + offsetX);
        const rFrac = ((rx / this.config.dimsWidth) - 0.5);
        const refIndex = (ry * this.config.dimsWidth + rx);
        const ri = refIndex * 4;
        const cr = qdAdd(re, qdScale(toQd(rFrac), size));

        // Initialize reference point
        cc[ri] = cr[0];
        cc[ri+1] = cr[1];
        cc[ri+2] = cj[0];
        cc[ri+3] = cj[1];
        this.quadIndexes.push(refIndex);
        let refspike = this.inspikeQdA(cr[0], cr[1], cj[0], cj[1]);
        if (refspike) {
          this.ch += 1;
        }

        // Initialize perturbations around this reference point
        const minY = Math.max(0, Math.floor(ry - offsetY));
        const maxY = Math.min(this.config.dimsHeight - 1, Math.ceil(ry + offsetY));
        const minX = Math.max(0, Math.floor(rx - offsetX));
        const maxX = Math.min(this.config.dimsWidth - 1, Math.ceil(rx + offsetX));
        for (let py = minY; py <= maxY; py++) {
          const dci = (ry - py) * pixH;
          for (let px = minX; px <= maxX; px++) {
            const dcr = (px - rx) * pixW;
            const pertIndex = (py * this.config.dimsWidth + px);
            const pi = pertIndex * 4;
            if (isNaN(cc[pi+3])) {  // Avoid double-initialization
              cc[pi] = dcr;
              cc[pi+1] = dci;
              cc[pi+2] = refIndex;
              cc[pi+3] = Infinity;
              this.pertIndexes.push(pertIndex);
              if (refspike && py == ry) {
                this.ch += 1;
              }
            }
          }
        }
      }
    }

    this.zz = this.cc.slice();
    this.bb = [];
    this.nz = [];
  }

  static fromSerialized(serialized) {
    const board = new PerturbationBoard(
      serialized.k,
      serialized.sizes[0],
      serialized.sizes[1],
      serialized.sizes[2],
      serialized.config,
      serialized.id
    );
    const cc = board.cc;

    // Override initialized values with serialized data
    Object.assign(board, serialized);
    delete board.pertZZ;

    // Reconstruct arrays from serialized data, leaving empty spots
    board.cc = [];
    board.zz = [];
    board.nz = [];
    board.bb = [];
    board.pp = [];
    for (let i = 0; i < serialized.quadIndexes.length; i++) {
      const index = serialized.quadIndexes[i];
      for (let j = 0; j < 4; j++) {
        board.zz[index * 4 + j] = board.nz[index * 4 + j] = serialized.zz[i * 4 + j];
        board.bb[index * 4 + j] = serialized.bb[i * 4 + j];
        board.cc[index * 4 + j] = cc[index * 4 + j];
      }
      if (!isFinite(cc[index * 4 + 3])) {
        board.initAsQuadPrecision(index, cc);
      }
      board.pp[index] = serialized.pp[i];
    }
    for (let i = 0; i < serialized.pertIndexes.length; i++) {
      const index = serialized.pertIndexes[i];
      for (let j = 0; j < 3; j++) {
        board.zz[index * 4 + j] = serialized.pertZZ[i * 3 + j];
        board.cc[index * 4 + j] = cc[index * 4 + j];
      }
      board.zz[index * 4 + 3] = board.cc[index * 4 + 3] = Infinity;
      board.pp[index] = 0;
    }
    return board;
  }

  serialize() {
    return {
      ...super.serialize(),
      quadIndexes: this.quadIndexes,
      pertIndexes: this.pertIndexes,
      zz: this.quadIndexes.flatMap(i => [this.zz[i*4], this.zz[i*4+1], this.zz[i*4+2], this.zz[i*4+3]]),
      bb: this.quadIndexes.flatMap(i => [this.bb[i*4], this.bb[i*4+1], this.bb[i*4+2], this.bb[i*4+3]]),
      pp: this.quadIndexes.map(index => this.pp[index]),
      pertZZ: this.pertIndexes.flatMap(i => [this.zz[i*4], this.zz[i*4+1], this.zz[i*4+2]]),
    };
  }

  iterate() {
    let changes = null;
    let results = [0, 0, 0];
    // Precompute quad-precision point escape without updating z
    // Update checkpoints at Fibonacci intervals
    const isCheckpoint = fibonacciPeriod(this.it) === 1;
    for (const index of this.quadIndexes) {
      if (isCheckpoint && !this.nn[index]) {
        AqdcCopy(this.bb, index*4, this.zz, index*4);  // bb = checkpoint z
        this.pp[index] = 0;  // Reset pp (period = iter when convergence first detected)
      }
      let r = this.precomputeQuad(index);
      results[r + 1] += 1;
      if (r !== 0) {
        if (!changes) {
          changes = { iter: this.it, nn: [], vv: [] };
        }
        if (r < 0) {
          changes.vv.push({
            index: index,
            z: AqdcGet(this.nz, index*4),
            p: this.pp[index]  // period
          });
        } else {
          changes.nn.push(index);
        }
      }
    }
    // Iterate perturbation points that use the old z
    const newQuadIndexes = [];
    let cache = { refIndex: null, binZpow: [] };
    for (const index of this.pertIndexes) {
      if (!this.computePerturbation(index, cache)) {
        this.convertToQuadPrecision(index);
        let r = this.precomputeQuad(index);
        results[r + 1] += 1;
        newQuadIndexes.push(index);
        if (r !== 0) {
          if (!changes) {
            changes = { iter: this.it, nn: [], vv: [] };
          }
          if (r < 0) {
            changes.vv.push({
              index: index,
              z: z,
              p: this.pp[index]  // period
            });
          } else {
            changes.nn.push(index);
          }
        }
      }
    }
    // Update index arrays
    if (newQuadIndexes.length > 0) {
      const newPertIndexes = [];
      let qi = 0;
      for (const index of this.pertIndexes) {
        if (newQuadIndexes[qi] == index) {
          qi += 1;
        } else {
          newPertIndexes.push(index);
        }
      }
      this.quadIndexes = this.quadIndexes.concat(newQuadIndexes);
      this.pertIndexes = newPertIndexes;
    }
    // Finally update quad-precision z with precomputed values
    for (const index of this.quadIndexes) {
      AqdcCopy(this.zz, index*4, this.nz, index*4);
    }
    // Tally progress
    let diverged = results[2];
    let count = results[0] + diverged;
    this.un -= count;
    this.di += diverged;
    // Trim finished pixels from array.
    if (this.pertIndexes.length + this.quadIndexes.length > this.un * 1.25) {
      this.compact();
      // Switch to full quad when perturbations are a small fraction of the work
      if (this.pertIndexes.length < this.quadIndexes.length * 0.5) {
        for (const index of this.pertIndexes) {
          this.convertToQuadPrecision(index);
          this.quadIndexes.push(index);
        }
        this.pertIndexes = [];
      }
    }
    this.it++;
    this.queueChanges(changes);
  }

  compact() {
    const trimmedQuadIndexes = this.quadIndexes.filter(i => !this.nn[i]);
    this.quadIndexes = trimmedQuadIndexes;
  }

  precomputeQuad(m) {
    // Quad-precision Mandelbrot iteration with convergence detection
    if (this.nn[m]) return 0;
    const m4 = m * 4;
    const tt = this.tt;
    const nz = this.nz;
    const r1 = this.zz[m4];
    const r2 = this.zz[m4+1];
    const j1 = this.zz[m4+2];
    const j2 = this.zz[m4+3];
    const cr1 = this.cc[m4];
    const cr2 = this.cc[m4+1];
    const cj1 = this.cc[m4+2];
    const cj2 = this.cc[m4+3];
    const br1 = this.bb[m4];  // bb = checkpoint z (quad-double)
    const br2 = this.bb[m4+1];
    const bj1 = this.bb[m4+2];
    const bj2 = this.bb[m4+3];
    AqdSquare(tt, 0, r1, r2);                    // 0: rsq = r**2
    AqdSquare(tt, 2, j1, j2);                    // 2: jsq = j**2
    AqdAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);   // 4: d = rsq+jsq
    if (tt[4] > 4) {  // Check divergence: |z|Â² > 4
      this.nn[m] = this.it;
      AqdcCopy(nz, m4, this.zz, m4);
      return 1;  // Diverged
    }
    AqdMul(tt, 6, 2 * r1, 2 * r2, j1, j2);       // 6: ja = 2*r*j
    AqdAdd(tt, 8, tt[0], tt[1], -tt[2], -tt[3]); // 8: ra = rsq-jsq
    for (let ord = 2; ord < this.config.exponent; ord++) {
      AqdMul(tt, 0, j1, j2, tt[6], tt[7]);         // 0: j * ja
      AqdMul(tt, 2, r1, r2, tt[8], tt[9]);         // 2: r * ra
      AqdAdd(tt, 4, -tt[0], -tt[1], tt[2], tt[3]); // 4: rt = r*ra - j*ja
      AqdMul(tt, 0, r1, r2, tt[6], tt[7]);         // 0: r * ja
      AqdMul(tt, 2, j1, j2, tt[8], tt[9]);         // 2: j * ra
      AqdAdd(tt, 6, tt[0], tt[1], tt[2], tt[3]);   // 6: ja = r*ja + j*ra
      AqdSet(tt, 8, tt[4], tt[5]);                 // 8: ra = rt
    }
    AqdAdd(nz, m4, tt[8], tt[9], cr1, cr2);        // nz: nzr = ra + cr
    AqdAdd(nz, m4+2, tt[6], tt[7], cj1, cj2);      // nz+2: nzj = ja + cj
    // Check convergence: compare new z to checkpoint
    AqdAbsSub(tt, 0, br1, br2, nz[m4], nz[m4+1]);  // 0: abs(nzr - br)
    AqdAbsSub(tt, 2, bj1, bj2, nz[m4+2], nz[m4+3]);// 2: abs(nzj - bj)
    AqdAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);     // 4: db = abs(nzr-br)+abs(nzj-bj)
    const db = tt[4] + tt[5]  // distance from checkpoint
    if (db <= this.epsilon2) {
      if (!this.pp[m]) { this.pp[m] = this.it; }  // Record iter when first detected
      if (db <= this.epsilon) {
        this.nn[m] = -this.it;
        if (this.inspikeQdA(cr1, cr2, cj1, cj2) && this.ch > 0) {
          this.ch -= 1;
        }
        return -1;  // Converged
      }
    }
    return 0;  // Continue iterating
  }

  computePerturbation(index, cache) {
    const m4 = index * 4;
    const cr = this.cc[m4]
    const ci = this.cc[m4+1]
    const refIndex = this.cc[m4+2]
    const ri4 = refIndex * 4;
    const dr = this.zz[m4];
    const di = this.zz[m4+1];

    // Switch to quad when approaching convergence.
    if (this.nn[refIndex] || this.pp[refIndex]) return false;

    // Compute binomial powers of z
    if (cache.refIndex !== refIndex) {
      cache.refIndex = refIndex;
      const ri4 = refIndex * 4;
      const zr = this.zz[ri4];
      const zi = this.zz[ri4+2];
      this.fillBinZpow(cache.binZpow, zr, zi);
    }
    const binZpow = cache.binZpow;

    // Compute in (z+d)^n - z^n = nz^(n-1) d + (n(n-1)/2)z^(n-2) d^2...
    let r = dr;
    let i = di;
    for (let ord = 0; ord < binZpow.length; ord += 2) {
      r += binZpow[ord];
      i += binZpow[ord+1];
      const rNew = r * dr - i * di;
      i = r * di + i * dr;
      r = rNew;
    }

    // Add perturbation in c
    r += cr;
    i += ci;

    if (this.isThresholdExceeded(r, i, refIndex)) {
      return false;
    }

    this.zz[m4] = r;
    this.zz[m4+1] = i;
    return true;
  }

  fillBinZpow(binZpow, zr, zi) {
    let zrCurrent = zr, ziCurrent = zi;
    let coeff = this.config.exponent;

    for (let k = 1; k < this.config.exponent - 1; k++) {
      binZpow[k*2-2] = coeff * zrCurrent;
      binZpow[k*2-1] = coeff * ziCurrent;

      // Update z power
      const zrNew = zrCurrent * zr - ziCurrent * zi;
      ziCurrent = zrCurrent * zi + ziCurrent * zr;
      zrCurrent = zrNew;

      // Update coefficient for next iteration
      coeff *= (this.config.exponent - k) / (k + 1);
    }

    // Add the last element without computing the next z power or coefficient
    if (this.config.exponent > 1) {
      binZpow[this.config.exponent*2 - 4] = coeff * zrCurrent;
      binZpow[this.config.exponent*2 - 3] = coeff * ziCurrent;
    }
  }

  isThresholdExceeded(dr, di, refIndex) {
    const mag = Math.max(Math.abs(dr), Math.abs(di));
    if (mag > this.perturbationThreshold) return true;
    // If orbit is getting large, then be more careful.
    if (mag * 10 < this.perturbationThreshold) return false;
    const zr = this.zz[refIndex * 4];
    const zi = this.zz[refIndex * 4 + 2];
    return ((dr + zr) ** 2 + (di + zi) ** 2 > 3);
  }

  convertToQuadPrecision(index) {
    const m4 = index * 4;
    const dr = this.zz[m4];
    const di = this.zz[m4+1];
    const cr = this.cc[m4];
    const ci = this.cc[m4+1];
    const refIndex = this.cc[m4+2];
    const ri4 = refIndex * 4;
    AqdAdd(this.zz, m4, dr, 0, this.zz[ri4], this.zz[ri4+1])
    AqdAdd(this.zz, m4+2, di, 0, this.zz[ri4+2], this.zz[ri4+3])
    AqdAdd(this.cc, m4, cr, 0, this.cc[ri4], this.cc[ri4+1])
    AqdAdd(this.cc, m4+2, ci, 0, this.cc[ri4+2], this.cc[ri4+3])
  }

  initAsQuadPrecision(index, refcc) {
    const m4 = index * 4;
    const cr = this.cc[m4];
    const ci = this.cc[m4+1];
    const refIndex = this.cc[m4+2];
    const ri4 = refIndex * 4;
    AqdAdd(this.cc, m4, cr, 0, refcc[ri4], refcc[ri4+1])
    AqdAdd(this.cc, m4+2, ci, 0, refcc[ri4+2], refcc[ri4+3])
  }
}

// Reference Orbit Threading - enables robust cycle detection despite rebasing
class ReferenceOrbitThreading {
  constructor(epsilon) {
    const floatPrecision = 1e-7;
    const maxCycleLength = 1e5;
    // epsilon3: as large as possible while keeping single-precision ability to calculate at epsilon precision
    this.epsilon3 = epsilon * 1e7 / Math.sqrt(maxCycleLength);
    this.bucketSize = 2 * this.epsilon3;
    this.threadingWindowSize = Math.min(1024, Math.floor(maxCycleLength));  // Small window to limit bucket growth
    this.refThreading = [];  // {next: index, deltaRe: f32, deltaIm: f32}
    this.spatialBuckets = new Map();
    this.minJump = 10;
  }

  addOrbitPoint(currentIndex, re, im, getPoint) {
    // Find nearest past neighbor in spatial buckets
    const bx = Math.floor(re / this.bucketSize);
    const by = Math.floor(im / this.bucketSize);
    let nearest = -1;
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const bucket = this.spatialBuckets.get(`${bx + dx},${by + dy}`);
        if (!bucket) continue;
        for (const j of bucket) {
          if (j >= currentIndex) continue;  // Only thread to past iterations
          const pt = getPoint(j);
          if (!pt) continue;
          const dist = Math.max(Math.abs(re - pt.re), Math.abs(im - pt.im));
          if (dist <= this.epsilon3 && j > nearest) nearest = j;
        }
      }
    }

    // Add thread
    this.refThreading.push({next: -1, deltaRe: 0, deltaIm: 0});
    if (nearest >= 0) {
      const pt = getPoint(nearest);
      this.refThreading[nearest] = {
        next: currentIndex,
        deltaRe: Math.fround(re - pt.re),
        deltaIm: Math.fround(im - pt.im)
      };
    }

    // Update spatial buckets
    const key = `${bx},${by}`;
    if (!this.spatialBuckets.has(key)) this.spatialBuckets.set(key, []);
    this.spatialBuckets.get(key).push(currentIndex);

    // Cleanup old entries
    if (currentIndex >= this.threadingWindowSize) {
      const oldIdx = currentIndex - this.threadingWindowSize;
      const oldPt = getPoint(oldIdx);
      if (oldPt) {
        const oldKey = `${Math.floor(oldPt.re / this.bucketSize)},${Math.floor(oldPt.im / this.bucketSize)}`;
        const bucket = this.spatialBuckets.get(oldKey);
        if (bucket) {
          const pos = bucket.indexOf(oldIdx);
          if (pos >= 0) bucket.splice(pos, 1);
          if (bucket.length === 0) this.spatialBuckets.delete(oldKey);
        }
      }
    }
  }
}

// Single reference orbit perturbation method.
// Based on Zhuoran Li's 2021 approach: https://mathr.co.uk/blog/2021-05-14_stretching_deep_zoom.html
// Rebasing implementation follows Imagina: https://github.com/ImaginaFractal/Imagina
class ZhuoranBoard extends Board {
  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);
    // Reference orbit data (quad-double precision)
    this.maxRefIterations = 10000;  // Will grow dynamically
    this.refOrbit = [];  // Array of [r_high, r_low, i_high, i_low] for each iteration
    this.refOrbitEscaped = false;
    this.refIterations = 0;  // Current length of reference orbit
    // Reference point (center of image)
    const refRe = toQd(re);
    const refIm = toQd(im);
    this.refC = [refRe[0], refRe[1], refIm[0], refIm[1]];
    // Per-pixel data (double precision)
    this.dc = [];  // Delta c from reference point [real, imag] pairs
    this.dz = [];  // Current perturbation delta [real, imag] pairs
    this.refIter = [];  // Which iteration of reference each pixel is following
    this.pixelIndexes = [];  // Active pixel indices
    this.maxRefIter = 1;  // Track maximum refIter to avoid scanning all pixels
    // Working array for quad-double operations
    this.tt = new Array(16);
    // Threading for robust cycle detection
    this.threading = new ReferenceOrbitThreading(this.epsilon);
    // Initialize reference orbit with z = 0 and z = c
    this.refOrbit.push([0, 0, 0, 0]);  // Iteration 0: z = 0
    this.refOrbit.push(this.refC.slice());  // Iteration 1: z = 0^2 + c = c
    this.refIterations = 1;  // We have computed 1 iteration beyond z=0
    this.threading.refThreading.push({next: -1, deltaRe: 0, deltaIm: 0});  // iter 0
    this.threading.refThreading.push({next: -1, deltaRe: 0, deltaIm: 0});  // iter 1
    this.initPixels(size, re, im);
    this.effort = 2;  // Slightly lower than PerturbationBoard since simpler
  }

  initPixels(size, re, im) {
    const pixW = size / this.config.dimsWidth;
    const pixH = (size / this.config.aspectRatio) / this.config.dimsHeight;
    const dimsWidth = this.config.dimsWidth;
    const dimsHeight = this.config.dimsHeight;
    const refRe = this.refC[0] + this.refC[1];
    const refIm = this.refC[2] + this.refC[3];
    // BUG FIX: re and im might be quad-double arrays, convert to regular doubles
    const re_double = Array.isArray(re) ? (re[0] + re[1]) : re;
    const im_double = Array.isArray(im) ? (im[0] + im[1]) : im;
    // Initialize all pixels as perturbations from the reference point
    for (let y = 0; y < dimsHeight; y++) {
      const yFrac = (0.5 - y / dimsHeight);
      const ci = im_double + yFrac * (size / this.config.aspectRatio);
      const dci = ci - refIm;
      for (let x = 0; x < dimsWidth; x++) {
        const xFrac = (x / dimsWidth - 0.5);
        const cr = re_double + xFrac * size;
        const dcr = cr - refRe;
        const index = y * dimsWidth + x;
        this.dc[index * 2] = dcr;
        this.dc[index * 2 + 1] = dci;
        // Start with z = c (skipping trivial first iteration where 0^2+c=c)
        // At refIter=1 where refOrbit[1] = c_ref, with dz = dc: z = c_ref + dc = c
        this.dz[index * 2] = dcr;
        this.dz[index * 2 + 1] = dci;
        this.refIter[index] = 1;  // Start at iteration 1 (z = c)
        this.pixelIndexes.push(index);
        if (this.inspike(cr, ci)) {
          this.ch += 1;
        }
      }
    }
  }

  static fromSerialized(serialized) {
    const board = new ZhuoranBoard(
      serialized.k,
      serialized.sizes[0],
      serialized.sizes[1],
      serialized.sizes[2],
      serialized.config,
      serialized.id
    );

    // Restore state
    Object.assign(board, serialized);

    // Recompute maxRefIter if not in serialized data
    if (!serialized.maxRefIter) {
      board.maxRefIter = 1;
      for (let i = 0; i < board.refIter.length; i++) {
        if (board.refIter[i] > board.maxRefIter) {
          board.maxRefIter = board.refIter[i];
        }
      }
    }

    return board;
  }

  serialize() {
    return {
      ...super.serialize(),
      refOrbit: this.refOrbit,
      refOrbitEscaped: this.refOrbitEscaped,
      refIterations: this.refIterations,
      refC: this.refC,
      dc: this.dc,
      dz: this.dz,
      refIter: this.refIter,
      pixelIndexes: this.pixelIndexes
    };
  }

  iterate() {
    let changes = null;
    // Step 1: Extend reference orbit if needed and not escaped
    // Use cached maxRefIter to avoid scanning all pixels every iteration
    const targetRefIterations = Math.max(this.it + 100, this.maxRefIter + 100);
    while (!this.refOrbitEscaped && this.refIterations < targetRefIterations) {
      this.extendReferenceOrbit();
    }
    // Step 2: Iterate all active pixels using perturbation
    const newPixelIndexes = [];
    for (const index of this.pixelIndexes) {
      if (this.nn[index]) continue;  // Skip finished pixels
      const result = this.iteratePixel(index);
      if (result !== 0) {
        if (!changes) {
          changes = { iter: this.it, nn: [], vv: [] };
        }
        if (result > 0) {
          // Diverged
          changes.nn.push(index);
          this.nn[index] = this.it;
          this.di += 1;
          this.un -= 1;
        } else {
          // Converged
          const index2 = index * 2;
          // Report the CURRENT z position after the iteration
          // Note: refIter was NOT incremented (returned before increment)
          // dz corresponds to refIter+1
          const nextRefIter = this.refIter[index] + 1;
          const ref = nextRefIter < this.refOrbit.length ? this.refOrbit[nextRefIter] : this.refOrbit[this.refOrbit.length - 1];
          const refR = ref ? (ref[0] + ref[1]) : 0;
          const refI = ref ? (ref[2] + ref[3]) : 0;
          changes.vv.push({
            index: index,
            z: [refR + this.dz[index2], refI + this.dz[index2 + 1]],
            p: this.pp[index]  // period = iter when convergence first detected
          });
          this.nn[index] = -this.it;
          this.un -= 1;
          if (this.inspike(
            this.dc[index2] + this.refC[0] + this.refC[1],
            this.dc[index2 + 1] + this.refC[2] + this.refC[3]
          ) && this.ch > 0) {
            this.ch -= 1;
          }
        }
      } else {
        newPixelIndexes.push(index);
      }
    }
    this.pixelIndexes = newPixelIndexes;
    // Compact if needed
    if (this.pixelIndexes.length > this.un * 1.25) {
      this.pixelIndexes = this.pixelIndexes.filter(i => !this.nn[i]);
    }
    this.it++;
    this.queueChanges(changes);
  }

  extendReferenceOrbit() {
    // Compute one more iteration of the reference orbit in quad-double precision
    const lastIndex = this.refIterations;
    const last = this.refOrbit[lastIndex];
    const tt = this.tt;

    const r1 = last[0];
    const r2 = last[1];
    const j1 = last[2];
    const j2 = last[3];

    // Check for escape
    AqdSquare(tt, 0, r1, r2);                    // rsq = r**2
    AqdSquare(tt, 2, j1, j2);                    // jsq = j**2
    AqdAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);   // d = rsq + jsq

    // tt[4] is the high part of the magnitude squared (tt[5] is just the low correction)
    // Use very large escape radius for reference orbit to support all pixel iterations
    // Reference must stay valid longer than any pixel, so use much larger threshold
    if (tt[4] > 1e10) {
      this.refOrbitEscaped = true;
      return;
    }

    // Compute z^n for general exponent
    AqdMul(tt, 6, 2 * r1, 2 * r2, j1, j2);       // ja = 2*r*j
    AqdAdd(tt, 8, tt[0], tt[1], -tt[2], -tt[3]); // ra = rsq - jsq

    for (let ord = 2; ord < this.config.exponent; ord++) {
      AqdMul(tt, 0, j1, j2, tt[6], tt[7]);         // j * ja
      AqdMul(tt, 2, r1, r2, tt[8], tt[9]);         // r * ra
      AqdAdd(tt, 4, -tt[0], -tt[1], tt[2], tt[3]); // rt = r*ra - j*ja
      AqdMul(tt, 0, r1, r2, tt[6], tt[7]);         // r * ja
      AqdMul(tt, 2, j1, j2, tt[8], tt[9]);         // j * ra
      AqdAdd(tt, 6, tt[0], tt[1], tt[2], tt[3]);   // ja = r*ja + j*ra
      AqdSet(tt, 8, tt[4], tt[5]);                 // ra = rt
    }

    // Add c to get next z
    const newZ = [0, 0, 0, 0];
    AqdAdd(newZ, 0, tt[8], tt[9], this.refC[0], this.refC[1]);      // real part
    AqdAdd(newZ, 2, tt[6], tt[7], this.refC[2], this.refC[3]);      // imag part

    this.refOrbit.push(newZ);
    this.refIterations++;

    // Threading: add new orbit point
    // PERFORMANCE: Only compute threading after settling period (first 2000 iterations)
    // This avoids overhead during early orbit computation when threading is poor anyway
    if (this.refIterations >= 2000) {
      const re = newZ[0] + newZ[1];
      const im = newZ[2] + newZ[3];
      const getPoint = (i) => {
        if (i < 0 || i >= this.refOrbit.length) return null;
        const p = this.refOrbit[i];
        return { re: p[0] + p[1], im: p[2] + p[3] };
      };
      this.threading.addOrbitPoint(this.refIterations, re, im, getPoint);
    }

    // Grow array if needed
    if (this.refIterations >= this.maxRefIterations) {
      this.maxRefIterations *= 2;
    }
  }

  iteratePixel(index) {
    const index2 = index * 2;
    let refIter = this.refIter[index];
    // Ensure reference orbit exists for this iteration
    if (refIter >= this.refOrbit.length) {
      // Need more reference orbit iterations
      if (this.refOrbitEscaped) {
        // Reference has escaped, can't extend further
        // Imagina's approach: Rebase to beginning of reference orbit
        // This allows continued use of perturbation theory
        // Get current z value
        const lastRef = this.refOrbit[this.refOrbit.length - 1];
        const lastRefR = lastRef[0] + lastRef[1];
        const lastRefI = lastRef[2] + lastRef[3];
        const dr = this.dz[index2];
        const di = this.dz[index2 + 1];
        // Set dz to current total position (Imagina's VecResetAndSync)
        // TESTING: Use Math.fround to simulate float32 precision like GPU
        this.dz[index2] = Math.fround(lastRefR + dr);
        this.dz[index2 + 1] = Math.fround(lastRefI + di);
        // Restart from iteration 0 (where z_ref = 0)
        this.refIter[index] = 0;
        refIter = 0;
        // Continue with perturbation iteration from the top
        // (don't return, fall through to normal iteration code below)
      } else {
        // This shouldn't happen with proper reference orbit extension
        console.warn(`Pixel ${index} needs refIter ${refIter} but orbit length is ${this.refOrbit.length}`);
        return 1;  // Mark as diverged only if unexpected
      }
    }
    // Check if we need to rebase (Zhuoran's key innovation)
    if (this.shouldRebase(index)) {
      // Imagina's rebasing: set dz = z_total and restart from refIter = 0
      const ref = this.refOrbit[refIter];
      const refR = ref[0] + ref[1];
      const refI = ref[2] + ref[3];
      const dr = this.dz[index2];
      const di = this.dz[index2 + 1];
      // Set dz to current total position (z_ref + dz)
      // TESTING: Use Math.fround to simulate float32 precision like GPU
      this.dz[index2] = Math.fround(refR + dr);
      this.dz[index2 + 1] = Math.fround(refI + di);
      // Restart from iteration 0 (where z_ref = 0)
      this.refIter[index] = 0;
      refIter = 0;

      // NOTE: We do NOT modify the checkpoint here
      // The difference-based comparison works across rebases:
      // z_current - z_checkpoint = [ref[0] - ref[ckpt_ref_iter]] + [dz_absolute - dz_ckpt]
    }
    // Get reference orbit value for current iteration
    const ref = this.refOrbit[refIter];
    if (!ref) {
      // Safety check - this shouldn't happen with the fix above
      console.error(`Missing reference orbit at iteration ${refIter}`);
      return 0;
    }
    const refR = ref[0] + ref[1];  // Convert quad to double
    const refI = ref[2] + ref[3];
    // Perturbation iteration using binomial expansion (Horner's method)
    // (z_ref+dz)^n - z_ref^n = sum(k=1 to n) C(n,k) * z_ref^(n-k) * dz^k
    const dr = this.dz[index2];
    const di = this.dz[index2 + 1];
    // Save the OLD z value (before this iteration) for checkpoint timing
    // This matches CpuBoard's behavior where bb is set BEFORE computing the new z
    const oldZR = refR + dr;
    const oldZI = refI + di;

    // TESTING: Use Math.fround to simulate float32 precision like GPU
    const exponent = this.config.exponent || 2;

    // Build binomial powers: coeff * z_ref^power for each term
    let zPowR = refR;
    let zPowI = refI;
    let coeff = exponent;

    // Start Horner's method with innermost term (just dz)
    let resultR = dr;
    let resultI = di;

    // Horner's method: accumulate terms from highest to lowest power of z_ref
    for (let k = 1; k < exponent; k++) {
      // Add coeff * z_ref^power term
      const termR = coeff * zPowR;
      const termI = coeff * zPowI;
      resultR = Math.fround(resultR + termR);
      resultI = Math.fround(resultI + termI);

      // Multiply by dz (complex multiplication)
      const tempR = Math.fround(Math.fround(resultR * dr) - Math.fround(resultI * di));
      resultI = Math.fround(Math.fround(resultR * di) + Math.fround(resultI * dr));
      resultR = tempR;

      // Update z_ref power: z_pow = z_pow * z_ref
      const newZPowR = Math.fround(Math.fround(zPowR * refR) - Math.fround(zPowI * refI));
      zPowI = Math.fround(Math.fround(zPowR * refI) + Math.fround(zPowI * refR));
      zPowR = newZPowR;

      // Update coefficient: coeff *= (n-k) / (k+1)
      coeff *= (exponent - k) / (k + 1);
    }

    // Add perturbation in c
    const newDr = Math.fround(resultR + this.dc[index2]);
    const newDi = Math.fround(resultI + this.dc[index2 + 1]);
    // Update dz first before checking divergence
    this.dz[index2] = newDr;
    this.dz[index2 + 1] = newDi;
    // Now check for divergence with the updated values
    // IMPORTANT: The new z value is refOrbit[refIter+1] + newDz, not refOrbit[refIter] + newDz!
    // We used refOrbit[refIter] to COMPUTE newDz, but the result corresponds to the NEXT reference iteration
    const nextRefIter = refIter + 1;
    if (nextRefIter >= this.refOrbit.length) {
      // This shouldn't happen because we extend the reference orbit beforehand
      console.error(`nextRefIter ${nextRefIter} >= refOrbit.length ${this.refOrbit.length}`);
      return 1;
    }
    const nextRef = this.refOrbit[nextRefIter];
    const nextRefR = nextRef[0] + nextRef[1];
    const nextRefI = nextRef[2] + nextRef[3];
    // Use escape radius 2 (magnitudeÂ² > 4)
    const totalR = nextRefR + newDr;
    const totalI = nextRefI + newDi;
    const totalMag2 = totalR * totalR + totalI * totalI;
    if (totalMag2 > 4) {
      return 1;  // Diverged
    }

    // CONVERGENCE DETECTION: fibonacciPeriod returns 1 at Fibonacci checkpoints
    // Step 1: Update checkpoint at fibonacciPeriod intervals
    const justUpdatedCheckpoint = (fibonacciPeriod(this.it) == 1);
    if (justUpdatedCheckpoint) {
      // Store dz (perturbation) and which reference iteration we're at
      // This allows precise difference computation: (ref[current] - ref[checkpoint]) + (dz[current] - dz[checkpoint])
      // TESTING: Use Math.fround to simulate float32 precision like GPU
      this.bb[index2] = Math.fround(dr);  // dz real at checkpoint (BEFORE iteration)
      this.bb[index2 + 1] = Math.fround(di);  // dz imag at checkpoint
      this.hasCheckpoint[index] = true;
      this.checkpointIter[index] = refIter;  // Which reference iteration (not this.it!)
      this.pp[index] = 0;  // Reset pp (period = iter when convergence first detected)
    }
    // Step 2: Check convergence EVERY iteration (if we have a checkpoint and didn't just update it)
    if (this.hasCheckpoint[index] && !justUpdatedCheckpoint) {
      const checkpointRefIter = this.checkpointIter[index];

      // NEW APPROACH: Check if we're at the same reference iteration
      // If refIter matches checkpointRefIter, we're at the same point in the reference orbit cycle
      // In that case, we only need to check if the perturbation dz is close to the checkpoint dz
      // This works even across rebases: after rebase, we wait for refIter to cycle back to match
      if (refIter === checkpointRefIter) {
        const checkpoint_dr = this.bb[index2];
        const checkpoint_di = this.bb[index2 + 1];

        // Compute Chebyshev distance (L-infinity norm) between current INPUT dz and checkpoint dz
        // Both are at the same refIter position, so we're comparing the same point in the orbit cycle
        // TESTING: Use Math.fround to simulate float32 precision like GPU
        const dzDiffR = Math.fround(Math.fround(dr) - Math.fround(checkpoint_dr));
        const dzDiffI = Math.fround(Math.fround(di) - Math.fround(checkpoint_di));
        const db = Math.max(Math.abs(dzDiffR), Math.abs(dzDiffI));

        if (db <= this.epsilon2) {
          if (!this.pp[index]) {
            this.pp[index] = this.it - 1;  // ZhuoranBoard: -1 to account for checkpoint timing
          }
          if (db <= this.epsilon) {
            return -1;  // Converged! Return before incrementing refIter
          }
        }
      }

      // THREAD-FOLLOWING & FALLBACK: Only after enough iterations
      // Activate after 2584 iterations (Fibonacci F(18)) to match GPU behavior
      if (this.it > 2584) {
        // First try thread-following (more precise than absolute position comparison)
        if (checkpointRefIter < this.refOrbit.length) {
          let current = checkpointRefIter;
          let deltaRe = 0;
          let deltaIm = 0;
          const maxSteps = 100;  // Match GPU limit to reduce pause
          let steps = 0;

          // Follow threads forward from checkpoint
          while (steps < maxSteps && current < this.refOrbit.length) {
            const thread = this.threading.refThreading[current];
            if (!thread || thread.next < 0) break;

            deltaRe += thread.deltaRe;
            deltaIm += thread.deltaIm;
            current = thread.next;
            steps++;

            // Check if we're close to current refIter
            if (Math.abs(current - refIter) <= 10) {
              const checkpoint_dr = this.bb[index2];
              const checkpoint_di = this.bb[index2 + 1];
              const dzDiffR = Math.fround(Math.fround(dr) - Math.fround(checkpoint_dr));
              const dzDiffI = Math.fround(Math.fround(di) - Math.fround(checkpoint_di));
              const totalDiffR = deltaRe + dzDiffR;
              const totalDiffI = deltaIm + dzDiffI;
              const db = Math.max(Math.abs(totalDiffR), Math.abs(totalDiffI));

              if (db <= this.epsilon2) {
                if (!this.pp[index]) {
                  this.pp[index] = this.it - 1;  // ZhuoranBoard: -1 to account for checkpoint timing
                }
                if (db <= this.epsilon) {
                  return -1;  // Converged via threading!
                }
              }
              break;  // Don't continue thread-following
            }
          }
        }

        // FALLBACK: If thread-following didn't help, use absolute position comparison
        // This handles orbits that never rebase (staying close to reference but never triggering rebase)
        const checkpoint_dr = this.bb[index2];
        const checkpoint_di = this.bb[index2 + 1];

        // Compute absolute positions at checkpoint and current iteration
        const refCheckpoint = this.refOrbit[checkpointRefIter];
        const refCheckpointR = refCheckpoint[0] + refCheckpoint[1];
        const refCheckpointI = refCheckpoint[2] + refCheckpoint[3];

        // Total difference in absolute positions
        const diffR = (refR + dr) - (refCheckpointR + checkpoint_dr);
        const diffI = (refI + di) - (refCheckpointI + checkpoint_di);
        const db = Math.max(Math.abs(diffR), Math.abs(diffI));

        if (db <= this.epsilon2) {
          if (!this.pp[index]) {
            this.pp[index] = this.it - 1;  // ZhuoranBoard: -1 to account for checkpoint timing
          }
          if (db <= this.epsilon) {
            return -1;  // Converged! Return before incrementing refIter
          }
        }
      }
    }
    // Update reference iteration counter (dz was already updated above)
    this.refIter[index]++;
    // Update cached maximum to avoid scanning all pixels
    if (this.refIter[index] > this.maxRefIter) {
      this.maxRefIter = this.refIter[index];
    }
    return 0;  // Continue iterating
  }

  shouldRebase(index) {
    // Zhuoran's rebasing condition using Chebyshev norm (Imagina's optimization)
    // Rebase when max(|z_total|) < max(|dz|)
    // This detects when we're near the critical point (0 for Mandelbrot)
    const index2 = index * 2;
    const dr = this.dz[index2];
    const di = this.dz[index2 + 1];

    const refIter = this.refIter[index];

    // Don't rebase if we're already at iteration 0 (start of reference orbit)
    if (refIter === 0) {
      return false;
    }

    // Check if reference orbit exists for this iteration
    if (refIter >= this.refOrbit.length || !this.refOrbit[refIter]) {
      return false; // Can't check, don't rebase
    }

    const ref = this.refOrbit[refIter];
    const refR = ref[0] + ref[1];
    const refI = ref[2] + ref[3];

    // Compute Chebyshev norm (L-infinity norm) - cheaper than magnitude squared
    const dzNorm = Math.max(Math.abs(dr), Math.abs(di));
    const totalR = refR + dr;
    const totalI = refI + di;
    const totalNorm = Math.max(Math.abs(totalR), Math.abs(totalI));

    // Rebase when orbit approaches critical point (0)
    // Use factor of 2 to rebase less aggressively, reducing cumulative errors
    return totalNorm < dzNorm * 2.0;
  }

  getCurrentRefZ(index) {
    const refIter = this.refIter[index];
    if (refIter <= this.refIterations && this.refOrbit[refIter]) {
      return this.refOrbit[refIter];
    }
    return [0, 0, 0, 0];
  }
}

// WebGPU-accelerated Mandelbrot computation using single-precision float32
// GPU computes all pixels in parallel using standard Mandelbrot iteration
// Base class for WebGPU-accelerated boards
// Provides shared GPU infrastructure for different computation strategies
class GpuBaseBoard extends Board {
  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);

    // Save parameters
    this.size = size;
    this.re = re;
    this.im = im;

    // WebGPU state (shared by all GPU board implementations)
    this.device = null;
    this.pipeline = null;
    this.buffers = {};
    this.isGPUReady = false;
    this.gpuInitPromise = null;
    this.isComputing = false;
    this.computePromise = null;  // Track current async computation
    this.lastReportedIters = null;
    this.cpuStatus = null;
  }

  checkSpike(size, re, im) {
    // Count chaotic pixels in spike region
    const dimsWidth = this.config.dimsWidth;
    const dimsHeight = this.config.dimsHeight;
    const re_double = Array.isArray(re) ? (re[0] + re[1]) : re;
    const im_double = Array.isArray(im) ? (im[0] + im[1]) : im;

    for (let y = 0; y < dimsHeight; y++) {
      const yFrac = (0.5 - y / dimsHeight);
      const ci = im_double + yFrac * (size / this.config.aspectRatio);

      for (let x = 0; x < dimsWidth; x++) {
        const xFrac = (x / dimsWidth - 0.5);
        const cr = re_double + xFrac * size;

        if (this.inspike(cr, ci)) {
          this.ch += 1;
        }
      }
    }
  }

  async initGPU() {
    try {
      // Check WebGPU availability
      if (!navigator.gpu) {
        console.warn('WebGPU not supported');
        return false;
      }

      // Request adapter and device
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        console.warn('No WebGPU adapter found');
        return false;
      }

      // Request device with higher buffer limits if supported
      const requiredLimits = {};
      if (adapter.limits.maxStorageBufferBindingSize > 134217728) {
        // Request higher limit if adapter supports it (default is 128MB)
        requiredLimits.maxStorageBufferBindingSize = adapter.limits.maxStorageBufferBindingSize;
      }
      if (adapter.limits.maxBufferSize > 134217728) {
        requiredLimits.maxBufferSize = adapter.limits.maxBufferSize;
      }

      this.device = await adapter.requestDevice({
        requiredLimits: Object.keys(requiredLimits).length > 0 ? requiredLimits : undefined
      });
      if (!this.device) {
        console.warn('Failed to get WebGPU device');
        return false;
      }

      // Subclass-specific initialization
      await this.createComputePipeline();
      await this.createBuffers();
      this.createBindGroup();

      this.isGPUReady = true;
      return true;

    } catch (error) {
      console.error(`Board ${this.id}: WebGPU initialization failed:`, error.message || error);
      // Check if this is a buffer size error
      if (error.message && error.message.includes('exceeds WebGPU safe limit')) {
        console.warn(`Board ${this.id}: Dimensions too large for GPU (${this.config.dimsWidth}x${this.config.dimsHeight}). This board will NOT compute any pixels!`);
      }
      return false;
    }
  }

  async ensureGPUReady() {
    if (this.gpuInitPromise) {
      await this.gpuInitPromise;
      this.gpuInitPromise = null;
    }
    return this.isGPUReady;
  }

  async iterate() {
    if (!this.isGPUReady) {
      return;
    }
    // Block if already computing (prevents scheduler spin on GPU boards)
    if (this.computePromise) {
      await this.computePromise;
      return;
    }
    this.computePromise = this.compute();
    try {
      await this.computePromise;
    } finally {
      this.computePromise = null;
    }
  }

  async readBuffer(buffer, TypedArrayConstructor) {
    const size = buffer.size;
    const stagingBuffer = this.device.createBuffer({
      size,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
      label: 'Staging buffer'
    });

    const commandEncoder = this.device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(buffer, 0, stagingBuffer, 0, size);
    this.device.queue.submit([commandEncoder.finish()]);

    await stagingBuffer.mapAsync(GPUMapMode.READ);
    const data = new TypedArrayConstructor(stagingBuffer.getMappedRange()).slice();
    stagingBuffer.unmap();
    stagingBuffer.destroy();

    return data;
  }

  unfinished() {
    return this.un;
  }

  static isAvailable() {
    return typeof navigator !== 'undefined' && 'gpu' in navigator;
  }

  static async queryMaxBufferSize() {
    if (GpuBaseBoard.cachedMaxBufferSize !== undefined) {
      return GpuBaseBoard.cachedMaxBufferSize;
    }
    try {
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) return 200 * 1024 * 1024;

      // Request device with higher limits if supported
      const requiredLimits = {};
      if (adapter.limits.maxStorageBufferBindingSize > 134217728) {
        requiredLimits.maxStorageBufferBindingSize = adapter.limits.maxStorageBufferBindingSize;
      }
      if (adapter.limits.maxBufferSize > 134217728) {
        requiredLimits.maxBufferSize = adapter.limits.maxBufferSize;
      }

      const device = await adapter.requestDevice({
        requiredLimits: Object.keys(requiredLimits).length > 0 ? requiredLimits : undefined
      });
      const limit = Math.min(device.limits.maxBufferSize, device.limits.maxStorageBufferBindingSize);
      GpuBaseBoard.cachedMaxBufferSize = Math.floor(limit * 0.9);  // 90% for safety
      return GpuBaseBoard.cachedMaxBufferSize;
    } catch (e) {
      GpuBaseBoard.cachedMaxBufferSize = 200 * 1024 * 1024;
      return GpuBaseBoard.cachedMaxBufferSize;
    }
  }

  static isSafeDims(dimsWidth, dimsHeight, bytesPerPixel = 16, maxBufferSize = 200 * 1024 * 1024) {
    // Check WebGPU buffer size limit (workgroup limit handled by 2D dispatch)
    const dims2 = dimsWidth * dimsHeight;
    const largestBufferSize = dims2 * bytesPerPixel;
    return largestBufferSize <= maxBufferSize;
  }

  static getBoardClass(pixelSize) {
    // Select board type based on zoom level
    // Shallow zooms: GpuBoard (simple float32)
    // Deep zooms: GpuZhuoranBoard (perturbation theory)
    return pixelSize > 1e-6 ? GpuBoard : GpuZhuoranBoard;
  }

  // Abstract methods - subclasses must implement these
  async createComputePipeline() {
    throw new Error('createComputePipeline() must be implemented by subclass');
  }

  async createBuffers() {
    throw new Error('createBuffers() must be implemented by subclass');
  }

  createBindGroup() {
    throw new Error('createBindGroup() must be implemented by subclass');
  }

  async compute() {
    throw new Error('compute() must be implemented by subclass');
  }
}

class GpuBoard extends GpuBaseBoard {
  static BYTES_PER_PIXEL = 8;  // 2x vec2<f32> (zValues or baseValues buffer)

  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);
    this.effort = 1;
    // Epsilon values for convergence detection scale with pixel size
    const pix = size / this.config.dimsWidth;
    // GPU uses float32 precision, so thresholds must be larger than CPU's float64
    this.epsilon = Math.min(1e-7, pix / 10);   // Final convergence threshold
    this.epsilon2 = Math.min(1e-5, pix * 10);  // Getting close threshold
    this.checkSpike(size, re, im);
    // Start GPU initialization (async)
    this.gpuInitPromise = this.initGPU();
  }

  async createComputePipeline() {
    // Mandelbrot shader with period detection for convergence
    const shaderCode = `
      struct Params {
        center_re: f32,
        center_im: f32,
        pixel_size: f32,
        aspect_ratio: f32,
        dims_width: u32,
        dims_height: u32,
        iterations_per_batch: u32,
        active_count: u32,
        epsilon: f32,
        epsilon2: f32,
        exponent: u32,
        workgroups_x: u32,
        start_iter: u32,
        checkpoint_count: u32,
        ckpt0: u32,
        ckpt1: u32,
        ckpt2: u32,
        ckpt3: u32,
        ckpt4: u32,
        ckpt5: u32,
        ckpt6: u32,
        ckpt7: u32,
      }

      @group(0) @binding(0) var<uniform> params: Params;
      @group(0) @binding(1) var<storage, read_write> iterations: array<u32>;
      @group(0) @binding(2) var<storage, read_write> z_values: array<f32>;  // [zr0, zi0, zr1, zi1, ...]
      @group(0) @binding(3) var<storage, read_write> status: array<u32>;    // 0=computing, 1=diverged, 2=converged
      @group(0) @binding(4) var<storage, read> active_pixels: array<u32>;   // Sparse list of active pixel indices
      @group(0) @binding(5) var<storage, read_write> base_values: array<f32>;  // base = checkpoint z for period detection
      @group(0) @binding(6) var<storage, read_write> period: array<u32>;   // p = iter when convergence first detected
      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
        // 2D dispatch: calculate linear index from 2D coordinates
        let active_idx = global_id.y * params.workgroups_x + global_id.x;
        if (active_idx >= params.active_count) {
          return;
        }
        let index = active_pixels[active_idx];
        let x = index % params.dims_width;
        let y = index / params.dims_width;
        // Compute c for this pixel
        let xFrac = (f32(x) / f32(params.dims_width)) - 0.5;
        let yFrac = 0.5 - (f32(y) / f32(params.dims_height));
        let cr = params.center_re + xFrac * params.pixel_size;
        let ci = params.center_im + yFrac * (params.pixel_size / params.aspect_ratio);
        // Continue from current z value
        var zr = z_values[index * 2u];
        var zi = z_values[index * 2u + 1u];
        var iter = iterations[index];
        // Load base values for period detection
        var base_r = base_values[index * 2u];
        var base_i = base_values[index * 2u + 1u];
        var p = period[index];
        // If this is the first batch and base is still zero, initialize it
        if (iter == 0u && base_r == 0.0 && base_i == 0.0) {
          base_r = zr;  // Initialize to starting z (which is 0,0)
          base_i = zi;
        }
        // Track next checkpoint using O(1) counter for adaptive Fibonacci checkpoints
        var next_checkpoint_idx = 0u;
        // Iterate for this batch
        for (var i = 0u; i < params.iterations_per_batch; i++) {
          // Check if this iteration is a Fibonacci checkpoint
          if (next_checkpoint_idx < params.checkpoint_count) {
            var checkpoint_offset = 0u;
            switch (next_checkpoint_idx) {
              case 0u: { checkpoint_offset = params.ckpt0; }
              case 1u: { checkpoint_offset = params.ckpt1; }
              case 2u: { checkpoint_offset = params.ckpt2; }
              case 3u: { checkpoint_offset = params.ckpt3; }
              case 4u: { checkpoint_offset = params.ckpt4; }
              case 5u: { checkpoint_offset = params.ckpt5; }
              case 6u: { checkpoint_offset = params.ckpt6; }
              case 7u: { checkpoint_offset = params.ckpt7; }
              default: {}
            }
            if (i == checkpoint_offset) {
              base_r = zr;
              base_i = zi;
              p = 0u;  // Reset p (period = iter when convergence first detected)
              next_checkpoint_idx++;
            }
          }
          let zr2 = zr * zr;
          let zi2 = zi * zi;
          // Check divergence (escape radius 2, so magnitudeÂ² > 4)
          if (zr2 + zi2 > 4.0) {
            status[index] = 1u;  // Diverged
            break;
          }
          // z = z^exponent + c (generalized Mandelbrot)
          var ra = zr2 - zi2;
          var ja = 2.0 * zr * zi;
          for (var ord = 2u; ord < params.exponent; ord++) {
            let rt = zr * ra - zi * ja;
            ja = zr * ja + zi * ra;
            ra = rt;
          }
          zr = ra + cr;
          zi = ja + ci;
          // Check convergence: compare new z to checkpoint
          let dr = zr - base_r;
          let di = zi - base_i;
          let db = abs(dr) + abs(di);  // distance from checkpoint
          if (db <= params.epsilon2) {
            if (p == 0u) {
              p = iter;  // Record iter when convergence first detected
            }
            if (db <= params.epsilon) {
              status[index] = 2u;  // Converged (periodic)
              break;
            }
          }
          iter++;
        }
        // Save state
        z_values[index * 2u] = zr;
        z_values[index * 2u + 1u] = zi;
        base_values[index * 2u] = base_r;
        base_values[index * 2u + 1u] = base_i;
        iterations[index] = iter;
        period[index] = p;
      }
    `;

    const shaderModule = this.device.createShaderModule({
      code: shaderCode,
      label: 'Mandelbrot compute shader'
    });

    this.pipeline = this.device.createComputePipeline({
      layout: 'auto',
      compute: {
        module: shaderModule,
        entryPoint: 'main'
      },
      label: 'Mandelbrot compute pipeline'
    });
  }

  async createBuffers() {
    const dims2 = this.config.dimsWidth * this.config.dimsHeight;

    // Check buffer size limits before creating (safety margin applied upstream)
    const maxBufferSize = Math.min(
      this.device.limits.maxBufferSize,
      this.device.limits.maxStorageBufferBindingSize
    );
    const largestBufferSize = dims2 * 2 * 4;  // zValues or baseValues buffer (8 bytes/pixel)

    if (largestBufferSize > maxBufferSize) {
      throw new Error(`Buffer size (${(largestBufferSize / (1024 * 1024)).toFixed(1)} MB) exceeds WebGPU limit (${(maxBufferSize / (1024 * 1024)).toFixed(1)} MB). Board ${this.config.dimsWidth}x${this.config.dimsHeight} is too large for GPU acceleration.`);
    }

    // Uniform buffer for shader parameters
    // struct Params { 12 base fields + 8 checkpoint offsets } = 20 u32s = 80 bytes, rounded to 128 for alignment
    this.buffers.params = this.device.createBuffer({
      size: 128,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      label: 'Parameters buffer'
    });

    // Storage buffer for iteration counts (one u32 per pixel)
    this.buffers.iterations = this.device.createBuffer({
      size: dims2 * 4,  // 4 bytes per u32
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Iterations buffer'
    });

    // Storage buffer for z values (two f32 per pixel: zr, zi)
    this.buffers.zValues = this.device.createBuffer({
      size: dims2 * 2 * 4,  // 2 floats per pixel, 4 bytes per float
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Z values buffer'
    });

    // Storage buffer for status flags (one u32 per pixel: 0=computing, 1=diverged)
    this.buffers.status = this.device.createBuffer({
      size: dims2 * 4,  // 4 bytes per u32
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Status buffer'
    });

    // Storage buffer for active pixel indices (sparse list, max size = dims2)
    this.buffers.activePixels = this.device.createBuffer({
      size: dims2 * 4,  // 4 bytes per u32
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      label: 'Active pixels buffer'
    });

    // Storage buffer for base values (period detection)
    this.buffers.baseValues = this.device.createBuffer({
      size: dims2 * 2 * 4,  // 2 floats per pixel
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      label: 'Base values buffer'
    });

    // Storage buffer for period values
    this.buffers.period = this.device.createBuffer({
      size: dims2 * 4,  // 4 bytes per u32
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Period buffer'
    });

    // Persistent staging buffers for reading results back to CPU
    this.buffers.stagingIterations = this.device.createBuffer({
      size: dims2 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      label: 'Staging iterations buffer'
    });

    this.buffers.stagingStatus = this.device.createBuffer({
      size: dims2 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      label: 'Staging status buffer'
    });

    this.buffers.stagingZValues = this.device.createBuffer({
      size: dims2 * 2 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      label: 'Staging z-values buffer'
    });

    this.buffers.stagingPeriod = this.device.createBuffer({
      size: dims2 * 4,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      label: 'Staging period buffer'
    });

    // Initialize all buffers
    const zeroData = new Float32Array(dims2 * 2).fill(0);
    this.device.queue.writeBuffer(this.buffers.zValues, 0, zeroData);
    this.device.queue.writeBuffer(this.buffers.baseValues, 0, zeroData);

    const statusData = new Uint32Array(dims2).fill(0);
    this.device.queue.writeBuffer(this.buffers.status, 0, statusData);

    const iterData = new Uint32Array(dims2).fill(0);
    this.device.queue.writeBuffer(this.buffers.iterations, 0, iterData);

    const periodData = new Uint32Array(dims2).fill(0);
    this.device.queue.writeBuffer(this.buffers.period, 0, periodData);

    // Initialize active pixels list (all pixels start active)
    const activePixels = new Uint32Array(dims2);
    for (let i = 0; i < dims2; i++) {
      activePixels[i] = i;
    }
    this.device.queue.writeBuffer(this.buffers.activePixels, 0, activePixels);
  }

  createBindGroup() {
    // Create bind group with all buffers
    this.bindGroup = this.device.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [
        {
          binding: 0,
          resource: { buffer: this.buffers.params }
        },
        {
          binding: 1,
          resource: { buffer: this.buffers.iterations }
        },
        {
          binding: 2,
          resource: { buffer: this.buffers.zValues }
        },
        {
          binding: 3,
          resource: { buffer: this.buffers.status }
        },
        {
          binding: 4,
          resource: { buffer: this.buffers.activePixels }
        },
        {
          binding: 5,
          resource: { buffer: this.buffers.baseValues }
        },
        {
          binding: 6,
          resource: { buffer: this.buffers.period }
        }
      ],
      label: 'Mandelbrot bind group'
    });
  }

  async compute() {
    // Prevent concurrent compute() calls
    if (this.isComputing) {
      return;
    }
    this.isComputing = true;
    try {
    const dims2 = this.config.dimsWidth * this.config.dimsHeight;
    const workgroupSize = 64;

    // Prepare parameters for GPU
    const re_double = Array.isArray(this.re) ? (this.re[0] + this.re[1]) : this.re;
    const im_double = Array.isArray(this.im) ? (this.im[0] + this.im[1]) : this.im;
    const pixel_size = this.size;

    // Initialize CPU-side status tracking if needed
    if (!this.cpuStatus) {
      this.cpuStatus = new Uint32Array(dims2).fill(0);  // 0 = computing
    }

    // Build sparse active pixel list (only pixels still computing)
    const activePixels = [];
    for (let i = 0; i < dims2; i++) {
      if (this.cpuStatus[i] === 0) {
        activePixels.push(i);
      }
    }

    const activeCount = activePixels.length;

    if (activeCount === 0) {
      this.un = 0;
      return;
    }

    // Dynamic batch sizing: scale iterations inversely with active pixels
    const targetWork = 333337;  // Prime, reduced for better responsiveness
    let iterationsPerBatch = Math.floor(targetWork / Math.max(activeCount, 1));
    // Clamp to reasonable bounds (min 17)
    iterationsPerBatch = Math.max(17, iterationsPerBatch);

    // Update effort for scheduler (reflects actual iterations per call)
    this.effort = iterationsPerBatch;

    // Upload active pixel list to GPU
    const activePixelsData = new Uint32Array(activePixels);
    this.device.queue.writeBuffer(this.buffers.activePixels, 0, activePixelsData);

    // 2D workgroup dispatch
    const numWorkgroups = Math.ceil(activeCount / workgroupSize);
    const workgroupsX = Math.ceil(Math.sqrt(numWorkgroups));
    const workgroupsY = Math.ceil(numWorkgroups / workgroupsX);

    // Precompute Fibonacci checkpoint offsets for this batch
    const checkpointOffsets = [];
    const bufferIter = this.it;
    for (let i = 0; i < iterationsPerBatch; i++) {
      const globalIter = bufferIter + i;
      if (fibonacciPeriod(globalIter) === 1) {
        checkpointOffsets.push(i);
      }
    }
    const checkpointCount = Math.min(checkpointOffsets.length, 8);

    // Upload parameters to uniform buffer (21 u32s with checkpoint fields + aspect ratio)
    const paramsBuffer = new ArrayBuffer(128);  // Extended to accommodate new fields
    const paramsF32 = new Float32Array(paramsBuffer);
    const paramsU32 = new Uint32Array(paramsBuffer);

    paramsF32[0] = re_double;
    paramsF32[1] = im_double;
    paramsF32[2] = pixel_size;
    paramsF32[3] = this.config.aspectRatio;
    paramsU32[4] = this.config.dimsWidth;
    paramsU32[5] = this.config.dimsHeight;
    paramsU32[6] = iterationsPerBatch;
    paramsU32[7] = activeCount;
    paramsF32[8] = this.epsilon;
    paramsF32[9] = this.epsilon2;
    paramsU32[10] = this.config.exponent;
    paramsU32[11] = workgroupsX * workgroupSize;  // Total threads in X dimension
    paramsU32[12] = bufferIter;  // Starting iteration
    paramsU32[13] = checkpointCount;  // Number of checkpoints in this batch

    // Pack all 8 checkpoint offsets (fill unused slots with 0)
    for (let i = 0; i < 8; i++) {
      paramsU32[14 + i] = i < checkpointCount ? checkpointOffsets[i] : 0;
    }

    this.device.queue.writeBuffer(this.buffers.params, 0, paramsBuffer);

    // Create command encoder
    const commandEncoder = this.device.createCommandEncoder({
      label: 'Mandelbrot compute encoder'
    });

    // Compute pass
    const passEncoder = commandEncoder.beginComputePass({
      label: 'Mandelbrot compute pass'
    });

    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, this.bindGroup);
    passEncoder.dispatchWorkgroups(workgroupsX, workgroupsY);  // 2D dispatch
    passEncoder.end();

    // Batch all buffer copies into single command encoder for efficiency
    commandEncoder.copyBufferToBuffer(this.buffers.iterations, 0, this.buffers.stagingIterations, 0, dims2 * 4);
    commandEncoder.copyBufferToBuffer(this.buffers.status, 0, this.buffers.stagingStatus, 0, dims2 * 4);

    // Submit compute + buffer copies in single batch
    this.device.queue.submit([commandEncoder.finish()]);
    await this.device.queue.onSubmittedWorkDone();

    // Update iteration counter (before processing results, like CPU implementations)
    this.it += iterationsPerBatch;

    // First pass: read lightweight buffers (iterations and status)
    await this.buffers.stagingIterations.mapAsync(GPUMapMode.READ);
    const iterationsData = new Uint32Array(this.buffers.stagingIterations.getMappedRange()).slice();
    this.buffers.stagingIterations.unmap();

    await this.buffers.stagingStatus.mapAsync(GPUMapMode.READ);
    const statusData = new Uint32Array(this.buffers.stagingStatus.getMappedRange()).slice();
    this.buffers.stagingStatus.unmap();

    // Initialize lastReportedIters if needed
    if (!this.lastReportedIters) {
      this.lastReportedIters = new Uint32Array(dims2).fill(0);
    }

    // Find pixels that NEWLY diverged or converged this batch
    const pixelsByIteration = new Map(); // For diverged: iter -> [indices]
    const convergedByIteration = new Map(); // For converged: iter -> [{index, z, p}]
    let newlyDiverged = 0;
    let newlyConverged = 0;
    let hasConverged = false;

    // First pass: process diverged pixels and detect if any converged
    for (const i of activePixels) {
      const iters = iterationsData[i];
      const status = statusData[i];
      const lastIters = this.lastReportedIters[i];

      // Update CPU-side status tracking
      this.cpuStatus[i] = status;

      if (status === 1) {
        // Diverged - newly diverged in this batch?
        if (lastIters === 0 || iters !== lastIters) {
          this.nn[i] = iters;
          this.pp[i] = 1;

          if (!pixelsByIteration.has(iters)) {
            pixelsByIteration.set(iters, []);
          }
          pixelsByIteration.get(iters).push(i);
          this.lastReportedIters[i] = iters;
          newlyDiverged++;
        }
      } else if (status === 2) {
        // Converged - mark that we need to read heavy buffers
        hasConverged = true;
      }
    }

    // Second pass: only read heavy buffers if we have converged pixels
    if (hasConverged) {
      // Create a new command encoder for heavy buffer readback
      const heavyEncoder = this.device.createCommandEncoder();
      heavyEncoder.copyBufferToBuffer(this.buffers.zValues, 0, this.buffers.stagingZValues, 0, dims2 * 2 * 4);
      heavyEncoder.copyBufferToBuffer(this.buffers.period, 0, this.buffers.stagingPeriod, 0, dims2 * 4);
      this.device.queue.submit([heavyEncoder.finish()]);
      await this.device.queue.onSubmittedWorkDone();

      await this.buffers.stagingZValues.mapAsync(GPUMapMode.READ);
      const zValuesData = new Float32Array(this.buffers.stagingZValues.getMappedRange()).slice();
      this.buffers.stagingZValues.unmap();

      await this.buffers.stagingPeriod.mapAsync(GPUMapMode.READ);
      const periodData = new Uint32Array(this.buffers.stagingPeriod.getMappedRange()).slice();
      this.buffers.stagingPeriod.unmap();

      // Process converged pixels
      for (const i of activePixels) {
        const iters = iterationsData[i];
        const status = statusData[i];
        const lastIters = this.lastReportedIters[i];

        if (status === 2 && (lastIters === 0 || iters !== lastIters)) {
          this.nn[i] = -iters;  // Negative iteration for converged pixels

          const zr = zValuesData[i * 2];
          const zi = zValuesData[i * 2 + 1];
          const period = periodData[i];

          // Add 1 because GPU shader increments iter before setting checkpoint,
          // so period value is 1 less than what CPU board would store
          this.pp[i] = period + 1;

          if (!convergedByIteration.has(iters)) {
            convergedByIteration.set(iters, []);
          }
          convergedByIteration.get(iters).push({
            index: i,
            z: [zr, 0, zi, 0],
            p: this.pp[i]
          });
          this.lastReportedIters[i] = iters;
          newlyConverged++;
        }
      }
    }

    // Count total finished pixels across entire grid (for statistics)
    let totalDiverged = 0;
    let totalConverged = 0;
    let stillComputing = 0;
    for (let i = 0; i < dims2; i++) {
      const status = this.cpuStatus[i];
      if (status === 1) totalDiverged++;
      else if (status === 2) totalConverged++;
      else stillComputing++;
    }

    // Create change objects for newly diverged and converged pixels
    const allIterations = new Set([...pixelsByIteration.keys(), ...convergedByIteration.keys()]);
    const sortedIterations = Array.from(allIterations).sort((a, b) => a - b);
    let totalChanges = 0;

    for (const iter of sortedIterations) {
      const divergedIndices = pixelsByIteration.get(iter) || [];
      const convergedData = convergedByIteration.get(iter) || [];

      this.changeList.push({
        iter: iter,
        nn: divergedIndices,
        vv: convergedData
      });
      totalChanges += divergedIndices.length + convergedData.length;
    }

    // Update board statistics
    this.di = totalDiverged;
    this.un = stillComputing;
    this.updateSize = totalChanges;

    } catch (error) {
      console.error(`GpuBoard.compute() ERROR:`, error);
    } finally {
      this.isComputing = false;
    }
  }

  static fromSerialized(serialized) {
    return new GpuBoard(
      serialized.k,
      serialized.sizes[0],
      serialized.sizes[1],
      serialized.sizes[2],
      serialized.config,
      serialized.id
    );
  }
}

// WebGPU-accelerated perturbation board using Zhuoran's approach
// Computes high-precision reference orbit on CPU, perturbations on GPU
class GpuZhuoranBoard extends GpuBaseBoard {
  static BYTES_PER_PIXEL = 16;  // 4x f32 (dzAndCheckpoint buffer)

  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);

    this.effort = 2;  // Same as ZhuoranBoard

    // Reference orbit for perturbation theory (computed on CPU in quad-double)
    this.refOrbit = [];  // Array of [r_high, r_low, i_high, i_low]
    this.refOrbitEscaped = false;
    this.refIterations = 0;
    this.maxRefIterations = 10000;

    // Reference point (center of image)
    const refRe = Array.isArray(re) ? re : toQd(re);
    const refIm = Array.isArray(im) ? im : toQd(im);
    this.refC = [refRe[0], refRe[1], refIm[0], refIm[1]];

    // Initialize reference orbit: iteration 0 is z=0, iteration 1 is z=c
    this.refOrbit.push([0, 0, 0, 0]);
    this.refOrbit.push(this.refC.slice());
    this.refIterations = 1;

    // Working array for quad-double operations
    this.tt = new Array(16);

    // Threading for robust cycle detection
    this.threading = new ReferenceOrbitThreading(this.epsilon);
    this.threading.refThreading.push({next: -1, deltaRe: 0, deltaIm: 0});  // iter 0
    this.threading.refThreading.push({next: -1, deltaRe: 0, deltaIm: 0});  // iter 1

    // Initialize per-pixel perturbation data
    this.initPixels(size, re, im);

    // Start GPU initialization (async)
    this.gpuInitPromise = this.initGPU();
  }

  initPixels(size, re, im) {
    const dimsWidth = this.config.dimsWidth;
    const dimsHeight = this.config.dimsHeight;
    const dims2 = this.config.dims2;

    // Convert re/im to quad-double if needed
    const re_qd = Array.isArray(re) ? re : toQd(re);
    const im_qd = Array.isArray(im) ? im : toQd(im);
    const size_qd = toQd(size);
    const sizeY_qd = toQd(size / this.config.aspectRatio);

    // Per-pixel data arrays
    this.dc = new Float32Array(dims2 * 2);  // Delta c from reference [real, imag] pairs
    this.dz = new Float32Array(dims2 * 2);  // Current perturbation delta [real, imag] pairs
    this.refIter = new Uint32Array(dims2);  // Which iteration of reference each pixel is following

    // Working arrays for quad-double arithmetic
    const cr_qd = new Array(4);
    const ci_qd = new Array(4);
    const dcr_qd = new Array(4);
    const dci_qd = new Array(4);
    const temp = new Array(4);

    // Initialize all pixels as perturbations from the reference point
    for (let y = 0; y < dimsHeight; y++) {
      const yFrac = (0.5 - y / dimsHeight);

      // ci_qd = im_qd + yFrac * sizeY_qd (in quad-double)
      AqdMul(temp, 0, toQd(yFrac)[0], toQd(yFrac)[1], sizeY_qd[0], sizeY_qd[1]);
      AqdAdd(ci_qd, 0, im_qd[0], im_qd[1], temp[0], temp[1]);

      // dci_qd = ci_qd - refC_imag
      AqdAdd(dci_qd, 0, ci_qd[0], ci_qd[1], -this.refC[2], -this.refC[3]);

      for (let x = 0; x < dimsWidth; x++) {
        const xFrac = (x / dimsWidth - 0.5);

        // cr_qd = re_qd + xFrac * size_qd (in quad-double)
        AqdMul(temp, 0, toQd(xFrac)[0], toQd(xFrac)[1], size_qd[0], size_qd[1]);
        AqdAdd(cr_qd, 0, re_qd[0], re_qd[1], temp[0], temp[1]);

        // dcr_qd = cr_qd - refC_real
        AqdAdd(dcr_qd, 0, cr_qd[0], cr_qd[1], -this.refC[0], -this.refC[1]);

        const index = y * dimsWidth + x;
        const index2 = index * 2;

        // Convert quad-double deltas to float32
        // TESTING: Use Math.fround to simulate float32 precision like GPU
        this.dc[index2] = Math.fround(dcr_qd[0] + dcr_qd[1]);
        this.dc[index2 + 1] = Math.fround(dci_qd[0] + dci_qd[1]);

        // Start with dz = dc (so z = c_ref + dc = c)
        this.dz[index2] = this.dc[index2];
        this.dz[index2 + 1] = this.dc[index2 + 1];

        // Start at iteration 1 (where refOrbit[1] = c_ref)
        this.refIter[index] = 1;
      }
    }

    this.checkSpike(size, re, im);
  }

  async createBuffers() {
    const dims2 = this.config.dimsWidth * this.config.dimsHeight;

    // Check buffer size limits before creating (safety margin applied upstream)
    const maxBufferSize = Math.min(
      this.device.limits.maxBufferSize,
      this.device.limits.maxStorageBufferBindingSize
    );
    const largestBufferSize = dims2 * 4 * 4;  // dzAndCheckpoint buffer (16 bytes/pixel)

    if (largestBufferSize > maxBufferSize) {
      throw new Error(`Buffer size (${(largestBufferSize / (1024 * 1024)).toFixed(1)} MB) exceeds WebGPU limit (${(maxBufferSize / (1024 * 1024)).toFixed(1)} MB). Board ${this.config.dimsWidth}x${this.config.dimsHeight} is too large for GPU acceleration.`);
    }

    // Storage buffer for iteration counts
    this.buffers.iterations = this.device.createBuffer({
      size: dims2 * 4,  // 4 bytes per u32
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Iterations buffer'
    });

    // Storage buffer for status and period (packed: 2 u32 per pixel)
    this.buffers.statusAndPeriod = this.device.createBuffer({
      size: dims2 * 2 * 4,  // 2 u32 per pixel
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
      label: 'Status and period buffer'
    });

    // Storage buffer for dc (delta c - constant offsets)
    this.buffers.dc = this.device.createBuffer({
      size: dims2 * 2 * 4,  // 2 f32 per pixel
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      label: 'Delta C buffer'
    });

    // Storage buffer for dz, checkpoint bb, and threading deltas (packed: 6 f32 per pixel)
    this.buffers.dzAndCheckpoint = this.device.createBuffer({
      size: dims2 * 6 * 4,  // 6 f32 per pixel: dz.x, dz.y, bb.x, bb.y, threaded_delta_re, threaded_delta_im
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'DZ and checkpoint buffer'
    });

    // Storage buffer for refIter, checkpointIter, and next_threaded_ref_iter (3 u32 per pixel)
    this.buffers.refIterAndCheckpoint = this.device.createBuffer({
      size: dims2 * 3 * 4,  // 3 u32 per pixel: [ref_iter, checkpoint_iter, next_threaded_ref_iter]
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'RefIter and checkpoint buffer'
    });

    // Storage buffer for reference orbit (orbit data only: 2 floats per iter)
    // Start with reasonable size, will recreate if needed
    this.buffers.refOrbit = this.device.createBuffer({
      size: Math.max(this.maxRefIterations * 2 * 4, 1024),
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      label: 'Reference orbit buffer'
    });

    // Storage buffer for threading data (4 floats per iter: next, deltaRe, deltaIm, pad)
    // Start with 1MB, will grow by doubling up to 128MB cap
    this.buffers.threading = this.device.createBuffer({
      size: 1 * 1024 * 1024,  // Start at 1MB
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      label: 'Threading buffer'
    });

    // Track last uploaded lengths for incremental uploads
    this.lastUploadedOrbitLength = -1;  // -1 means nothing uploaded yet
    this.lastUploadedThreadingLength = -1;

    // Uniform buffer for parameters
    this.buffers.params = this.device.createBuffer({
      size: 128,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      label: 'Params buffer'
    });

    // Initialize buffers with packed data
    // dzAndCheckpoint: [dz.x, dz.y, bb.x=0, bb.y=0, threaded_delta_re=0, threaded_delta_im=0] per pixel
    const dzAndCheckpointData = new Float32Array(dims2 * 6);
    for (let i = 0; i < dims2; i++) {
      dzAndCheckpointData[i * 6] = this.dz[i * 2];      // dz.x
      dzAndCheckpointData[i * 6 + 1] = this.dz[i * 2 + 1];  // dz.y
      dzAndCheckpointData[i * 6 + 2] = 0;  // bb.x
      dzAndCheckpointData[i * 6 + 3] = 0;  // bb.y
      dzAndCheckpointData[i * 6 + 4] = 0;  // threaded_delta_re
      dzAndCheckpointData[i * 6 + 5] = 0;  // threaded_delta_im
    }

    // Initialize refIterAndCheckpoint: [ref_iter, checkpoint_iter, next_threaded_ref_iter] per pixel
    const refIterAndCheckpointData = new Uint32Array(dims2 * 3);
    for (let i = 0; i < dims2; i++) {
      refIterAndCheckpointData[i * 3] = this.refIter[i];  // ref_iter
      refIterAndCheckpointData[i * 3 + 1] = 0xFFFFFFFF;  // checkpoint_iter: use sentinel for "no checkpoint yet"
      refIterAndCheckpointData[i * 3 + 2] = 0xFFFFFFFF;  // next_threaded_ref_iter: sentinel for "no thread yet"
    }

    // Initialize orbit buffer with initial reference orbit (iter 0 and 1)
    const initialOrbitData = new Float32Array(4);  // 2 iters * 2 floats
    initialOrbitData[0] = 0;  // iter 0: re = 0
    initialOrbitData[1] = 0;  // iter 0: im = 0
    initialOrbitData[2] = this.refC[0] + this.refC[1];  // iter 1: re = c_ref
    initialOrbitData[3] = this.refC[2] + this.refC[3];  // iter 1: im = c_ref

    // Initialize threading buffer with initial threading data (iter 0 and 1, no threads)
    const initialThreadingData = new Float32Array(8);  // 2 iters * 4 floats
    initialThreadingData[0] = -1;  // iter 0: next = -1 (no thread)
    initialThreadingData[4] = -1;  // iter 1: next = -1 (no thread)

    this.device.queue.writeBuffer(this.buffers.dc, 0, this.dc);
    this.device.queue.writeBuffer(this.buffers.dzAndCheckpoint, 0, dzAndCheckpointData);
    this.device.queue.writeBuffer(this.buffers.refIterAndCheckpoint, 0, refIterAndCheckpointData);
    this.device.queue.writeBuffer(this.buffers.refOrbit, 0, initialOrbitData);
    this.device.queue.writeBuffer(this.buffers.threading, 0, initialThreadingData);

    // Initialize iterations buffer to 1 (z=c is iteration 1, not 0)
    const iterData = new Uint32Array(dims2).fill(1);
    this.device.queue.writeBuffer(this.buffers.iterations, 0, iterData);

    // Mark initial data as uploaded
    this.lastUploadedOrbitLength = 1;  // Uploaded iters 0 and 1
    this.lastUploadedThreadingLength = 1;
  }

  createBindGroup() {
    this.bindGroup = this.device.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: this.buffers.params } },
        { binding: 1, resource: { buffer: this.buffers.iterations } },
        { binding: 2, resource: { buffer: this.buffers.statusAndPeriod } },
        { binding: 3, resource: { buffer: this.buffers.dc } },
        { binding: 4, resource: { buffer: this.buffers.dzAndCheckpoint } },
        { binding: 5, resource: { buffer: this.buffers.refIterAndCheckpoint } },
        { binding: 6, resource: { buffer: this.buffers.refOrbit } },
        { binding: 7, resource: { buffer: this.buffers.threading } }
      ],
      label: 'Perturbation bind group'
    });
  }

  // Copy extendReferenceOrbit from ZhuoranBoard
  extendReferenceOrbit() {
    // Compute one more iteration of the reference orbit in quad-double precision
    const lastIndex = this.refIterations;
    const last = this.refOrbit[lastIndex];
    const tt = this.tt;

    const r1 = last[0];
    const r2 = last[1];
    const j1 = last[2];
    const j2 = last[3];

    // Check for escape
    AqdSquare(tt, 0, r1, r2);                    // rsq = r**2
    AqdSquare(tt, 2, j1, j2);                    // jsq = j**2
    AqdAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);   // d = rsq + jsq

    // Use very large escape radius for reference orbit
    if (tt[4] > 1e10) {
      this.refOrbitEscaped = true;
      return;
    }

    // Compute z^exponent using quad-double
    AqdSet(tt, 8, r1, r2);  // ra = r
    AqdSet(tt, 6, j1, j2);  // ja = j
    for (let ex = 1; ex < this.config.exponent; ex++) {
      AqdMul(tt, 0, j1, j2, tt[6], tt[7]);         // j * ja
      AqdMul(tt, 2, r1, r2, tt[8], tt[9]);         // r * ra
      AqdAdd(tt, 4, -tt[0], -tt[1], tt[2], tt[3]); // rt = r*ra - j*ja
      AqdMul(tt, 0, r1, r2, tt[6], tt[7]);         // r * ja
      AqdMul(tt, 2, j1, j2, tt[8], tt[9]);         // j * ra
      AqdAdd(tt, 6, tt[0], tt[1], tt[2], tt[3]);   // ja = r*ja + j*ra
      AqdSet(tt, 8, tt[4], tt[5]);                 // ra = rt
    }

    // Add c to get next z
    const newZ = [0, 0, 0, 0];
    AqdAdd(newZ, 0, tt[8], tt[9], this.refC[0], this.refC[1]);      // real part
    AqdAdd(newZ, 2, tt[6], tt[7], this.refC[2], this.refC[3]);      // imag part

    this.refOrbit.push(newZ);
    this.refIterations++;

    // Threading: add new orbit point
    // Start threading at F(18) = 2584 and continue forever
    if (this.refIterations >= 2584) {
      const re = newZ[0] + newZ[1];
      const im = newZ[2] + newZ[3];
      const getPoint = (i) => {
        if (i < 0 || i >= this.refOrbit.length) return null;
        const p = this.refOrbit[i];
        return { re: p[0] + p[1], im: p[2] + p[3] };
      };
      this.threading.addOrbitPoint(this.refIterations, re, im, getPoint);
    }

    // Grow array if needed
    if (this.refIterations >= this.maxRefIterations) {
      this.maxRefIterations *= 2;
    }
  }

  setupReferenceOrbitLoop() {
    // When reference orbit hits threading limit, find a close point to loop back to
    const THREADING_CAPACITY = 4194304;  // 2^22
    const SEARCH_WINDOW = 10000;

    if (this.refIterations < THREADING_CAPACITY || this.refOrbitLoopConfigured) {
      return; // Not at limit yet, or already configured
    }

    // Get endpoint (current position at threading limit)
    const endpoint = this.refOrbit[THREADING_CAPACITY];
    const endR = endpoint[0] + endpoint[1];
    const endI = endpoint[2] + endpoint[3];

    // Search back to find closest point
    let closestIter = THREADING_CAPACITY - SEARCH_WINDOW;
    let closestDist = Infinity;

    for (let i = THREADING_CAPACITY - SEARCH_WINDOW; i < THREADING_CAPACITY; i++) {
      const pt = this.refOrbit[i];
      const ptR = pt[0] + pt[1];
      const ptI = pt[2] + pt[3];
      const dr = endR - ptR;
      const di = endI - ptI;
      const dist = Math.max(Math.abs(dr), Math.abs(di)); // Chebyshev distance

      if (dist <= closestDist) {  // Use <= to take latest point when tied
        closestDist = dist;
        closestIter = i;
      }
    }

    // Compute delta in quad-double precision
    const closestPt = this.refOrbit[closestIter];
    const tt = this.tt;
    AqdAdd(tt, 0, endpoint[0], endpoint[1], -closestPt[0], -closestPt[1]); // real delta
    AqdAdd(tt, 2, endpoint[2], endpoint[3], -closestPt[2], -closestPt[3]); // imag delta

    // Store loop parameters
    this.refOrbitLoop = {
      enabled: true,
      threshold: THREADING_CAPACITY,
      jumpAmount: THREADING_CAPACITY - closestIter,
      deltaR: tt[0] + tt[1], // Convert to float64
      deltaI: tt[2] + tt[3]
    };

    this.refOrbitLoopConfigured = true;

    // Update threading for loop segment to wrap around
    const loopDeltaR = this.refOrbitLoop.deltaR;
    const loopDeltaI = this.refOrbitLoop.deltaI;
    const epsilon3 = this.threading.epsilon3;

    // For each iteration in the loop segment, check if it can thread to another iteration
    // considering the loop wrap (iterations will repeat with a delta offset)
    for (let i = closestIter; i <= THREADING_CAPACITY; i++) {
      const iPt = this.refOrbit[i];
      const iR = iPt[0] + iPt[1];
      const iI = iPt[2] + iPt[3];

      // Check if we can thread to same or later iteration (considering it will wrap with delta)
      // Allow j = i for self-threading within the loop (period-N orbits repeat with delta)
      for (let j = i; j <= THREADING_CAPACITY; j++) {
        const jPt = this.refOrbit[j];
        // After loop, iteration j will be at position refOrbit[j] + loop_delta
        const jR = jPt[0] + jPt[1] + loopDeltaR;
        const jI = jPt[2] + jPt[3] + loopDeltaI;

        const dr = iR - jR;
        const di = iI - jI;
        const dist = Math.max(Math.abs(dr), Math.abs(di));

        if (dist <= epsilon3) {
          // Thread i -> j (wrapping through the loop)
          this.threading.refThreading[i] = {
            next: j,
            deltaRe: Math.fround(jR - iR),
            deltaIm: Math.fround(jI - iI)
          };
          break;  // Take first match
        }
      }
    }
  }

  async createComputePipeline() {
    const shaderCode = `
      struct Params {
        dims_width: u32,
        dims_height: u32,
        iterations_per_batch: u32,
        active_count: u32,
        ref_orbit_length: u32,
        exponent: u32,
        workgroups_x: u32,
        start_iter: u32,
        checkpoint_count: u32,
        ckpt0: u32,
        ckpt1: u32,
        ckpt2: u32,
        ckpt3: u32,
        ckpt4: u32,
        ckpt5: u32,
        ckpt6: u32,
        ckpt7: u32,
        loop_enabled: u32,      // 1 if loop enabled, 0 otherwise
        loop_threshold: u32,    // ref_iter threshold to trigger loop
        loop_jump: u32,         // Amount to subtract from ref_iter
        _padding: u32,          // Alignment padding
        pixel_size: f32,
        aspect_ratio: f32,
        loop_delta_r: f32,      // Delta to add to dzr
        loop_delta_i: f32,      // Delta to add to dzi
      }

      @group(0) @binding(0) var<uniform> params: Params;
      @group(0) @binding(1) var<storage, read_write> iterations: array<u32>;
      @group(0) @binding(2) var<storage, read_write> statusAndPeriod: array<vec2<u32>>;  // [status, pp]
      @group(0) @binding(3) var<storage, read> dc: array<f32>;              // Delta c (constant)
      // Note: Using array<f32> for 6-float structure to avoid padding issues
      // Layout: [dz.x, dz.y, bb.x, bb.y, threaded_delta_re, threaded_delta_im] per pixel
      @group(0) @binding(4) var<storage, read_write> dzAndCheckpoint: array<f32>;
      // Layout: [ref_iter, checkpoint_iter, next_threaded_ref_iter] per pixel (stride 3)
      @group(0) @binding(5) var<storage, read_write> refIterAndCheckpoint: array<u32>;
      @group(0) @binding(6) var<storage, read> refOrbit: array<f32>;  // Reference orbit [r,i pairs] only
      @group(0) @binding(7) var<storage, read> threading: array<vec4<f32>>;  // Threading [next, deltaR, deltaI, pad]

      // Get threading data from separate threading buffer
      // Returns vec3: [next_index_as_f32, deltaRe, deltaIm]
      fn getThread(idx: u32) -> vec3<f32> {
        if (idx >= params.ref_orbit_length) { return vec3<f32>(-1.0, 0.0, 0.0); }
        let thread_data = threading[idx];
        return vec3<f32>(thread_data.x, thread_data.y, thread_data.z);
      }

      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
        // 2D dispatch: calculate linear index from 2D coordinates
        let index = global_id.y * params.workgroups_x + global_id.x;
        let dims2 = params.dims_width * params.dims_height;
        if (index >= dims2) { return; }

        // Skip if already finished
        let status_val = statusAndPeriod[index].x;
        if (status_val != 0u) { return; }

        let index2 = index * 2u;
        let index6 = index * 6u;  // For dzAndCheckpoint (6 floats per pixel)
        let index3 = index * 3u;  // For refIterAndCheckpoint (3 u32s per pixel)

        // Load iteration counter (initialized to 1 to match CpuBoard semantics)
        var iter = iterations[index];
        // Unpack: dz = perturbation delta, bb = checkpoint dz, threading deltas
        var dzr = dzAndCheckpoint[index6];
        var dzi = dzAndCheckpoint[index6 + 1u];
        var bbr = dzAndCheckpoint[index6 + 2u];  // checkpoint dz real
        var bbi = dzAndCheckpoint[index6 + 3u];  // checkpoint dz imag
        var threaded_delta_re = dzAndCheckpoint[index6 + 4u];
        var threaded_delta_im = dzAndCheckpoint[index6 + 5u];
        var ref_iter = refIterAndCheckpoint[index3];
        let dcr = dc[index2];
        let dci = dc[index2 + 1u];
        var ckpt_iter = refIterAndCheckpoint[index3 + 1u];  // ref_iter when checkpoint was saved
        var next_threaded_ref_iter = refIterAndCheckpoint[index3 + 2u];  // Next threaded position
        var pp = statusAndPeriod[index].y;     // period = iter when convergence first detected
        // Convergence thresholds scale with pixel size for deep zooms
        // GPU uses float32 precision, so thresholds must be larger than CPU's float64
        let epsilon = min(1e-7, params.pixel_size / 10.0);   // Final convergence threshold
        let epsilon2 = min(1e-5, params.pixel_size * 10.0);  // Getting close threshold

        // Track next checkpoint using O(1) counter for adaptive checkpoints
        var next_checkpoint_idx = 0u;

        // Iterate for the batch
        for (var batch_iter = 0u; batch_iter < params.iterations_per_batch; batch_iter++) {
          // Early exit if pixel already finished (converged/diverged)
          if (statusAndPeriod[index].x != 0u) {
            break;
          }

          // BUG FIX: Check rebasing BEFORE loading reference orbit (matches CPU ZhuoranBoard)
          // The old code loaded refr/refi first, then rebased, then used stale refr/refi
          let dz_norm = max(abs(dzr), abs(dzi));

          // Peek at reference orbit to check rebasing condition
          let ref_offset_check = ref_iter * 2u;
          if (ref_offset_check + 1u < params.ref_orbit_length * 2u) {
            let refr_check = refOrbit[ref_offset_check];
            let refi_check = refOrbit[ref_offset_check + 1u];
            let total_r_pre = refr_check + dzr;
            let total_i_pre = refi_check + dzi;
            let total_norm = max(abs(total_r_pre), abs(total_i_pre));

            // Rebase when orbit approaches critical point
            if (ref_iter > 0u && total_norm < dz_norm * 2.0) {
              dzr = total_r_pre;  // Set dz = z_total (absolute position)
              dzi = total_i_pre;
              ref_iter = 0u;  // Restart from beginning of reference orbit

              // NOTE: We do NOT modify the checkpoint here
              // The difference-based comparison works across rebases:
              // z_current - z_checkpoint = [ref[0] - ref[ckpt_ref_iter]] + [dz_absolute - dz_ckpt]
            }
          }

          // NOW load reference orbit values for current (possibly rebased) ref_iter
          let ref_offset = ref_iter * 2u;
          if (ref_offset + 1u >= params.ref_orbit_length * 2u) {
            break;  // Reference orbit too short
          }
          var refr = refOrbit[ref_offset];
          var refi = refOrbit[ref_offset + 1u];

          // Check current z for divergence
          let curr_total_r = refr + dzr;
          let curr_total_i = refi + dzi;
          let curr_mag_sq = curr_total_r * curr_total_r + curr_total_i * curr_total_i;
          if (curr_mag_sq > 4.0) {
            statusAndPeriod[index] = vec2<u32>(1u, pp);
            break;
          }

          // Save dz before iteration (for checkpoint timing)
          let old_dzr = dzr;
          let old_dzi = dzi;
          let old_ref_iter = ref_iter;

          // Perturbation iteration using binomial expansion (Horner's method)
          // (z_ref+dz)^n - z_ref^n = sum(k=1 to n) C(n,k) * z_ref^(n-k) * dz^k
          // Computed as: dz * (C(n,1)*z_ref^(n-1) + dz * (C(n,2)*z_ref^(n-2) + ...))

          // Build binomial powers: coeff * z_ref^power for each term
          var z_pow_r = refr;
          var z_pow_i = refi;
          var coeff = f32(params.exponent);

          // Start Horner's method with innermost term
          var result_r = dzr;
          var result_i = dzi;

          // Horner's method: accumulate terms from highest to lowest power of z_ref
          for (var k = 1u; k < params.exponent; k++) {
            // Add coeff * z_ref^power term
            let term_r = coeff * z_pow_r;
            let term_i = coeff * z_pow_i;
            result_r = result_r + term_r;
            result_i = result_i + term_i;

            // Multiply by dz (complex multiplication)
            let temp_r = result_r * dzr - result_i * dzi;
            result_i = result_r * dzi + result_i * dzr;
            result_r = temp_r;

            // Update z_ref power: z_pow = z_pow * z_ref
            let new_z_pow_r = z_pow_r * refr - z_pow_i * refi;
            z_pow_i = z_pow_r * refi + z_pow_i * refr;
            z_pow_r = new_z_pow_r;

            // Update coefficient: coeff *= (n-k) / (k+1)
            coeff *= f32(params.exponent - k) / f32(k + 1u);
          }

          // Add perturbation in c
          dzr = result_r + dcr;
          dzi = result_i + dci;

          // Check if reference orbit is long enough for next iteration
          let next_ref_check = (ref_iter + 1u) * 2u;
          if (next_ref_check + 1u >= params.ref_orbit_length * 2u) {
            break;
          }

          // CONVERGENCE DETECTION: Check if this iteration is a checkpoint
          var just_updated = false;
          if (next_checkpoint_idx < params.checkpoint_count) {
            // Get the offset for the next checkpoint based on index
            var checkpoint_offset = 0u;
            switch (next_checkpoint_idx) {
              case 0u: { checkpoint_offset = params.ckpt0; }
              case 1u: { checkpoint_offset = params.ckpt1; }
              case 2u: { checkpoint_offset = params.ckpt2; }
              case 3u: { checkpoint_offset = params.ckpt3; }
              case 4u: { checkpoint_offset = params.ckpt4; }
              case 5u: { checkpoint_offset = params.ckpt5; }
              case 6u: { checkpoint_offset = params.ckpt6; }
              case 7u: { checkpoint_offset = params.ckpt7; }
              default: {}
            }

            // Check if current batch_iter matches this checkpoint
            if (batch_iter == checkpoint_offset) {
              just_updated = true;
              bbr = old_dzr;  // dz real at checkpoint (BEFORE iteration)
              bbi = old_dzi;  // dz imag at checkpoint
              ckpt_iter = old_ref_iter;  // Store reference iteration
              pp = 0u;
              next_checkpoint_idx++;  // Move to next checkpoint

              // Initialize threading: reset deltas at checkpoint and follow ONE thread
              threaded_delta_re = 0.0;
              threaded_delta_im = 0.0;
              if (old_ref_iter >= 2584u && old_ref_iter < params.ref_orbit_length) {
                let thread = getThread(old_ref_iter);
                if (thread.x >= 0.0) {
                  next_threaded_ref_iter = u32(thread.x);
                  threaded_delta_re = thread.y;
                  threaded_delta_im = thread.z;
                } else {
                  next_threaded_ref_iter = 0xFFFFFFFFu;
                }
              } else {
                next_threaded_ref_iter = 0xFFFFFFFFu;
              }
            }
          }
          // Check convergence (if we have a checkpoint and didn't just update it)
          // Use 0xFFFFFFFF as sentinel for "no checkpoint yet" (allows ckpt_iter=0)
          if (ckpt_iter != 0xFFFFFFFFu && !just_updated) {
            // Threading buffer capacity: 64MB / 16 bytes per iteration = 4,194,304 (2^22)
            const THREADING_CAPACITY = 4194304u;

            // Fallback: when ref_iter exceeds threading buffer, use absolute position comparison
            if (ref_iter >= THREADING_CAPACITY) {
              // Compute absolute positions (accepts float32 precision loss)
              let z_total_r = refr + old_dzr;
              let z_total_i = refi + old_dzi;
              let checkpoint_ref_offset = ckpt_iter * 2u;
              let z_checkpoint_r = refOrbit[checkpoint_ref_offset] + bbr;
              let z_checkpoint_i = refOrbit[checkpoint_ref_offset + 1u] + bbi;

              let diff_r = z_total_r - z_checkpoint_r;
              let diff_i = z_total_i - z_checkpoint_i;
              let db = max(abs(diff_r), abs(diff_i));

              if (db <= epsilon2) {
                if (pp == 0u) {
                  pp = iter;
                }
                if (db <= epsilon) {
                  statusAndPeriod[index] = vec2<u32>(2u, pp);  // Converged!
                  break;
                }
              }
            } else {
              // Normal convergence check with threading (high precision)
              // Check at checkpoint or at next threaded position
              if (ref_iter == ckpt_iter || (next_threaded_ref_iter != 0xFFFFFFFFu && ref_iter == next_threaded_ref_iter)) {
                let dz_diff_r = old_dzr - bbr;
                let dz_diff_i = old_dzi - bbi;
                let total_diff_r = threaded_delta_re + dz_diff_r;
                let total_diff_i = threaded_delta_im + dz_diff_i;
                let db = max(abs(total_diff_r), abs(total_diff_i));

                if (db <= epsilon2) {
                  if (pp == 0u) {
                    pp = iter;
                  }
                  if (db <= epsilon) {
                    statusAndPeriod[index] = vec2<u32>(2u, pp);  // Converged!
                    break;
                  }
                }

                // If at threaded position, step forward to next thread
                if (ref_iter == next_threaded_ref_iter && next_threaded_ref_iter < params.ref_orbit_length) {
                  let thread = getThread(next_threaded_ref_iter);
                  if (thread.x >= 0.0) {
                    threaded_delta_re += thread.y;
                    threaded_delta_im += thread.z;
                    next_threaded_ref_iter = u32(thread.x);
                  } else {
                    next_threaded_ref_iter = 0xFFFFFFFFu;
                  }
                }
              }
            }
          }

          iter++;
          ref_iter++;

          // Reference orbit loop: when ref_iter hits threshold, apply delta and jump back
          if (params.loop_enabled != 0u && ref_iter >= params.loop_threshold) {
            dzr += params.loop_delta_r;
            dzi += params.loop_delta_i;
            ref_iter -= params.loop_jump;
          }
        }
        // Write back state - pack into combined buffers
        iterations[index] = iter;
        dzAndCheckpoint[index6] = dzr;
        dzAndCheckpoint[index6 + 1u] = dzi;
        dzAndCheckpoint[index6 + 2u] = bbr;
        dzAndCheckpoint[index6 + 3u] = bbi;
        dzAndCheckpoint[index6 + 4u] = threaded_delta_re;
        dzAndCheckpoint[index6 + 5u] = threaded_delta_im;
        refIterAndCheckpoint[index3] = ref_iter;
        refIterAndCheckpoint[index3 + 1u] = ckpt_iter;
        refIterAndCheckpoint[index3 + 2u] = next_threaded_ref_iter;
        // Write back pp even if not converged (so it persists across batches)
        if (statusAndPeriod[index].x == 0u) {
          statusAndPeriod[index] = vec2<u32>(0u, pp);
        }
      }
    `;

    const shaderModule = this.device.createShaderModule({
      code: shaderCode,
      label: 'Perturbation compute shader'
    });

    this.pipeline = this.device.createComputePipeline({
      layout: 'auto',
      compute: {
        module: shaderModule,
        entryPoint: 'main'
      },
      label: 'Perturbation compute pipeline'
    });
  }

  async compute() {
    // Prevent concurrent compute() calls
    if (this.isComputing) {
      return;
    }
    this.isComputing = true;
    const dims2 = this.config.dimsWidth * this.config.dimsHeight;

    try {
    // Calculate batch size first (needed to determine reference orbit buffer)
    const pixelsToIterate = this.un + this.ch;
    const iterationsPerBatch = Math.max(17, Math.floor(333337 / Math.max(pixelsToIterate, 1)));

    // Update effort for scheduler (reflects actual iterations per call)
    this.effort = iterationsPerBatch;

    // Step 1: Extend reference orbit on CPU as needed
    // Extend to what pixels need (this.it) plus enough buffer for next batch
    const THREADING_CAPACITY = 4194304;  // 2^22
    const currentNeed = this.it + iterationsPerBatch;
    // Also allow growth for thread-following, but cap to avoid waste
    // Use proportional buffer (10%) for long periods, or fixed 10k for short periods
    const maxAllowedGrowth = Math.max(currentNeed + 10000, Math.round(currentNeed * 1.1));
    const threadingBuffer = Math.min(this.refIterations + 100, maxAllowedGrowth);
    // Cap at threading capacity - don't extend beyond this point
    const targetRefIterations = Math.min(Math.max(currentNeed, threadingBuffer), THREADING_CAPACITY);
    while (!this.refOrbitEscaped && this.refIterations < targetRefIterations) {
      this.extendReferenceOrbit();
    }

    // Setup reference orbit loop when we hit the threading capacity
    if (this.refIterations >= THREADING_CAPACITY && !this.refOrbitLoopConfigured) {
      this.setupReferenceOrbitLoop();
    }

    // Step 2: Upload reference orbit and threading to GPU (INCREMENTAL UPLOADS)
    const totalIters = this.refIterations + 1;  // Include iteration 0
    let orbitUploadTime = 0;
    let orbitBufferResized = false;

    // Resize refOrbit buffer if needed (2 floats per iter)
    const requiredOrbitSize = totalIters * 2 * 4;
    const allocOrbitSize = Math.max(requiredOrbitSize * 2, 1024);
    if (this.buffers.refOrbit.size < requiredOrbitSize && this.buffers.refOrbit.size < allocOrbitSize) {
      // Only resize if we can actually allocate a larger buffer
      // Wait for GPU to finish before destroying buffer
      await this.device.queue.onSubmittedWorkDone();
      orbitBufferResized = true;
      this.buffers.refOrbit.destroy();
      this.buffers.refOrbit = this.device.createBuffer({
        size: allocOrbitSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        label: 'Reference orbit buffer'
      });
      this.lastUploadedOrbitLength = -1;  // Reset after resize
      this.createBindGroup();
    }

    // Resize threading buffer if needed (4 floats per iter), cap at 128MB
    const requiredThreadingSize = totalIters * 4 * 4;
    const maxBufferSize = 128 * 1024 * 1024;  // 128MB cap
    const allocSize = Math.min(Math.max(requiredThreadingSize * 2, 1024), maxBufferSize);
    if (this.buffers.threading.size < requiredThreadingSize && this.buffers.threading.size < allocSize) {
      // Only resize if we can actually allocate a larger buffer (not already at max cap)
      // Wait for GPU to finish before destroying buffer
      await this.device.queue.onSubmittedWorkDone();
      this.buffers.threading.destroy();
      this.buffers.threading = this.device.createBuffer({
        size: allocSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        label: 'Threading buffer'
      });
      this.lastUploadedThreadingLength = -1;  // Reset after resize
      this.createBindGroup();
    }

    // INCREMENTAL UPLOAD: Only upload new orbit data
    if (this.lastUploadedOrbitLength < this.refIterations) {
      const startIdx = Math.max(0, this.lastUploadedOrbitLength + 1);
      const count = this.refIterations - startIdx + 1;
      const orbitF32 = new Float32Array(count * 2);

      for (let i = 0; i < count; i++) {
        const orbitIdx = startIdx + i;
        const ref = this.refOrbit[orbitIdx];
        orbitF32[i * 2] = ref[0] + ref[1];
        orbitF32[i * 2 + 1] = ref[2] + ref[3];
      }

      const byteOffset = startIdx * 2 * 4;
      this.device.queue.writeBuffer(this.buffers.refOrbit, byteOffset, orbitF32);
      this.lastUploadedOrbitLength = this.refIterations;
    }

    // INCREMENTAL UPLOAD: Only upload new threading data (capped at buffer size)
    if (this.lastUploadedThreadingLength < this.refIterations) {
      const startIdx = Math.max(0, this.lastUploadedThreadingLength + 1);
      // Cap to buffer capacity (1M iterations in 16MB buffer)
      const maxIters = this.buffers.threading.size / 16;
      const endIdx = Math.min(this.refIterations, maxIters - 1);
      const count = endIdx - startIdx + 1;

      if (count > 0) {
        const threadF32 = new Float32Array(count * 4);

        for (let i = 0; i < count; i++) {
          const threadIdx = startIdx + i;
          const thread = this.threading.refThreading[threadIdx];
          if (!thread) {
            // No threading data yet (before iteration 2584) - use -1 sentinel
            threadF32[i * 4] = -1;
            threadF32[i * 4 + 1] = 0;
            threadF32[i * 4 + 2] = 0;
            threadF32[i * 4 + 3] = 0;
          } else {
            threadF32[i * 4] = thread.next;  // Store as f32 (will be cast to u32 in shader)
            threadF32[i * 4 + 1] = thread.deltaRe;
            threadF32[i * 4 + 2] = thread.deltaIm;
            threadF32[i * 4 + 3] = 0;  // Padding
          }
        }

        const byteOffset = startIdx * 4 * 4;
        this.device.queue.writeBuffer(this.buffers.threading, byteOffset, threadF32);
      }

      this.lastUploadedThreadingLength = this.refIterations;
    }

    // Step 3: Check if all done
    if (this.un === 0) {
      this.isComputing = false;
      return;  // All pixels finished
    }

    // Step 4: Set up parameters
    // Batch size already calculated above (before reference orbit extension)
    const pixelSize = this.size / this.config.dimsWidth;

    // Step 4a: Precompute checkpoint offsets for this batch using fibonacciPeriod
    const checkpointOffsets = [];
    const bufferIter = this.it;
    for (let i = 0; i < iterationsPerBatch; i++) {
      const globalIter = bufferIter + i;
      if (fibonacciPeriod(globalIter) === 1) {
        checkpointOffsets.push(i);
      }
    }

    // Cap at 8 checkpoints (hardware limit based on uniform buffer fields)
    // Note: checkpointCount can be 0 if no checkpoints in this batch
    // That's OK - we'll keep comparing to the last checkpoint from a previous batch
    const checkpointCount = Math.min(checkpointOffsets.length, 8);

    // Step 5: Dispatch GPU compute - process all pixels
    const workgroupSize = 64;
    const numWorkgroups = Math.ceil(dims2 / workgroupSize);

    // 2D workgroup dispatch
    const workgroupsX = Math.ceil(Math.sqrt(numWorkgroups));
    const workgroupsY = Math.ceil(numWorkgroups / workgroupsX);

    // Pack params: dims_width, dims_height, iterations_per_batch, active_count, ref_orbit_length, exponent, workgroups_x, start_iter, checkpoint_count, ckpt0-7, loop params, pixel_size, aspect_ratio, loop deltas
    const paramsBuffer = new ArrayBuffer(128);  // Extended for new layout
    const paramsU32 = new Uint32Array(paramsBuffer);
    const paramsF32 = new Float32Array(paramsBuffer);
    paramsU32[0] = this.config.dimsWidth;
    paramsU32[1] = this.config.dimsHeight;
    paramsU32[2] = iterationsPerBatch;
    paramsU32[3] = dims2;  // active_count: Process all pixels, skip finished ones in shader
    paramsU32[4] = this.refIterations + 1;  // ref_orbit_length: includes iteration 0
    paramsU32[5] = this.config.exponent || 2;
    paramsU32[6] = workgroupsX * workgroupSize;  // Total threads in X dimension
    paramsU32[7] = bufferIter;  // start_iter: Starting iteration (what's in the buffer before iter++)
    paramsU32[8] = checkpointCount;  // Number of checkpoints in this batch

    // Pack all 8 checkpoint offsets (fill unused slots with 0)
    for (let i = 0; i < 8; i++) {
      paramsU32[9 + i] = i < checkpointCount ? checkpointOffsets[i] : 0;
    }

    // Pack reference orbit loop parameters
    const loop = this.refOrbitLoop || { enabled: false };
    paramsU32[17] = loop.enabled ? 1 : 0;
    paramsU32[18] = loop.threshold || 0;
    paramsU32[19] = loop.jumpAmount || 0;
    paramsU32[20] = 0;  // padding
    paramsF32[21] = pixelSize;
    paramsF32[22] = this.config.aspectRatio;
    paramsF32[23] = loop.deltaR || 0;
    paramsF32[24] = loop.deltaI || 0;

    this.device.queue.writeBuffer(this.buffers.params, 0, paramsBuffer);

    const commandEncoder = this.device.createCommandEncoder({ label: 'Perturbation compute' });
    const passEncoder = commandEncoder.beginComputePass({ label: 'Perturbation pass' });
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, this.bindGroup);
    passEncoder.dispatchWorkgroups(workgroupsX, workgroupsY);  // 2D dispatch
    passEncoder.end();

    this.device.queue.submit([commandEncoder.finish()]);

    // Step 6: Read back results
    await this.device.queue.onSubmittedWorkDone();

    const iterationsData = await this.readBuffer(this.buffers.iterations, Uint32Array);
    const statusAndPeriodData = await this.readBuffer(this.buffers.statusAndPeriod, Uint32Array);

    // Update global iteration counter (before processing results, like CPU implementations)
    this.it += iterationsPerBatch;

    // Only read detailed state if we need convergence positions
    let dzAndCheckpointData = null;
    let refIterData = null;

    // Step 7: Update board state
    const pixelsByIteration = new Map();  // Group diverged pixels by their exact iteration
    const convergedByIteration = new Map();  // Group converged pixels by their exact iteration
    let hasConverged = false;

    // First pass: check for diverged pixels and count converged
    let divergedCount = 0;
    let convergedCount = 0;

    for (let i = 0; i < dims2; i++) {
      const status = statusAndPeriodData[i * 2];  // First u32 in vec2
      const period = statusAndPeriodData[i * 2 + 1];  // Second u32 in vec2

      if (this.nn[i] !== 0) continue;  // Already finished

      if (status === 1) {
        // Newly diverged
        const iters = iterationsData[i];
        divergedCount++;
        this.nn[i] = iters;
        this.pp[i] = period;

        if (!pixelsByIteration.has(iters)) {
          pixelsByIteration.set(iters, []);
        }
        pixelsByIteration.get(iters).push(i);
        this.di++;
        this.un--;
      } else if (status === 2) {
        convergedCount++;
        hasConverged = true;
      }
    }

    // Second pass: only read heavy buffers if we have converged pixels
    if (hasConverged) {
      dzAndCheckpointData = await this.readBuffer(this.buffers.dzAndCheckpoint, Float32Array);
      refIterData = await this.readBuffer(this.buffers.refIterAndCheckpoint, Uint32Array);

      for (let i = 0; i < dims2; i++) {
        const status = statusAndPeriodData[i * 2];
        const period = statusAndPeriodData[i * 2 + 1];

        if (this.nn[i]) continue;  // Already finished

        if (status === 2) {
          // Newly converged
          const iters = iterationsData[i];
          this.nn[i] = -iters;

          // period from shader is pp (iteration when first within epsilon2)
          // Store pp - 1 because fibonacciPeriod() adds 1 in its calculation
          this.pp[i] = period - 1;

          // Get converged position: refOrbit[refIter+1] + dz
          // dz corresponds to refIter+1 because we computed new dz but didn't increment ref_iter
          const refIter = refIterData[i * 3];  // Read first u32 of 3-u32 structure
          const nextRefIter = refIter + 1;
          const dzr = dzAndCheckpointData[i * 6];
          const dzi = dzAndCheckpointData[i * 6 + 1];

          const ref = nextRefIter < this.refOrbit.length ? this.refOrbit[nextRefIter] : this.refOrbit[this.refOrbit.length - 1];
          const refR = ref ? (ref[0] + ref[1]) : 0;
          const refI = ref ? (ref[2] + ref[3]) : 0;

          if (!convergedByIteration.has(iters)) {
            convergedByIteration.set(iters, []);
          }
          convergedByIteration.get(iters).push({
            index: i,
            z: [refR + dzr, refI + dzi],
            p: this.pp[i]  // Raw pp value (UI will call fibonacciPeriod to calculate period)
          });
          this.un--;
        }
      }
    }

    // Create change objects grouped by iteration
    const allIterations = new Set([...pixelsByIteration.keys(), ...convergedByIteration.keys()]);
    const sortedIterations = Array.from(allIterations).sort((a, b) => a - b);

    for (const iter of sortedIterations) {
      const divergedIndices = pixelsByIteration.get(iter) || [];
      const convergedData = convergedByIteration.get(iter) || [];

      if (divergedIndices.length > 0 || convergedData.length > 0) {
        this.queueChanges({
          iter: iter,
          nn: divergedIndices,
          vv: convergedData
        });
      }
    }

    } catch (error) {
      console.error(`GpuZhuoranBoard.compute() ERROR:`, error);
    } finally {
      this.isComputing = false;
    }
  }

  static fromSerialized(serialized) {
    return new GpuZhuoranBoard(
      serialized.k,
      serialized.sizes[0],
      serialized.sizes[1],
      serialized.sizes[2],
      serialized.config,
      serialized.id
    );
  }
}

function workerLog(message) {
  self.postMessage({
    type: 'log',
    data: message
  });
}

const workerName = self.name;
const boards = new Map();
let hiddenBoards = new Set();
let focusedBoardK = null;
let computationPaused = false;
let steps = 0;
let startTime = 0;
let endTime = -1;
let timer = null;
let gpuMaxBufferSize = null;

self.onmessage = async function(e) {
  const { type, data } = e.data;
  switch (type) {
    case 'addBoard':
      workerNumber = data.workerNumber;
      const enableGPU = data.config.enableGPU;
      const webGPUAvailable = GpuBoard.isAvailable();

      // Query GPU limits once on first use
      if (enableGPU && webGPUAvailable && gpuMaxBufferSize === null) {
        gpuMaxBufferSize = await GpuBaseBoard.queryMaxBufferSize();
      }

      const forcedBoardType = data.config.forceBoard;  // Explicit board selection via board= parameter
      let board;
      const pixelSize = data.size / data.config.dimsWidth;
      const GpuBoardClass = GpuBaseBoard.getBoardClass(pixelSize);
      const bytesPerPixel = GpuBoardClass.BYTES_PER_PIXEL;
      const gpuSafe = GpuBaseBoard.isSafeDims(data.config.dimsWidth, data.config.dimsHeight, bytesPerPixel, gpuMaxBufferSize || 200 * 1024 * 1024);

      // Explicit board type selection via board= parameter
      if (forcedBoardType) {
        console.log(`Board ${data.k}: Requested board type: ${forcedBoardType}`);

        // Use switch to avoid referencing undefined classes
        switch (forcedBoardType) {
          case 'cpu':
            board = new CpuBoard(data.k, data.size, data.re, data.im, data.config, data.id);
            break;
          case 'zhuoran':
            board = new ZhuoranBoard(data.k, data.size, data.re, data.im, data.config, data.id);
            break;
          case 'perturbation':
            board = new PerturbationBoard(data.k, data.size, data.re, data.im, data.config, data.id);
            break;
          case 'gpu':
            if (webGPUAvailable && gpuSafe) {
              board = new GpuBoard(data.k, data.size, data.re, data.im, data.config, data.id);
            } else {
              console.warn('GpuBoard requested but not available, falling back to CpuBoard');
              board = new CpuBoard(data.k, data.size, data.re, data.im, data.config, data.id);
            }
            break;
          case 'gpuzhuoran':
            if (webGPUAvailable && gpuSafe) {
              board = new GpuZhuoranBoard(data.k, data.size, data.re, data.im, data.config, data.id);
            } else {
              console.warn('GpuZhuoranBoard requested but not available, falling back to ZhuoranBoard');
              board = new ZhuoranBoard(data.k, data.size, data.re, data.im, data.config, data.id);
            }
            break;
          default:
            console.error(`Unknown board type: ${forcedBoardType}, falling back to CpuBoard`);
            board = new CpuBoard(data.k, data.size, data.re, data.im, data.config, data.id);
        }
      } else if (enableGPU && webGPUAvailable && gpuSafe) {
        // Two-tier strategy with WebGPU:
        // - Shallow zooms: GpuBoard with simple float32 iteration
        // - Deep zooms: GpuZhuoranBoard with quad-double reference + float32 perturbations
        board = new GpuBoardClass(data.k, data.size, data.re, data.im, data.config, data.id);
      } else {
        if (enableGPU && webGPUAvailable && !gpuSafe) {
          const dims2 = data.config.dims2;
          const bufferSizeMB = (dims2 * bytesPerPixel / (1024*1024)).toFixed(0);
          const limitMB = ((gpuMaxBufferSize || 200 * 1024 * 1024) / (1024*1024)).toFixed(0);
          console.log(`Board ${data.k}: dims=${data.config.dimsWidth}x${data.config.dimsHeight} too large for GPU (buffer size ${bufferSizeMB} MB > ${limitMB} MB), using CPU`);
        }
        // WebGPU disabled or unavailable - use CPU-based boards
        if (pixelSize > 1e-12) {
          board = new CpuBoard(data.k, data.size, data.re, data.im, data.config, data.id);
        } else {
          board = new PerturbationBoard(data.k, data.size, data.re, data.im, data.config, data.id);
        }
      }

      boards.set(data.k, board);

      const re_val = Array.isArray(data.re) ? (data.re[0] + data.re[1]) : data.re;
      const im_val = Array.isArray(data.im) ? (data.im[0] + data.im[1]) : data.im;
      const precision = Math.max(3, Math.min(15, Math.ceil(-Math.log10(pixelSize)) + 2));
      console.log(`Board ${data.k}: ${board.constructor.name} @ (${re_val.toExponential(precision)}, ${im_val.toExponential(precision)}), dims=${data.config.dimsWidth}x${data.config.dimsHeight}, pixel=${pixelSize.toExponential(3)}`);

      // Send board type info once on creation
      self.postMessage({
        type: 'boardCreated',
        data: {
          k: data.k,
          boardType: board.constructor.name,
          isGPUBoard: board instanceof GpuBoard || board instanceof GpuZhuoranBoard
        }
      });
      break;
    case 'removeBoard':
      boards.delete(data.k);
      break;
    case 'setFocusedBoard':
      focusedBoardK = data.k;
      break;
    case 'setHiddenBoards':
      hiddenBoards = new Set(data.hiddenBoards);
      break;
    case 'requestTransfer':
      const transferredBoards = [];
      for (const k of data.boardKeys) {
        if (boards.has(k)) {
          const board = boards.get(k);
          // Skip GPU boards - they cannot be transferred as they lose GPU state
          if (board instanceof GpuBoard || board instanceof GpuZhuoranBoard) {
            console.log(`Skipping transfer of GPU board ${k} (${board.constructor.name})`);
            continue;
          }
          board.compact();
          const serializedBoard = board.serialize();
          boards.delete(k);
          transferredBoards.push(serializedBoard);
        }
      }
      // Send the serialized boards back to the scheduler
      self.postMessage({
        type: 'downloadTransfer',
        data: { transferredBoards }
      });
      break;
    case 'uploadTransfer':
      // Recreate the board from the serialized data and add it to this worker
      const newBoard = Board.fromSerialized(data.boardData);
      boards.set(newBoard.k, newBoard);
      break;
    case 'pause':
      computationPaused = data.pause;
      break;
  }
  if (!timer && boards.size && !computationPaused) {
    iterateBoards();
  } else {
    const remainingWork = Array.from(boards.values()).
        filter(board => !hiddenBoards.has(board.k)).
        map(b => b.unfinished() * b.effort).reduce((a, b) => a + b, 0);
    self.postMessage({
      type: 'update',
      data: {
        remainingWork,
      }
    });
  }
};

async function iterateBoards() {
  timer = null;
  if (computationPaused) {
    return;
  }
  let pri = Array.from(boards.values())
        .filter(board => (board.unfinished() || board.updateSize))
        .filter(board => !hiddenBoards.has(board.k));
  if (pri.length) {
    // Start timer if it is not already running.
    if (endTime) {
      startTime = (new Date).getTime();
      endTime = 0;
    }
    if (steps % 2) {
      // Prioritize most unfinished half the time.
      pri = pri.sort((a, b) => b.unfinished() - a.unfinished());
    } else {
      // Prioritize the most recent half the time.
      pri = pri.sort((a, b) => b.k - a.k);
      // Allow the user to prioritize by pointing the mouse.
      if (focusedBoardK !== null) {
        pri.sort((a, b) => (a.k === focusedBoardK ? -1 : b.k === focusedBoardK ? 1 : 0));
      }
    }
    // Exponential scheduling policy
    let shift = Math.floor(steps++ / 2) + 1;
    let p = 0;
    while (shift & (1 << p)) { p += 1; }
    const board = pri[Math.min(p, pri.length) % pri.length];
    for (let workDone = 0; workDone < 17377 && board.unfinished(); ) {
      workDone += board.un * board.effort;
      await board.iterate();
      if (board.isComputing) break;
    }
    const now = (new Date()).getTime();
    if (focusedBoardK == board.k ?
        (board.updateSize >= 1429 || now - board.lastTime >= 100) :
        (board.updateSize >= 4673 || now - board.lastTime >= 500)) {
      const boardEffort = board.unfinished() * board.effort;
      const remainingWork = pri.map(b => b.unfinished() * b.effort).reduce((a, b) => a + b, 0);
      const workerInfo = `${workerName}: ` + (board.unfinished() ?
           `boards {${[...boards.keys()]}}, work: ${remainingWork}` :
           `board finished`);
      self.postMessage({
        type: 'iterations',
        data: {
          k: board.k,
          id: board.id,
          it: board.it,
          un: board.un,
          di: board.di,
          ch: board.ch,
          changeList: board.changeList,
          boardEffort,
          remainingWork,
          workerInfo,
          boardType: board.constructor.name
        }
      });
      board.lastTime = now;
      board.updateSize = 0;
      board.changeList = [];
      if (!board.unfinished()) {
        // Delete board when done.
        boards.delete(board.k);
        // workerLog(`Board ${board.k} finished, leaving {${[...boards.keys()]}}`);
      }
    }
  } else {
    // End timer when there is no remaining work
    if (!endTime) {
       endTime = (new Date).getTime();
       // workerLog(`Finished in ${((endTime - startTime) / 1000).toFixed(3)}s`);
    }
    return;
  }
  timer = setTimeout(iterateBoards, 0);
}

</script>
<script id="quadCode">
//////////// quad-precision (qd, double double) utilities ///////////

function toQd(x) {
  return Array.isArray(x) ? x : [x, 0];
}

function toQdc(c) {
  if (c.length == 4) { return c; }
  const r = toQd(c[0]);
  const j = toQd(c[1]);
  return [r[0], r[1], j[0], j[1]];
}

function fast2Sum(a, b) {
  let s = a + b;
  let t = b - (s - a);
  return [s, t];
}

function slow2Sum(a, b) {
  let s = a + b;
  let c = s - a;
  return [s, (a - (s - c)) + (b - c)];
}

function qdSplit(a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  return [x, y];
}

function twoProduct(a, b) {
  let p = a * b;
  let [ah, al] = qdSplit(a);
  let [bh, bl] = qdSplit(b);
  let err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  return [p, err];
}

function twoSquare(a) {
  let p = a * a;
  let [ah, al] = qdSplit(a);
  let err = ((ah * ah - p) + 2 * ah * al) + al * al;
  return [p, err];
}

function qdAdd(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [h1, h2] = slow2Sum(a1, b1);
  let [l1, l2] = slow2Sum(a0, b0);
  let [v1, v2] = fast2Sum(h1, h2 + l1);
  return fast2Sum(v1, v2 + l2);
}

function qdMul(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [p1, p2] = twoProduct(a1, b1);
  return fast2Sum(p1, p2 + a1 * b0 + b1 * a0);
}

function qdDouble(a) {
  return [a[0] * 2, a[1] * 2];
}

function qdScale(q, s) {
  let [q1, q0] = q;
  let [p1, p2] = twoProduct(q1, s);
  return fast2Sum(p1, p2 + s * q0);
}

function qdSquare(a) {
  let [a1, a0] = a;
  let [p1, p2] = twoSquare(a1);
  return fast2Sum(p1, p2 + 2 * a1 * a0);
}

function qdcPow(q, n) {
  if (n === 1) return q;
  if (n === 2) return qdcSquare(q);
  if (n === 3) return qdcMul(qdSquare(q), q);
  let result = [1, 0, 0, 0];
  let base = q;
  while (n > 0) {
    if (n % 2 === 1) { result = qdcMul(result, base); }
    base = qdcSquare(base);
    n = Math.floor(n / 2);
  }
  return result;
}

function qdNegate(a) {
  let [a1, a0] = a;
  return [-a1, -a0];
}

function qdSub(a, b) {
  return qdAdd(a, qdNegate(b));
}

function qdDiv(a, b) {
  let reciprocal = qdReciprocal(b);
  return qdMul(a, reciprocal);
}

function qdReciprocal(b, iters = 2) {
  if (b[0] === 0 && b[1] === 0) {
    return [NaN, 0];  // Return NaN for division by zero
  }
  // Refine the approximation using Newton-Raphson iteration
  let x = [1 / b[0], 0];
  for (let i = 0; i < iters; i++) {
    x = qdMul(x, qdSub([2, 0], qdMul(x, b)));
  }
  return x;
}

// Complex operations in quad precision
function qdcAdd(a, b) {
  let realSum = qdAdd([a[0], a[1]], [b[0], b[1]]);
  let imagSum = qdAdd([a[2], a[3]], [b[2], b[3]]);
  return [realSum[0], realSum[1], imagSum[0], imagSum[1]];
}

// Complex subtraction in quad precision
function qdcSub(a, b) {
  let realDiff = qdSub([a[0], a[1]], [b[0], b[1]]);
  let imagDiff = qdSub([a[2], a[3]], [b[2], b[3]]);
  return [realDiff[0], realDiff[1], imagDiff[0], imagDiff[1]];
}

// Complex multiplication in quad precision
function qdcMul(a, b) {
  let ac = qdMul([a[0], a[1]], [b[0], b[1]]);
  let bd = qdMul([a[2], a[3]], [b[2], b[3]]);
  let adbc = qdMul(qdAdd([a[0], a[1]], [a[2], a[3]]), qdAdd([b[0], b[1]], [b[2], b[3]]));
  let real = qdSub(ac, bd);
  let imag = qdSub(adbc, qdAdd(ac, bd));
  return [real[0], real[1], imag[0], imag[1]];
}

// Complex doubling in quad precision
function qdcDouble(a) {
  let realDouble = qdDouble([a[0], a[1]]);
  let imagDouble = qdDouble([a[2], a[3]]);
  return [realDouble[0], realDouble[1], imagDouble[0], imagDouble[1]];
}

// Complex squaring in quad precision
function qdcSquare(a) {
  let a0a0 = qdSquare([a[0], a[1]]);
  let a1a1 = qdSquare([a[2], a[3]]);
  let a0a1 = qdMul([a[0], a[1]], [a[2], a[3]]);
  let real = qdSub(a0a0, a1a1);
  let imag = qdDouble(a0a1);
  return [real[0], real[1], imag[0], imag[1]];
}

// Complex absolute value in quad precision
function qdcAbs(a) {
  let a0a0 = qdSquare([a[0], a[1]]);
  let a1a1 = qdSquare([a[2], a[3]]);
  return qdAdd(a0a0, a1a1);
}

function qdParse(s) {
  s = s.trim().toLowerCase();
  if (s === "infinity" || s === "+infinity") return [Infinity, 0];
  if (s === "-infinity") return [-Infinity, 0];
  if (s === "nan") return [NaN, 0];
  let sign = 1;
  if (s[0] === '-') {
    sign = -1;
    s = s.slice(1);
  } else if (s[0] === '+') {
    s = s.slice(1);
  }
  let e = 0;
  let parts = s.split('e');
  if (parts.length > 1) {
    s = parts[0];
    e = parseInt(parts[1]);
  }
  let decimalPos = s.indexOf('.');
  if (decimalPos !== -1) {
    s = s.replace('.', '');
    e -= s.length - decimalPos;
  }
  s = s.replace(/^0+/, '');
  if (s === '') return [0, 0];
  let result = [0, 0];
  for (let digit of s) {
    result = qdAdd(qdMul(result, [10, 0]), [parseInt(digit), 0]);
  }
  if (e !== 0) {
    result = qdMul(result, qdPow10(e));
  }
  if (sign === -1) {
    result = qdNegate(result);
  }
  return result;
}

function qdPow10(e) {
  if (e < 0) return qdReciprocal(qdPow10(-e));
  // Up to 1e16, the second component is zero.
  if (e <= 16) { return [10 ** e, 0]; }
  if (e % 2) { return qdMul([1e15, 0], qdPow10(e - 15)) };
  return qdSquare(qdPow10(e / 2));
}

function qdFloor(q) {
  let [a, b] = q;
  let fl = Math.floor(a);
  let [r0, r1] = qdAdd([a, b], [-fl, 0]);
  if (r0 < 0 || (r0 === 0 && r1 < 0)) {
    fl -= 1;
  }
  return [fl, 0];
}

function qdCompare(a, b) {
  if (a[0] < b[0]) return -1;
  if (a[0] > b[0]) return 1;
  if (a[1] < b[1]) return -1;
  if (a[1] > b[1]) return 1;
  return 0;
}

function qdLt(a, s) {
  return a[0] < s || (a[0] == s && a[1] < 0);
}

function qdEq(a, s) {
  return a[0] == s && a[1] == 0;
}

function qdAbs(q) {
  return (q[0] + q[1] < 0) ? qdNegate(q) : q;
}

function qdFixed(q, digits = 0) {
  // With fixed-point notation, digits specifies the number of digits after the decimal point.
  return qdFormat(q, digits, true);
}

const qdTen = [10, 0];

function qdFormat(q, digits = 'auto', useFixedPoint = false) {
  // With scientific notation, digits specifies the number of significant digits.
  let [a, b] = q;
  let s = a < 0 || (a === 0 && b < 0) ? '-' : '';
  let autoFormat = (digits == 'auto');
  if (autoFormat) {
     digits = 32;
  }
  q = qdAbs(q);
  if (!isFinite(a) || !isFinite(b)) return a.toString();
  if (a === 0 && b === 0) {
     if (autoFormat) return '0';
     if (useFixedPoint) digits += 1;
     return '0' + (digits > 1 ? '.' + '0'.repeat(digits - 1) : '');
  }
  // Scale q to be between 1 and 10
  let e = parseInt(q[0].toExponential().match(/e([+-]\d+)/)[1]);
  if (qdCompare(q, qdPow10(e)) < 0) { e -= 1; }
  if (qdCompare(q, qdPow10(1+e)) >= 0) { e += 1; }
  if (e) { q = qdMul(q, qdPow10(-e)); }
  if (!qdLt(q, 10)) { // Hit boundary condition
    q = qdDiv(q, qdTen);
    e += 1;
  }
  let result = '';
  let nonzeroDigits = digits;
  if (useFixedPoint && !autoFormat) {
     nonzeroDigits = nonzeroDigits + e + 1;
  }
  for (let i = 0; i < nonzeroDigits + 1; i++) {
    let floorQ = qdFloor(q);
    let digit = floorQ[0];
    result += digit;
    q = qdSub(q, floorQ);
    q = qdMul(q, qdTen);
  }
  // Rounding
  if (nonzeroDigits < 0) {
    // No nonzero signficant digits? Treat as zero.
    result = '?';
    nonzeroDigits = 0;
    e = 0;
  } else if (parseInt(result[nonzeroDigits]) >= 5) {
    result = result.slice(0, nonzeroDigits) + '?';
    let carry = 1;
    for (let i = nonzeroDigits - 1; i >= 0; i--) {
      let digit = parseInt(result[i]) + carry;
      if (digit < 10) {
        result = result.slice(0, i) + digit + result.slice(i + 1);
        carry = 0;
        break;
      } else {
        result = result.slice(0, i) + '0' + result.slice(i + 1);
        carry = 1;
      }
    }
    if (carry) {
      result = '1' + result;
      nonzeroDigits += 1;
      e++;
    }
  }
  result = result.slice(0, nonzeroDigits);
  epart = '';
  if (!useFixedPoint && (!autoFormat || e < -6 || e >= 32)) {
    // Scientific notation
    if (result.length > 1) {
      result = result[0] + '.' + result.slice(1);
    }
    if (e !== 0) {
      epart = 'e' + e;
    }
  } else {
    // Fixed-point notation
    if (e >= 0) {
      result = result.padEnd(e + 1, '0');
      result = result.slice(0, e + 1) + '.' + result.slice(e + 1);
    } else {
      result = '0.' + '0'.repeat(-e - 1) + result;
    }
    // Ensure the correct number of digits after the decimal point
    let [intPart, fracPart] = result.split('.');
    if (digits <= 0) {
      result = intPart;
    } else {
      fracPart = (fracPart || '').padEnd(digits, '0');
      result = intPart + '.' + fracPart;
    }
  }
  if (autoFormat) {
    // Auto digit selection: trim trailing zeros
    result = result.replace(/\.0+$|(\.\d*[1-9])0+$/, "$1");
  }
  return s + result + epart;
}

// Array in-place quad precision, allows fast computation
// by avoiding array constructors

function Afast2Sum(r, i, a, b) {
  let s = a + b;
  r[i] = s;
  r[i+1] = b - (s - a);
}

function Aslow2Sum(r, i, a, b) {
  let s = a + b;
  let c = s - a;
  r[i] = s;
  r[i+1] = (a - (s - c)) + (b - c);
}

function AqdSplit(r, i, a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  r[i] = x;
  r[i+1] = y;
}

function AtwoProduct(r, i, a, b) {
  const p = a * b;
  AqdSplit(r, i, a);
  const ah = r[i];
  const al = r[i+1];
  AqdSplit(r, i, b);
  const bh = r[i];
  const bl = r[i+1];
  const err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  r[i] = p;
  r[i+1] = err;
}

function AtwoSquare(r, i, a) {
  const p = a * a;
  AqdSplit(r, i, a);
  const ah = r[i];
  const al = r[i+1];
  const err = ((ah * ah - p) + 2 * ah * al) + al * al;
  r[i] = p;
  r[i+1] = err;
}

function AqdAdd(r, i, a1, a2, b1, b2) {
  Aslow2Sum(r, i, a1, b1);
  const h1 = r[i];
  const h2 = r[i+1];
  Aslow2Sum(r, i, a2, b2);
  const l1 = r[i];
  const l2 = r[i+1];
  Afast2Sum(r, i, h1, h2 + l1);
  const v1 = r[i];
  const v2 = r[i+1];
  Afast2Sum(r, i, v1, v2 + l2);
}

function AqdMul(r, i, a1, a2, b1, b2) {
  AtwoProduct(r, i, a1, b1);
  const p1 = r[i];
  const p2 = r[i+1];
  Afast2Sum(r, i, p1, p2 + a1 * b2 + b1 * a2);
}

function AqdSet(r, i, a1, a2) {
  r[i] = a1;
  r[i+1] = a2;
}

function AqdcCopy(r, i, s, si) {
  r[i] = s[si];
  r[i+1] = s[si+1];
  r[i+2] = s[si+2];
  r[i+3] = s[si+3];
}

function AqdcGet(s, si) {
  return s.slice(si, si+4);
}

function AqdSquare(r, i, a1, a2) {
  AtwoSquare(r, i, a1);
  const p1 = r[i];
  const p2 = r[i+1];
  Afast2Sum(r, i, p1, p2 + 2 * a1 * a2);
}

function AqdAbsSub(r, i, a1, a2, b1, b2) {
  AqdAdd(r, i, a1, a2, -b1, -b2);
  if (r[i] + r[i+1] < 0) {
    r[i] = -r[i];
    r[i+1] = -r[i+1];
  }
}

// Additional shared utility function for tracking cycles.

function fibonacciPeriod(iteration) {
  // Returns 1 at Fibonacci checkpoints (1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...)
  // Otherwise returns distance from most recent Fibonacci checkpoint plus 1.
  // Fibonacci growth (Ï† â‰ˆ 1.618) reduces aliasing with periods compared to power-of-2.
  if (iteration === 0) return 1;
  if (iteration === 1) return 1;

  // Find largest Fibonacci number <= iteration
  let a = 1, b = 1;
  while (b < iteration) {
    const next = a + b;
    a = b;
    b = next;
  }

  // Return 1 if iteration is exact Fibonacci, else distance from previous
  if (b === iteration) return 1;
  return iteration - a + 1;
}

</script>
<!-- Internationalization: Non-English help text and language detection -->
<div lang="es" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Explorador de Fractales del Conjunto de Mandelbrot
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Toca">Haz clic</span> para ampliar.</b>  <span mobile="">Haz clic derecho para guardar imÃ¡genes, <b>M</b> para crear y guardar un vÃ­deo de tu recorrido de zoom.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> se itera para cada <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">nÃºmero complejo</a> <em>c</em>.  Los colores muestran <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iteraciones</a> hasta la divergencia; los puntos negros <a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">convergen o ciclan</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Los puntos amarillos muestran <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">Ã³rbitas</a></b>.  Los puntos rojos muestran ciclos lÃ­mite.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Acerca de las iteraciones.</b> Este visor muestra mÃ¡s detalle fractal con el tiempo al refinar las iteraciones hacia el infinito mientras exploras. Cuanto mÃ¡s esperes, mÃ¡s detalle se mostrarÃ¡.
DespuÃ©s de miles o millones de iteraciones, puedes resolver los detalles mÃ¡s finos en las partes mÃ¡s complejas del fractal.
Ve informaciÃ³n sobre iteraciones, progreso y coordenadas <span mobile="tocando">pasando el cursor sobre</span> el nÃºmero amarillo de zoom bajo cada ventana.
<span mobile="Manteniendo tu dedo">Mover el ratÃ³n</span> sobre el contenido fractal animarÃ¡ la Ã³rbita de valores <em>z</em> para cada ubicaciÃ³n <em>c</em>, revelando la compleja dinÃ¡mica de frontera que ha fascinado a los matemÃ¡ticos.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Explorando una ruta de zoom.</b>
Cada <span mobile="toque">clic</span> en el fractal abre un nivel de zoom mÃ¡s alto en la ubicaciÃ³n seleccionada, calculado en tu GPU si estÃ¡ disponible.
DespuÃ©s de ampliar mÃ¡s allÃ¡ de una magnificaciÃ³n de un billÃ³n de veces, usamos un algoritmo de perturbaciÃ³n de precisiÃ³n cuÃ¡druple que resuelve detalles finos con mÃ¡s de 30 dÃ­gitos de precisiÃ³n.
Una vez que hayas creado una ruta interesante que muestre el detalle que deseas, puedes <a class="moviemode">crear y descargar tu propio vÃ­deo de zoom profundo de Mandelbrot</a> o marcar tu URL para guardar y compartir tu exploraciÃ³n.
Para crear imÃ¡genes y vÃ­deos de alta calidad, este visor calcula subpÃ­xeles con una proporciÃ³n de <span class="pixelratio">2</span>:1<span mobile="">, y eso puede aumentarse para crear visualizaciones mÃ¡s precisas</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>MÃ¡s comandos:</b>
<b>I</b> amplÃ­a;
<b mac="&#8984;">Ctrl</b>-clic para ampliar en el lugar;
<b>H</b> encoge y <b>G</b> agranda cada ventana;
<b>R</b> reabre ventanas intermedias;
<b>C</b> recentra todas;
<b>T</b> cambia el tema de color;
<b>U</b> resalta pÃ­xeles sin terminar;
<b mac="&#x23CE;">Enter</b> alterna pantalla completa;
<b>X</b> aumenta y <b>Z</b> disminuye el exponente de <em>z</em>;
<b>F</b> aumenta y <b>D</b> disminuye la proporciÃ³n de pÃ­xeles;
<b>A</b> alterna relaciÃ³n de aspecto;
<b>M</b> crea un vÃ­deo que sigue tu ruta;
<nobr><b>?</b> muestra esta ayuda.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<div lang="zh" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
æ›¼å¾·åšé›†åˆåˆ†å½¢æŽ¢ç´¢å™¨
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="ç‚¹å‡»">å•å‡»</span>ä»¥ç¼©æ”¾ã€‚</b>  <span mobile="">å³é”®å•å‡»ä»¥ä¿å­˜å›¾åƒï¼ŒæŒ‰<b>M</b>é”®åˆ›å»ºå¹¶ä¿å­˜æ‚¨çš„ç¼©æ”¾è·¯å¾„è§†é¢‘ã€‚</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
å¯¹æ¯ä¸ª<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">å¤æ•°</a> <em>c</em> è¿­ä»£ <em>z &rightarrow; z<sup class="exponent">2</sup>+c</em>ã€‚é¢œè‰²æ˜¾ç¤ºåˆ°<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">å‘æ•£çš„è¿­ä»£æ¬¡æ•°</a>ï¼›é»‘è‰²ç‚¹<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">æ”¶æ•›æˆ–å¾ªçŽ¯</a>ã€‚
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>é»„ç‚¹æ˜¾ç¤º<a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">è½¨é“</a></b>ã€‚çº¢ç‚¹æ˜¾ç¤ºæžé™çŽ¯ã€‚
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>å…³äºŽè¿­ä»£ã€‚</b>éšç€æ‚¨çš„æŽ¢ç´¢ï¼Œæ­¤æŸ¥çœ‹å™¨é€šè¿‡å°†è¿­ä»£ç²¾ç»†åŒ–è‡³æ— ç©·æ¥æ˜¾ç¤ºæ›´å¤šåˆ†å½¢ç»†èŠ‚ã€‚ç­‰å¾…æ—¶é—´è¶Šé•¿ï¼Œæ˜¾ç¤ºçš„ç»†èŠ‚è¶Šå¤šã€‚
ç»è¿‡æ•°åƒæˆ–æ•°ç™¾ä¸‡æ¬¡è¿­ä»£åŽï¼Œæ‚¨å¯ä»¥è§£æžåˆ†å½¢æœ€å¤æ‚éƒ¨åˆ†çš„æœ€ç²¾ç»†ç»†èŠ‚ã€‚
é€šè¿‡<span mobile="ç‚¹å‡»">æ‚¬åœåœ¨</span>æ¯ä¸ªçª—å£ä¸‹æ–¹çš„é»„è‰²ç¼©æ”¾æ•°å­—ä¸Šï¼ŒæŸ¥çœ‹æœ‰å…³è¿­ä»£ã€è¿›åº¦å’Œåæ ‡çš„ä¿¡æ¯ã€‚
<span mobile="æŒ‰ä½æ‰‹æŒ‡">ç§»åŠ¨é¼ æ ‡</span>åˆ°åˆ†å½¢å†…å®¹ä¸Šå°†åŠ¨ç”»æ˜¾ç¤ºæ¯ä¸ªä½ç½® <em>c</em> çš„ <em>z</em> å€¼è½¨é“ï¼Œæ­ç¤ºä»¤æ•°å­¦å®¶ç€è¿·çš„å¤æ‚è¾¹ç•ŒåŠ¨åŠ›å­¦ã€‚
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>æŽ¢ç´¢ç¼©æ”¾è·¯å¾„ã€‚</b>
åˆ†å½¢ä¸Šçš„æ¯æ¬¡<span mobile="ç‚¹å‡»">å•å‡»</span>éƒ½ä¼šåœ¨æ‰€é€‰ä½ç½®æ‰“å¼€æ›´é«˜çš„ç¼©æ”¾çº§åˆ«ï¼Œå¦‚æžœå¯ç”¨ï¼Œå°†åœ¨æ‚¨çš„GPUä¸Šè®¡ç®—ã€‚
å½“æ‚¨æ”¾å¤§è¶…è¿‡ä¸‡äº¿å€åŽï¼Œæˆ‘ä»¬ä½¿ç”¨å››ç²¾åº¦æ‰°åŠ¨ç®—æ³•ï¼Œå¯å°†ç²¾ç»†ç»†èŠ‚è§£æžåˆ°è¶…è¿‡30ä½æ•°å­—çš„ç²¾åº¦ã€‚
ä¸€æ—¦æ‚¨åˆ¶ä½œäº†ä¸€æ¡æ˜¾ç¤ºæ‰€éœ€ç»†èŠ‚çš„æœ‰è¶£è·¯å¾„ï¼Œæ‚¨å¯ä»¥<a class="moviemode">åˆ›å»ºå¹¶ä¸‹è½½è‡ªå·±çš„æ›¼å¾·åšæ·±åº¦ç¼©æ”¾è§†é¢‘</a>ï¼Œæˆ–ä¸ºæ‚¨çš„URLæ·»åŠ ä¹¦ç­¾ä»¥ä¿å­˜å’Œåˆ†äº«æ‚¨çš„æŽ¢ç´¢ã€‚
ä¸ºäº†åˆ›å»ºé«˜è´¨é‡çš„å›¾åƒå’Œè§†é¢‘ï¼Œæ­¤æŸ¥çœ‹å™¨ä»¥<span class="pixelratio">2</span>:1çš„æ¯”ä¾‹è®¡ç®—å­åƒç´ <span mobile="">ï¼Œå¹¶ä¸”å¯ä»¥å¢žåŠ è¯¥æ¯”ä¾‹ä»¥åˆ›å»ºæ›´ç²¾ç¡®çš„æ˜¾ç¤º</span>ã€‚
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>æ›´å¤šå‘½ä»¤ï¼š</b>
<b>I</b> æ”¾å¤§ï¼›
<b mac="&#8984;">Ctrl</b>-å•å‡»å¯åŽŸåœ°æ”¾å¤§ï¼›
<b>H</b> ç¼©å°ï¼Œ<b>G</b> æ”¾å¤§æ¯ä¸ªçª—å£ï¼›
<b>R</b> é‡æ–°æ‰“å¼€ä¸­é—´çª—å£ï¼›
<b>C</b> é‡æ–°å±…ä¸­æ‰€æœ‰çª—å£ï¼›
<b>T</b> æ›´æ”¹é¢œè‰²ä¸»é¢˜ï¼›
<b>U</b> çªå‡ºæ˜¾ç¤ºæœªå®Œæˆçš„åƒç´ ï¼›
<b mac="&#x23CE;">Enter</b> åˆ‡æ¢å…¨å±ï¼›
<b>X</b> å¢žåŠ ï¼Œ<b>Z</b> å‡å°‘ <em>z</em> æŒ‡æ•°ï¼›
<b>F</b> å¢žåŠ ï¼Œ<b>D</b> å‡å°‘åƒç´ æ¯”çŽ‡ï¼›
<b>A</b> åˆ‡æ¢çºµæ¨ªæ¯”ï¼›
<b>M</b> åˆ¶ä½œæ²¿æ‚¨è·¯å¾„çš„è§†é¢‘ï¼›
<nobr><b>?</b> æ˜¾ç¤ºæ­¤å¸®åŠ©ã€‚</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<div lang="zh-TW" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
æ›¼å¾·åšé›†åˆç¢Žå½¢æŽ¢ç´¢å™¨
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="é»žæ“Š">é»žæ“Š</span>ä»¥ç¸®æ”¾ã€‚</b>  <span mobile="">å³éµé»žæ“Šä»¥å„²å­˜åœ–åƒï¼ŒæŒ‰<b>M</b>éµå‰µå»ºä¸¦å„²å­˜æ‚¨çš„ç¸®æ”¾è·¯å¾‘å½±ç‰‡ã€‚</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
å°æ¯å€‹<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">è¤‡æ•¸</a> <em>c</em> è¿­ä»£ <em>z &rightarrow; z<sup class="exponent">2</sup>+c</em>ã€‚é¡è‰²é¡¯ç¤ºåˆ°<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">ç™¼æ•£çš„è¿­ä»£æ¬¡æ•¸</a>ï¼›é»‘è‰²é»ž<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">æ”¶æ–‚æˆ–å¾ªç’°</a>ã€‚
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>é»ƒé»žé¡¯ç¤º<a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">è»Œé“</a></b>ã€‚ç´…é»žé¡¯ç¤ºæ¥µé™ç’°ã€‚
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>é—œæ–¼è¿­ä»£ã€‚</b>éš¨è‘—æ‚¨çš„æŽ¢ç´¢ï¼Œæ­¤æª¢è¦–å™¨é€šéŽå°‡è¿­ä»£ç²¾ç´°åŒ–è‡³ç„¡çª®ä¾†é¡¯ç¤ºæ›´å¤šç¢Žå½¢ç´°ç¯€ã€‚ç­‰å¾…æ™‚é–“è¶Šé•·ï¼Œé¡¯ç¤ºçš„ç´°ç¯€è¶Šå¤šã€‚
ç¶“éŽæ•¸åƒæˆ–æ•¸ç™¾è¬æ¬¡è¿­ä»£å¾Œï¼Œæ‚¨å¯ä»¥è§£æžç¢Žå½¢æœ€è¤‡é›œéƒ¨åˆ†çš„æœ€ç²¾ç´°ç´°ç¯€ã€‚
é€šéŽ<span mobile="é»žæ“Š">æ‡¸åœåœ¨</span>æ¯å€‹è¦–çª—ä¸‹æ–¹çš„é»ƒè‰²ç¸®æ”¾æ•¸å­—ä¸Šï¼ŒæŸ¥çœ‹æœ‰é—œè¿­ä»£ã€é€²åº¦å’Œåº§æ¨™çš„è³‡è¨Šã€‚
<span mobile="æŒ‰ä½æ‰‹æŒ‡">ç§»å‹•æ»‘é¼ </span>åˆ°ç¢Žå½¢å…§å®¹ä¸Šå°‡å‹•ç•«é¡¯ç¤ºæ¯å€‹ä½ç½® <em>c</em> çš„ <em>z</em> å€¼è»Œé“ï¼Œæ­ç¤ºä»¤æ•¸å­¸å®¶è‘—è¿·çš„è¤‡é›œé‚Šç•Œå‹•åŠ›å­¸ã€‚
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>æŽ¢ç´¢ç¸®æ”¾è·¯å¾‘ã€‚</b>
ç¢Žå½¢ä¸Šçš„æ¯æ¬¡<span mobile="é»žæ“Š">é»žæ“Š</span>éƒ½æœƒåœ¨æ‰€é¸ä½ç½®é–‹å•Ÿæ›´é«˜çš„ç¸®æ”¾ç´šåˆ¥ï¼Œå¦‚æžœå¯ç”¨ï¼Œå°‡åœ¨æ‚¨çš„GPUä¸Šè¨ˆç®—ã€‚
ç•¶æ‚¨æ”¾å¤§è¶…éŽå…†å€å¾Œï¼Œæˆ‘å€‘ä½¿ç”¨å››ç²¾åº¦æ“¾å‹•æ¼”ç®—æ³•ï¼Œå¯å°‡ç²¾ç´°ç´°ç¯€è§£æžåˆ°è¶…éŽ30ä½æ•¸å­—çš„ç²¾åº¦ã€‚
ä¸€æ—¦æ‚¨è£½ä½œäº†ä¸€æ¢é¡¯ç¤ºæ‰€éœ€ç´°ç¯€çš„æœ‰è¶£è·¯å¾‘ï¼Œæ‚¨å¯ä»¥<a class="moviemode">å‰µå»ºä¸¦ä¸‹è¼‰è‡ªå·±çš„æ›¼å¾·åšæ·±åº¦ç¸®æ”¾å½±ç‰‡</a>ï¼Œæˆ–ç‚ºæ‚¨çš„URLåŠ å…¥æ›¸ç±¤ä»¥å„²å­˜å’Œåˆ†äº«æ‚¨çš„æŽ¢ç´¢ã€‚
ç‚ºäº†å‰µå»ºé«˜å“è³ªçš„åœ–åƒå’Œå½±ç‰‡ï¼Œæ­¤æª¢è¦–å™¨ä»¥<span class="pixelratio">2</span>:1çš„æ¯”ä¾‹è¨ˆç®—å­åƒç´ <span mobile="">ï¼Œä¸¦ä¸”å¯ä»¥å¢žåŠ è©²æ¯”ä¾‹ä»¥å‰µå»ºæ›´ç²¾ç¢ºçš„é¡¯ç¤º</span>ã€‚
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>æ›´å¤šå‘½ä»¤ï¼š</b>
<b>I</b> æ”¾å¤§ï¼›
<b mac="&#8984;">Ctrl</b>-é»žæ“Šå¯åŽŸåœ°æ”¾å¤§ï¼›
<b>H</b> ç¸®å°ï¼Œ<b>G</b> æ”¾å¤§æ¯å€‹è¦–çª—ï¼›
<b>R</b> é‡æ–°é–‹å•Ÿä¸­é–“è¦–çª—ï¼›
<b>C</b> é‡æ–°ç½®ä¸­æ‰€æœ‰è¦–çª—ï¼›
<b>T</b> æ›´æ”¹é¡è‰²ä¸»é¡Œï¼›
<b>U</b> çªå‡ºé¡¯ç¤ºæœªå®Œæˆçš„åƒç´ ï¼›
<b mac="&#x23CE;">Enter</b> åˆ‡æ›å…¨èž¢å¹•ï¼›
<b>X</b> å¢žåŠ ï¼Œ<b>Z</b> æ¸›å°‘ <em>z</em> æŒ‡æ•¸ï¼›
<b>F</b> å¢žåŠ ï¼Œ<b>D</b> æ¸›å°‘åƒç´ æ¯”çŽ‡ï¼›
<b>A</b> åˆ‡æ›ç¸±æ©«æ¯”ï¼›
<b>M</b> è£½ä½œæ²¿æ‚¨è·¯å¾‘çš„å½±ç‰‡ï¼›
<nobr><b>?</b> é¡¯ç¤ºæ­¤å¹«åŠ©ã€‚</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<div lang="ar" style="display:none;direction:rtl;text-align:right">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Ù…Ø³ØªÙƒØ´Ù ÙƒØ³ÙŠØ±ÙŠØ§Øª Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ø§Ù†Ø¯Ù„Ø¨Ø±ÙˆØª
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Ø§Ø¶ØºØ·">Ø§Ù†Ù‚Ø±</span> Ù„Ù„ØªÙƒØ¨ÙŠØ±.</b>  <span mobile="">Ø§Ù†Ù‚Ø± Ø¨Ø²Ø± Ø§Ù„Ù…Ø§ÙˆØ³ Ø§Ù„Ø£ÙŠÙ…Ù† Ù„Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±ØŒ <b>M</b> Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ­ÙØ¸ ÙÙŠØ¯ÙŠÙˆ Ù„Ù…Ø³Ø§Ø± Ø§Ù„ØªÙƒØ¨ÙŠØ± Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
ÙŠØªÙ… ØªÙƒØ±Ø§Ø± <em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> Ù„ÙƒÙ„ <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">Ø¹Ø¯Ø¯ Ù…Ø±ÙƒØ¨</a> <em>c</em>.  ØªÙØ¸Ù‡Ø± Ø§Ù„Ø£Ù„ÙˆØ§Ù† <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª</a> Ø­ØªÙ‰ Ø§Ù„ØªØ¨Ø§Ø¹Ø¯Ø› Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø³ÙˆØ¯Ø§Ø¡ <a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">ØªØªÙ‚Ø§Ø±Ø¨ Ø£Ùˆ ØªØ¯ÙˆØ±</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„ØµÙØ±Ø§Ø¡ ØªÙØ¸Ù‡Ø± <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">Ø§Ù„Ù…Ø¯Ø§Ø±Ø§Øª</a></b>.  Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø­Ù…Ø±Ø§Ø¡ ØªÙØ¸Ù‡Ø± Ø§Ù„Ø¯ÙˆØ±Ø§Øª Ø§Ù„Ø­Ø¯ÙŠØ©.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Ø­ÙˆÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª.</b> ÙŠÙØ¸Ù‡Ø± Ù‡Ø°Ø§ Ø§Ù„Ø¹Ø§Ø±Ø¶ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† ØªÙØ§ØµÙŠÙ„ Ø§Ù„ÙƒØ³ÙŠØ±ÙŠØ§Øª Ø¨Ù…Ø±ÙˆØ± Ø§Ù„ÙˆÙ‚Øª Ù…Ù† Ø®Ù„Ø§Ù„ ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª Ø¥Ù„Ù‰ Ù…Ø§ Ù„Ø§ Ù†Ù‡Ø§ÙŠØ© Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªÙƒØ´Ø§ÙÙƒ. ÙƒÙ„Ù…Ø§ Ø§Ù†ØªØ¸Ø±Øª Ø£ÙƒØ«Ø±ØŒ ÙƒÙ„Ù…Ø§ Ø¸Ù‡Ø± Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªÙØ§ØµÙŠÙ„.
Ø¨Ø¹Ø¯ Ø¢Ù„Ø§Ù Ø£Ùˆ Ù…Ù„Ø§ÙŠÙŠÙ† Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§ØªØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ù„ Ø£Ø¯Ù‚ Ø§Ù„ØªÙØ§ØµÙŠÙ„ ÙÙŠ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø£ÙƒØ«Ø± ØªØ¹Ù‚ÙŠØ¯Ø§Ù‹ Ù…Ù† Ø§Ù„ÙƒØ³ÙŠØ±ÙŠØ©.
Ø´Ø§Ù‡Ø¯ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø­ÙˆÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø±Ø§Øª ÙˆØ§Ù„ØªÙ‚Ø¯Ù… ÙˆØ§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¹Ù† Ø·Ø±ÙŠÙ‚ <span mobile="Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰">ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù…Ø¤Ø´Ø± ÙÙˆÙ‚</span> Ø±Ù‚Ù… Ø§Ù„ØªÙƒØ¨ÙŠØ± Ø§Ù„Ø£ØµÙØ± Ø£Ø³ÙÙ„ ÙƒÙ„ Ù†Ø§ÙØ°Ø©.
<span mobile="Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø¥ØµØ¨Ø¹Ùƒ">ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù…Ø§ÙˆØ³</span> ÙÙˆÙ‚ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ÙƒØ³ÙŠØ±ÙŠØ© Ø³ÙŠÙØ­Ø±Ùƒ Ù…Ø¯Ø§Ø± Ù‚ÙŠÙ… <em>z</em> Ù„ÙƒÙ„ Ù…ÙˆÙ‚Ø¹ <em>c</em>ØŒ Ù…Ù…Ø§ ÙŠÙƒØ´Ù Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Øª Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø© Ø§Ù„ØªÙŠ ÙØªÙ†Øª Ø¹Ù„Ù…Ø§Ø¡ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Ø§Ø³ØªÙƒØ´Ø§Ù Ù…Ø³Ø§Ø± Ø§Ù„ØªÙƒØ¨ÙŠØ±.</b>
ÙƒÙ„ <span mobile="Ù†Ù‚Ø±Ø©">Ù†Ù‚Ø±Ø©</span> Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ³ÙŠØ±ÙŠØ© ØªÙØªØ­ Ù…Ø³ØªÙˆÙ‰ ØªÙƒØ¨ÙŠØ± Ø£Ø¹Ù„Ù‰ ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯ØŒ Ù…Ø­Ø³ÙˆØ¨Ø§Ù‹ Ø¹Ù„Ù‰ GPU Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ø¥Ù† ØªÙˆÙØ±.
Ø¨Ø¹Ø¯ Ø§Ù„ØªÙƒØ¨ÙŠØ± Ø¥Ù„Ù‰ Ù…Ø§ ÙŠØªØ¬Ø§ÙˆØ² ØªÙƒØ¨ÙŠØ± ØªØ±ÙŠÙ„ÙŠÙˆÙ† Ø¶Ø¹ÙØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ø¶Ø·Ø±Ø§Ø¨ Ø±Ø¨Ø§Ø¹ÙŠØ© Ø§Ù„Ø¯Ù‚Ø© ØªØ­Ù„ Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø© Ù„Ø£ÙƒØ«Ø± Ù…Ù† 30 Ø±Ù‚Ù…Ø§Ù‹ Ù…Ù† Ø§Ù„Ø¯Ù‚Ø©.
Ø¨Ù…Ø¬Ø±Ø¯ Ø£Ù† ØªØµÙ†Ø¹ Ù…Ø³Ø§Ø±Ø§Ù‹ Ù…Ø«ÙŠØ±Ø§Ù‹ ÙŠÙØ¸Ù‡Ø± Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯Ù‡Ø§ØŒ ÙŠÙ…ÙƒÙ†Ùƒ <a class="moviemode">Ø¥Ù†Ø´Ø§Ø¡ ÙˆØªÙ†Ø²ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ ØªÙƒØ¨ÙŠØ± Ø¹Ù…ÙŠÙ‚ Ù„Ù…Ø§Ù†Ø¯Ù„Ø¨Ø±ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ</a> Ø£Ùˆ ÙˆØ¶Ø¹ Ø¥Ø´Ø§Ø±Ø© Ù…Ø±Ø¬Ø¹ÙŠØ© Ø¹Ù„Ù‰ Ø¹Ù†ÙˆØ§Ù† URL Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ø­ÙØ¸ ÙˆÙ…Ø´Ø§Ø±ÙƒØ© Ø§Ø³ØªÙƒØ´Ø§ÙÙƒ.
Ù„Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ± ÙˆÙ…Ù‚Ø§Ø·Ø¹ ÙÙŠØ¯ÙŠÙˆ Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø¬ÙˆØ¯Ø©ØŒ ÙŠØ­Ø³Ø¨ Ù‡Ø°Ø§ Ø§Ù„Ø¹Ø§Ø±Ø¶ Ø§Ù„Ø¨ÙƒØ³Ù„Ø§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ© Ø¨Ù†Ø³Ø¨Ø© <span class="pixelratio">2</span>:1<span mobile="">ØŒ ÙˆÙŠÙ…ÙƒÙ† Ø²ÙŠØ§Ø¯Ø© Ø°Ù„Ùƒ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ø±ÙˆØ¶ Ø£ÙƒØ«Ø± Ø¯Ù‚Ø©</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£ÙˆØ§Ù…Ø±:</b>
<b>I</b> ÙŠÙƒØ¨Ù‘Ø±Ø›
<b mac="&#8984;">Ctrl</b>-Ù†Ù‚Ø± Ù„Ù„ØªÙƒØ¨ÙŠØ± ÙÙŠ Ø§Ù„Ù…ÙƒØ§Ù†Ø›
<b>H</b> ÙŠÙØµØºÙ‘Ø± Ùˆ<b>G</b> ÙŠÙÙƒØ¨Ù‘Ø± ÙƒÙ„ Ù†Ø§ÙØ°Ø©Ø›
<b>R</b> ÙŠÙØ¹ÙŠØ¯ ÙØªØ­ Ø§Ù„Ù†ÙˆØ§ÙØ° Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©Ø›
<b>C</b> ÙŠÙØ¹ÙŠØ¯ ØªÙˆØ³ÙŠØ· Ø§Ù„ÙƒÙ„Ø›
<b>T</b> ÙŠÙØºÙŠÙ‘Ø± Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ø£Ù„ÙˆØ§Ù†Ø›
<b>U</b> ÙŠÙØ¨Ø±Ø² Ø§Ù„Ø¨ÙƒØ³Ù„Ø§Øª ØºÙŠØ± Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©Ø›
<b mac="&#x23CE;">Enter</b> ÙŠÙØ¨Ø¯Ù‘Ù„ ÙˆØ¶Ø¹ Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©Ø›
<b>X</b> ÙŠØ²ÙŠØ¯ Ùˆ<b>Z</b> ÙŠÙ†Ù‚Øµ Ø£Ø³ <em>z</em>Ø›
<b>F</b> ÙŠØ²ÙŠØ¯ Ùˆ<b>D</b> ÙŠÙ†Ù‚Øµ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¨ÙƒØ³Ù„Ø›
<b>A</b> ÙŠØ¨Ø¯Ù‘Ù„ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¹Ø±Ø¶ Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø›
<b>M</b> ÙŠØµÙ†Ø¹ ÙÙŠØ¯ÙŠÙˆ ÙŠØªØ¨Ø¹ Ù…Ø³Ø§Ø±ÙƒØ›
<nobr><b>?</b> ÙŠÙØ¸Ù‡Ø± Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:left">
<a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> -</p>
</div>

<div lang="id" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Penjelajah Fraktal Himpunan Mandelbrot
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Ketuk">Klik</span> untuk memperbesar.</b>  <span mobile="">Klik kanan untuk menyimpan gambar, <b>M</b> untuk membuat dan menyimpan video jalur zoom Anda.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> diiterasi untuk setiap <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">bilangan kompleks</a> <em>c</em>.  Warna menunjukkan <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iterasi</a> hingga divergensi; titik hitam <a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">konvergen atau bersiklus</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Titik kuning menunjukkan <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbit</a></b>.  Titik merah menunjukkan siklus batas.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Tentang iterasi.</b> Penampil ini menunjukkan lebih banyak detail fraktal seiring waktu dengan menyempurnakan iterasi hingga tak terhingga saat Anda menjelajah. Semakin lama Anda menunggu, semakin banyak detail yang ditampilkan.
Setelah ribuan atau jutaan iterasi, Anda dapat menyelesaikan detail terbaik di bagian paling kompleks dari fraktal.
Lihat informasi tentang iterasi, kemajuan, dan koordinat dengan <span mobile="mengetuk">mengarahkan kursor ke</span> angka zoom kuning di bawah setiap jendela.
<span mobile="Menahan jari Anda">Menggerakkan mouse</span> di atas konten fraktal akan menganimasi orbit nilai <em>z</em> untuk setiap lokasi <em>c</em>, mengungkapkan dinamika batas kompleks yang telah memukau para matematikawan.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Menjelajahi jalur zoom.</b>
Setiap <span mobile="ketukan">klik</span> pada fraktal membuka level zoom yang lebih tinggi di lokasi yang dipilih, dihitung pada GPU Anda jika tersedia.
Setelah Anda memperbesar melampaui pembesaran satu triliun kali, kami menggunakan algoritma perturbasi presisi ganda empat yang menyelesaikan detail halus hingga lebih dari 30 digit akurasi.
Setelah Anda membuat jalur menarik yang menunjukkan detail yang Anda inginkan, Anda dapat <a class="moviemode">membuat dan mengunduh video zoom dalam Mandelbrot Anda sendiri</a> atau menandai URL Anda untuk menyimpan dan membagikan penjelajahan Anda.
Untuk membuat gambar dan video berkualitas tinggi, penampil ini menghitung subpiksel dengan rasio <span class="pixelratio">2</span>:1<span mobile="">, dan itu dapat ditingkatkan untuk membuat tampilan yang lebih presisi</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Perintah lainnya:</b>
<b>I</b> memperbesar;
<b mac="&#8984;">Ctrl</b>-klik untuk memperbesar di tempat;
<b>H</b> mengecilkan dan <b>G</b> memperbesar setiap jendela;
<b>R</b> membuka kembali jendela tengah;
<b>C</b> memusatkan kembali semua;
<b>T</b> mengubah tema warna;
<b>U</b> menyorot piksel yang belum selesai;
<b mac="&#x23CE;">Enter</b> mengalihkan layar penuh;
<b>X</b> meningkatkan dan <b>Z</b> menurunkan eksponen <em>z</em>;
<b>F</b> meningkatkan dan <b>D</b> menurunkan rasio piksel;
<b>A</b> mengalihkan rasio aspek;
<b>M</b> membuat video yang mengikuti jalur Anda;
<nobr><b>?</b> menampilkan bantuan ini.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<div lang="pt" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Explorador de Fractais do Conjunto de Mandelbrot
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Toque">Clique</span> para ampliar.</b>  <span mobile="">Clique com o botÃ£o direito para salvar imagens, <b>M</b> para criar e salvar um vÃ­deo do seu caminho de zoom.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> Ã© iterado para cada <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">nÃºmero complexo</a> <em>c</em>.  As cores mostram <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iteraÃ§Ãµes</a> atÃ© a divergÃªncia; pontos pretos <a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">convergem ou ciclam</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Pontos amarelos mostram <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">Ã³rbitas</a></b>.  Pontos vermelhos mostram ciclos limite.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Sobre iteraÃ§Ãµes.</b> Este visualizador mostra mais detalhes fractais ao longo do tempo, refinando iteraÃ§Ãµes ao infinito enquanto vocÃª explora. Quanto mais vocÃª espera, mais detalhes sÃ£o mostrados.
ApÃ³s milhares ou milhÃµes de iteraÃ§Ãµes, vocÃª pode resolver os detalhes mais finos nas partes mais complexas do fractal.
Veja informaÃ§Ãµes sobre iteraÃ§Ãµes, progresso e coordenadas <span mobile="tocando">passando o mouse sobre</span> o nÃºmero amarelo de zoom sob cada janela.
<span mobile="Mantendo seu dedo">Mover o mouse</span> sobre o conteÃºdo fractal animarÃ¡ a Ã³rbita dos valores <em>z</em> para cada localizaÃ§Ã£o <em>c</em>, revelando a complexa dinÃ¢mica de fronteira que fascinou matemÃ¡ticos.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Explorando um caminho de zoom.</b>
Cada <span mobile="toque">clique</span> no fractal abre um nÃ­vel de zoom mais alto no local selecionado, calculado na sua GPU se disponÃ­vel.
ApÃ³s ampliar alÃ©m de uma magnificaÃ§Ã£o de um trilhÃ£o de vezes, usamos um algoritmo de perturbaÃ§Ã£o de precisÃ£o quÃ¡drupla que resolve detalhes finos com mais de 30 dÃ­gitos de precisÃ£o.
Depois de criar um caminho interessante que mostra os detalhes que vocÃª deseja, vocÃª pode <a class="moviemode">criar e baixar seu prÃ³prio vÃ­deo de zoom profundo de Mandelbrot</a> ou marcar sua URL para salvar e compartilhar sua exploraÃ§Ã£o.
Para criar imagens e vÃ­deos de alta qualidade, este visualizador calcula subpixels com uma proporÃ§Ã£o de <span class="pixelratio">2</span>:1<span mobile="">, e isso pode ser aumentado para criar exibiÃ§Ãµes mais precisas</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Mais comandos:</b>
<b>I</b> amplia;
<b mac="&#8984;">Ctrl</b>-clique para ampliar no local;
<b>H</b> encolhe e <b>G</b> aumenta cada janela;
<b>R</b> reabre janelas intermediÃ¡rias;
<b>C</b> recentraliza todas;
<b>T</b> muda o tema de cores;
<b>U</b> destaca pixels inacabados;
<b mac="&#x23CE;">Enter</b> alterna tela cheia;
<b>X</b> aumenta e <b>Z</b> diminui o expoente de <em>z</em>;
<b>F</b> aumenta e <b>D</b> diminui a proporÃ§Ã£o de pixels;
<b>A</b> alterna proporÃ§Ã£o de tela;
<b>M</b> cria um vÃ­deo que segue seu caminho;
<nobr><b>?</b> mostra esta ajuda.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<div lang="fr" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Explorateur de Fractales de l'Ensemble de Mandelbrot
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Appuyez">Cliquez</span> pour zoomer.</b>  <span mobile="">Cliquez avec le bouton droit pour enregistrer les images, <b>M</b> pour crÃ©er et enregistrer une vidÃ©o de votre parcours de zoom.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> est itÃ©rÃ© pour chaque <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">nombre complexe</a> <em>c</em>.  Les couleurs montrent les <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">itÃ©rations</a> jusqu'Ã  la divergence ; les points noirs <a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">convergent ou cyclent</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Les points jaunes montrent les <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbites</a></b>.  Les points rouges montrent les cycles limites.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Ã€ propos des itÃ©rations.</b> Ce visualiseur montre plus de dÃ©tails fractals au fil du temps en affinant les itÃ©rations vers l'infini pendant votre exploration. Plus vous attendez, plus de dÃ©tails sont affichÃ©s.
AprÃ¨s des milliers ou des millions d'itÃ©rations, vous pouvez rÃ©soudre les dÃ©tails les plus fins dans les parties les plus complexes de la fractale.
Consultez les informations sur les itÃ©rations, la progression et les coordonnÃ©es en <span mobile="appuyant sur">passant la souris sur</span> le numÃ©ro de zoom jaune sous chaque fenÃªtre.
<span mobile="En maintenant votre doigt">DÃ©placer votre souris</span> sur le contenu fractal animera l'orbite des valeurs <em>z</em> pour chaque emplacement <em>c</em>, rÃ©vÃ©lant la dynamique de frontiÃ¨re complexe qui a fascinÃ© les mathÃ©maticiens.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Explorer un parcours de zoom.</b>
Chaque <span mobile="appui">clic</span> sur la fractale ouvre un niveau de zoom supÃ©rieur Ã  l'emplacement sÃ©lectionnÃ©, calculÃ© sur votre GPU si disponible.
AprÃ¨s avoir zoomÃ© au-delÃ  d'un grossissement de mille milliards de fois, nous utilisons un algorithme de perturbation en quadruple prÃ©cision qui rÃ©sout les dÃ©tails fins avec plus de 30 chiffres de prÃ©cision.
Une fois que vous avez crÃ©Ã© un parcours intÃ©ressant qui montre les dÃ©tails que vous souhaitez, vous pouvez <a class="moviemode">crÃ©er et tÃ©lÃ©charger votre propre vidÃ©o de zoom profond de Mandelbrot</a> ou mettre en signet votre URL pour sauvegarder et partager votre exploration.
Pour crÃ©er des images et des vidÃ©os de haute qualitÃ©, ce visualiseur calcule les sous-pixels avec un rapport de <span class="pixelratio">2</span>:1<span mobile="">, et cela peut Ãªtre augmentÃ© pour crÃ©er des affichages plus prÃ©cis</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Plus de commandes :</b>
<b>I</b> zoom avant ;
<b mac="&#8984;">Ctrl</b>-clic pour zoomer sur place ;
<b>H</b> rÃ©trÃ©cit et <b>G</b> agrandit chaque fenÃªtre ;
<b>R</b> rouvre les fenÃªtres intermÃ©diaires ;
<b>C</b> recentre toutes ;
<b>T</b> change le thÃ¨me de couleur ;
<b>U</b> met en Ã©vidence les pixels inachevÃ©s ;
<b mac="&#x23CE;">EntrÃ©e</b> bascule en plein Ã©cran ;
<b>X</b> augmente et <b>Z</b> diminue l'exposant de <em>z</em> ;
<b>F</b> augmente et <b>D</b> diminue le rapport de pixels ;
<b>A</b> bascule le rapport d'aspect ;
<b>M</b> crÃ©e une vidÃ©o qui suit votre parcours ;
<nobr><b>?</b> affiche cette aide.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<div lang="ja" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
ãƒžãƒ³ãƒ‡ãƒ«ãƒ–ãƒ­é›†åˆãƒ•ãƒ©ã‚¯ã‚¿ãƒ«æŽ¢ç´¢ãƒ„ãƒ¼ãƒ«
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="ã‚¿ãƒƒãƒ—">ã‚¯ãƒªãƒƒã‚¯</span>ã—ã¦ã‚ºãƒ¼ãƒ ã€‚</b>  <span mobile="">å³ã‚¯ãƒªãƒƒã‚¯ã§ç”»åƒã‚’ä¿å­˜ã€<b>M</b>ã§ã‚ºãƒ¼ãƒ ãƒ‘ã‚¹ã®å‹•ç”»ã‚’ä½œæˆãƒ»ä¿å­˜ã§ãã¾ã™ã€‚</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
å„<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">è¤‡ç´ æ•°</a> <em>c</em> ã«å¯¾ã—ã¦ <em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> ãŒåå¾©ã•ã‚Œã¾ã™ã€‚è‰²ã¯ç™ºæ•£ã¾ã§ã®<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">åå¾©å›žæ•°</a>ã‚’ç¤ºã—ã€é»’ã„ç‚¹ã¯<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">åŽæŸã¾ãŸã¯å‘¨æœŸçš„</a>ã§ã™ã€‚
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>é»„è‰²ã®ç‚¹ã¯<a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">è»Œé“</a>ã‚’ç¤ºã—ã¾ã™</b>ã€‚èµ¤ã„ç‚¹ã¯æ¥µé™å‘¨æœŸã‚’ç¤ºã—ã¾ã™ã€‚
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>åå¾©ã«ã¤ã„ã¦ã€‚</b>ã“ã®ãƒ“ãƒ¥ãƒ¼ã‚¢ã¯ã€æŽ¢ç´¢ä¸­ã«åå¾©ã‚’ç„¡é™å¤§ã¾ã§ç²¾ç·»åŒ–ã™ã‚‹ã“ã¨ã§ã€æ™‚é–“ã¨ã¨ã‚‚ã«ã‚ˆã‚Šå¤šãã®ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«ã®è©³ç´°ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚å¾…ã¤ã»ã©ã€ã‚ˆã‚Šå¤šãã®è©³ç´°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
æ•°åƒã¾ãŸã¯æ•°ç™¾ä¸‡å›žã®åå¾©ã®å¾Œã€ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«ã®æœ€ã‚‚è¤‡é›‘ãªéƒ¨åˆ†ã§æœ€ã‚‚ç´°ã‹ã„è©³ç´°ã‚’è§£åƒã§ãã¾ã™ã€‚
å„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä¸‹ã®é»„è‰²ã®ã‚ºãƒ¼ãƒ ç•ªå·ã‚’<span mobile="ã‚¿ãƒƒãƒ—">ãƒžã‚¦ã‚¹ã‚ªãƒ¼ãƒãƒ¼</span>ã™ã‚‹ã“ã¨ã§ã€åå¾©ã€é€²è¡ŒçŠ¶æ³ã€åº§æ¨™ã«é–¢ã™ã‚‹æƒ…å ±ã‚’ç¢ºèªã§ãã¾ã™ã€‚
ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä¸Šã§<span mobile="æŒ‡ã‚’ä¿æŒ">ãƒžã‚¦ã‚¹ã‚’ç§»å‹•</span>ã™ã‚‹ã¨ã€å„ä½ç½® <em>c</em> ã® <em>z</em> å€¤ã®è»Œé“ãŒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŒ–ã•ã‚Œã€æ•°å­¦è€…ã‚’é­…äº†ã—ã¦ããŸè¤‡é›‘ãªå¢ƒç•Œãƒ€ã‚¤ãƒŠãƒŸã‚¯ã‚¹ãŒæ˜Žã‚‰ã‹ã«ãªã‚Šã¾ã™ã€‚
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>ã‚ºãƒ¼ãƒ ãƒ‘ã‚¹ã®æŽ¢ç´¢ã€‚</b>
ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«ä¸Šã®å„<span mobile="ã‚¿ãƒƒãƒ—">ã‚¯ãƒªãƒƒã‚¯</span>ã¯ã€é¸æŠžã—ãŸå ´æ‰€ã§ã‚ˆã‚Šé«˜ã„ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’é–‹ãã€å¯èƒ½ã§ã‚ã‚Œã°GPUä¸Šã§è¨ˆç®—ã•ã‚Œã¾ã™ã€‚
1å…†å€ã‚’è¶…ãˆã‚‹å€çŽ‡ã¾ã§ã‚ºãƒ¼ãƒ ã™ã‚‹ã¨ã€30æ¡ä»¥ä¸Šã®ç²¾åº¦ã§ç´°ã‹ã„è©³ç´°ã‚’è§£æ±ºã™ã‚‹4å€ç²¾åº¦æ‘‚å‹•ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
å¿…è¦ãªè©³ç´°ã‚’ç¤ºã™èˆˆå‘³æ·±ã„ãƒ‘ã‚¹ã‚’ä½œæˆã—ãŸã‚‰ã€<a class="moviemode">ç‹¬è‡ªã®ãƒžãƒ³ãƒ‡ãƒ«ãƒ–ãƒ­ãƒ‡ã‚£ãƒ¼ãƒ—ã‚ºãƒ¼ãƒ å‹•ç”»ã‚’ä½œæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</a>ã—ãŸã‚Šã€URLã‚’ãƒ–ãƒƒã‚¯ãƒžãƒ¼ã‚¯ã—ã¦æŽ¢ç´¢ã‚’ä¿å­˜ãƒ»å…±æœ‰ã—ãŸã‚Šã§ãã¾ã™ã€‚
é«˜å“è³ªã®ç”»åƒã¨å‹•ç”»ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ã€ã“ã®ãƒ“ãƒ¥ãƒ¼ã‚¢ã¯<span class="pixelratio">2</span>:1ã®æ¯”çŽ‡ã§ã‚µãƒ–ãƒ”ã‚¯ã‚»ãƒ«ã‚’è¨ˆç®—ã—<span mobile="">ã€ã‚ˆã‚Šæ­£ç¢ºãªè¡¨ç¤ºã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ã“ã‚Œã‚’å¢—ã‚„ã™ã“ã¨ãŒã§ãã¾ã™</span>ã€‚
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>ãã®ä»–ã®ã‚³ãƒžãƒ³ãƒ‰ï¼š</b>
<b>I</b> ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ï¼›
<b mac="&#8984;">Ctrl</b>-ã‚¯ãƒªãƒƒã‚¯ã§ãã®å ´ã§ã‚ºãƒ¼ãƒ ï¼›
<b>H</b> ã§ç¸®å°ã€<b>G</b> ã§å„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æ‹¡å¤§ï¼›
<b>R</b> ä¸­é–“ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’å†åº¦é–‹ãï¼›
<b>C</b> ã™ã¹ã¦ã‚’å†ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°ï¼›
<b>T</b> ã‚«ãƒ©ãƒ¼ãƒ†ãƒ¼ãƒžã‚’å¤‰æ›´ï¼›
<b>U</b> æœªå®Œäº†ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼›
<b mac="&#x23CE;">Enter</b> ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚’åˆ‡ã‚Šæ›¿ãˆï¼›
<b>X</b> ã§å¢—åŠ ã€<b>Z</b> ã§ <em>z</em> æŒ‡æ•°ã‚’æ¸›å°‘ï¼›
<b>F</b> ã§å¢—åŠ ã€<b>D</b> ã§ãƒ”ã‚¯ã‚»ãƒ«æ¯”çŽ‡ã‚’æ¸›å°‘ï¼›
<b>A</b> ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’åˆ‡ã‚Šæ›¿ãˆï¼›
<b>M</b> ãƒ‘ã‚¹ã«å¾“ã†å‹•ç”»ã‚’ä½œæˆï¼›
<nobr><b>?</b> ã“ã®ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã€‚</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<div lang="ru" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Ð˜ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ñ„Ñ€Ð°ÐºÑ‚Ð°Ð»Ð¾Ð² Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð° ÐœÐ°Ð½Ð´ÐµÐ»ÑŒÐ±Ñ€Ð¾Ñ‚Ð°
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ">Ð©ÐµÐ»ÐºÐ½Ð¸Ñ‚Ðµ</span>, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ñ‚ÑŒ.</b>  <span mobile="">Ð©ÐµÐ»ÐºÐ½Ð¸Ñ‚Ðµ Ð¿Ñ€Ð°Ð²Ð¾Ð¹ ÐºÐ½Ð¾Ð¿ÐºÐ¾Ð¹ Ð¼Ñ‹ÑˆÐ¸, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ, <b>M</b>, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð²Ð¸Ð´ÐµÐ¾ Ð²Ð°ÑˆÐµÐ³Ð¾ Ð¿ÑƒÑ‚Ð¸ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ñ.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> Ð¸Ñ‚ÐµÑ€Ð¸Ñ€ÑƒÐµÑ‚ÑÑ Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">ÐºÐ¾Ð¼Ð¿Ð»ÐµÐºÑÐ½Ð¾Ð³Ð¾ Ñ‡Ð¸ÑÐ»Ð°</a> <em>c</em>.  Ð¦Ð²ÐµÑ‚Ð° Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÑŽÑ‚ <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸Ð¸</a> Ð´Ð¾ Ñ€Ð°ÑÑ…Ð¾Ð¶Ð´ÐµÐ½Ð¸Ñ; Ñ‡ÐµÑ€Ð½Ñ‹Ðµ Ñ‚Ð¾Ñ‡ÐºÐ¸ <a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">ÑÑ…Ð¾Ð´ÑÑ‚ÑÑ Ð¸Ð»Ð¸ Ñ†Ð¸ÐºÐ»Ð¸Ñ€ÑƒÑŽÑ‚ÑÑ</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Ð–ÐµÐ»Ñ‚Ñ‹Ðµ Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÑŽÑ‚ <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">Ð¾Ñ€Ð±Ð¸Ñ‚Ñ‹</a></b>.  ÐšÑ€Ð°ÑÐ½Ñ‹Ðµ Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÑŽÑ‚ Ð¿Ñ€ÐµÐ´ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ñ†Ð¸ÐºÐ»Ñ‹.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>ÐžÐ± Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸ÑÑ….</b> Ð­Ñ‚Ð¾Ñ‚ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ñ‰Ð¸Ðº Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹ Ñ„Ñ€Ð°ÐºÑ‚Ð°Ð»Ð¾Ð² Ñ Ñ‚ÐµÑ‡ÐµÐ½Ð¸ÐµÐ¼ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸, ÑƒÑ‚Ð¾Ñ‡Ð½ÑÑ Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð´Ð¾ Ð±ÐµÑÐºÐ¾Ð½ÐµÑ‡Ð½Ð¾ÑÑ‚Ð¸ Ð¿Ð¾ Ð¼ÐµÑ€Ðµ Ð²Ð°ÑˆÐµÐ³Ð¾ Ð¸ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ñ. Ð§ÐµÐ¼ Ð´Ð¾Ð»ÑŒÑˆÐµ Ð²Ñ‹ Ð¶Ð´ÐµÑ‚Ðµ, Ñ‚ÐµÐ¼ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÑ‚ÑÑ.
ÐŸÐ¾ÑÐ»Ðµ Ñ‚Ñ‹ÑÑÑ‡ Ð¸Ð»Ð¸ Ð¼Ð¸Ð»Ð»Ð¸Ð¾Ð½Ð¾Ð² Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸Ð¹ Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ñ€Ð°Ð·Ñ€ÐµÑˆÐ¸Ñ‚ÑŒ Ð¼ÐµÐ»ÑŒÑ‡Ð°Ð¹ÑˆÐ¸Ðµ Ð´ÐµÑ‚Ð°Ð»Ð¸ Ð² ÑÐ°Ð¼Ñ‹Ñ… ÑÐ»Ð¾Ð¶Ð½Ñ‹Ñ… Ñ‡Ð°ÑÑ‚ÑÑ… Ñ„Ñ€Ð°ÐºÑ‚Ð°Ð»Ð°.
ÐŸÑ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ñ‚Ðµ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾Ð± Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸ÑÑ…, Ð¿Ñ€Ð¾Ð³Ñ€ÐµÑÑÐµ Ð¸ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ð°Ñ…, <span mobile="Ð½Ð°Ð¶Ð°Ð² Ð½Ð°">Ð½Ð°Ð²ÐµÐ´Ñ ÐºÑƒÑ€ÑÐ¾Ñ€ Ð½Ð°</span> Ð¶ÐµÐ»Ñ‚Ñ‹Ð¹ Ð½Ð¾Ð¼ÐµÑ€ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð´ ÐºÐ°Ð¶Ð´Ñ‹Ð¼ Ð¾ÐºÐ½Ð¾Ð¼.
<span mobile="Ð£Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°Ñ Ð¿Ð°Ð»ÐµÑ†">ÐŸÐµÑ€ÐµÐ¼ÐµÑ‰ÐµÐ½Ð¸Ðµ Ð¼Ñ‹ÑˆÐ¸</span> Ð½Ð°Ð´ Ñ„Ñ€Ð°ÐºÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ð¼ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ñ‹Ð¼ Ð°Ð½Ð¸Ð¼Ð¸Ñ€ÑƒÐµÑ‚ Ð¾Ñ€Ð±Ð¸Ñ‚Ñƒ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ <em>z</em> Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð¼ÐµÑÑ‚Ð¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ <em>c</em>, Ñ€Ð°ÑÐºÑ€Ñ‹Ð²Ð°Ñ ÑÐ»Ð¾Ð¶Ð½ÑƒÑŽ Ð´Ð¸Ð½Ð°Ð¼Ð¸ÐºÑƒ Ð³Ñ€Ð°Ð½Ð¸Ñ†, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð²Ð¾ÑÑ…Ð¸Ñ‰Ð°Ð»Ð° Ð¼Ð°Ñ‚ÐµÐ¼Ð°Ñ‚Ð¸ÐºÐ¾Ð².
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Ð˜ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿ÑƒÑ‚Ð¸ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ñ.</b>
ÐšÐ°Ð¶Ð´Ñ‹Ð¹ <span mobile="Ð½Ð°Ð¶Ð°Ñ‚Ð¸Ðµ">Ñ‰ÐµÐ»Ñ‡Ð¾Ðº</span> Ð½Ð° Ñ„Ñ€Ð°ÐºÑ‚Ð°Ð»Ðµ Ð¾Ñ‚ÐºÑ€Ñ‹Ð²Ð°ÐµÑ‚ Ð±Ð¾Ð»ÐµÐµ Ð²Ñ‹ÑÐ¾ÐºÐ¸Ð¹ ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ñ Ð² Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ð¾Ð¼ Ð¼ÐµÑÑ‚Ðµ, Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÑÐµÐ¼Ñ‹Ð¹ Ð½Ð° Ð²Ð°ÑˆÐµÐ¼ GPU, ÐµÑÐ»Ð¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾.
ÐŸÐ¾ÑÐ»Ðµ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ñ Ð±Ð¾Ð»ÐµÐµ Ñ‡ÐµÐ¼ Ð² Ñ‚Ñ€Ð¸Ð»Ð»Ð¸Ð¾Ð½ Ñ€Ð°Ð· Ð¼Ñ‹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼ Ð²Ð¾Ð·Ð¼ÑƒÑ‰ÐµÐ½Ð¸Ñ Ñ Ñ‡ÐµÑ‚Ð²ÐµÑ€Ð½Ð¾Ð¹ Ñ‚Ð¾Ñ‡Ð½Ð¾ÑÑ‚ÑŒÑŽ, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ñ€Ð°Ð·Ñ€ÐµÑˆÐ°ÐµÑ‚ Ð¼ÐµÐ»ÐºÐ¸Ðµ Ð´ÐµÑ‚Ð°Ð»Ð¸ Ñ Ñ‚Ð¾Ñ‡Ð½Ð¾ÑÑ‚ÑŒÑŽ Ð±Ð¾Ð»ÐµÐµ 30 Ñ†Ð¸Ñ„Ñ€.
ÐšÐ°Ðº Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð²Ñ‹ ÑÐ¾Ð·Ð´Ð°Ð´Ð¸Ñ‚Ðµ Ð¸Ð½Ñ‚ÐµÑ€ÐµÑÐ½Ñ‹Ð¹ Ð¿ÑƒÑ‚ÑŒ, Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÑŽÑ‰Ð¸Ð¹ Ð½ÑƒÐ¶Ð½Ñ‹Ðµ Ð²Ð°Ð¼ Ð´ÐµÑ‚Ð°Ð»Ð¸, Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ <a class="moviemode">ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ ÑÐ¾Ð±ÑÑ‚Ð²ÐµÐ½Ð½Ð¾Ðµ Ð²Ð¸Ð´ÐµÐ¾ Ð³Ð»ÑƒÐ±Ð¾ÐºÐ¾Ð³Ð¾ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ñ ÐœÐ°Ð½Ð´ÐµÐ»ÑŒÐ±Ñ€Ð¾Ñ‚Ð°</a> Ð¸Ð»Ð¸ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð·Ð°ÐºÐ»Ð°Ð´ÐºÑƒ Ð½Ð° Ð²Ð°Ñˆ URL, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð¸ Ð¿Ð¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ ÑÐ²Ð¾Ð¸Ð¼ Ð¸ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼.
Ð”Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð²Ñ‹ÑÐ¾ÐºÐ¾ÐºÐ°Ñ‡ÐµÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ñ… Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¹ Ð¸ Ð²Ð¸Ð´ÐµÐ¾ ÑÑ‚Ð¾Ñ‚ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ñ‰Ð¸Ðº Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÑÐµÑ‚ ÑÑƒÐ±Ð¿Ð¸ÐºÑÐµÐ»Ð¸ Ñ ÑÐ¾Ð¾Ñ‚Ð½Ð¾ÑˆÐµÐ½Ð¸ÐµÐ¼ <span class="pixelratio">2</span>:1<span mobile="">, Ð¸ ÑÑ‚Ð¾ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¾ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð±Ð¾Ð»ÐµÐµ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ñ… Ð´Ð¸ÑÐ¿Ð»ÐµÐµÐ²</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹:</b>
<b>I</b> ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ð²Ð°ÐµÑ‚;
<b mac="&#8984;">Ctrl</b>-Ñ‰ÐµÐ»Ñ‡Ð¾Ðº Ð´Ð»Ñ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ñ Ð½Ð° Ð¼ÐµÑÑ‚Ðµ;
<b>H</b> ÑƒÐ¼ÐµÐ½ÑŒÑˆÐ°ÐµÑ‚, Ð° <b>G</b> ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ð²Ð°ÐµÑ‚ ÐºÐ°Ð¶Ð´Ð¾Ðµ Ð¾ÐºÐ½Ð¾;
<b>R</b> Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð½Ð¾ Ð¾Ñ‚ÐºÑ€Ñ‹Ð²Ð°ÐµÑ‚ Ð¿Ñ€Ð¾Ð¼ÐµÐ¶ÑƒÑ‚Ð¾Ñ‡Ð½Ñ‹Ðµ Ð¾ÐºÐ½Ð°;
<b>C</b> Ð¿ÐµÑ€ÐµÑ†ÐµÐ½Ñ‚Ñ€Ð¸Ñ€ÑƒÐµÑ‚ Ð²ÑÐµ;
<b>T</b> Ð¼ÐµÐ½ÑÐµÑ‚ Ñ†Ð²ÐµÑ‚Ð¾Ð²ÑƒÑŽ Ñ‚ÐµÐ¼Ñƒ;
<b>U</b> Ð²Ñ‹Ð´ÐµÐ»ÑÐµÑ‚ Ð½ÐµÐ·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð½Ñ‹Ðµ Ð¿Ð¸ÐºÑÐµÐ»Ð¸;
<b mac="&#x23CE;">Enter</b> Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ Ð¿Ð¾Ð»Ð½Ð¾ÑÐºÑ€Ð°Ð½Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼;
<b>X</b> ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ð²Ð°ÐµÑ‚, Ð° <b>Z</b> ÑƒÐ¼ÐµÐ½ÑŒÑˆÐ°ÐµÑ‚ Ð¿Ð¾ÐºÐ°Ð·Ð°Ñ‚ÐµÐ»ÑŒ ÑÑ‚ÐµÐ¿ÐµÐ½Ð¸ <em>z</em>;
<b>F</b> ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ð²Ð°ÐµÑ‚, Ð° <b>D</b> ÑƒÐ¼ÐµÐ½ÑŒÑˆÐ°ÐµÑ‚ ÑÐ¾Ð¾Ñ‚Ð½Ð¾ÑˆÐµÐ½Ð¸Ðµ Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹;
<b>A</b> Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ ÑÐ¾Ð¾Ñ‚Ð½Ð¾ÑˆÐµÐ½Ð¸Ðµ ÑÑ‚Ð¾Ñ€Ð¾Ð½;
<b>M</b> ÑÐ¾Ð·Ð´Ð°ÐµÑ‚ Ð²Ð¸Ð´ÐµÐ¾, ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐµ Ð²Ð°ÑˆÐµÐ¼Ñƒ Ð¿ÑƒÑ‚Ð¸;
<nobr><b>?</b> Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ ÑÑ‚Ñƒ ÑÐ¿Ñ€Ð°Ð²ÐºÑƒ.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<div lang="de" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Mandelbrot-Menge Fraktal-Explorer
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Tippen">Klicken</span> Sie zum VergrÃ¶ÃŸern.</b>  <span mobile="">Rechtsklick zum Speichern von Bildern, <b>M</b> zum Erstellen und Speichern eines Videos Ihres Zoom-Pfads.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> wird fÃ¼r jede <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">komplexe Zahl</a> <em>c</em> iteriert.  Farben zeigen <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">Iterationen</a> bis zur Divergenz; schwarze Punkte <a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">konvergieren oder zyklieren</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Gelbe Punkte zeigen <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">Bahnen</a></b>.  Rote Punkte zeigen Grenzzyklen.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Ãœber Iterationen.</b> Dieser Viewer zeigt im Laufe der Zeit mehr fraktale Details, indem er die Iterationen wÃ¤hrend Ihrer Erkundung gegen unendlich verfeinert. Je lÃ¤nger Sie warten, desto mehr Details werden angezeigt.
Nach Tausenden oder Millionen von Iterationen kÃ¶nnen Sie die feinsten Details in den komplexesten Teilen des Fraktals auflÃ¶sen.
Sehen Sie Informationen zu Iterationen, Fortschritt und Koordinaten, indem Sie <span mobile="tippen">mit der Maus Ã¼ber</span> die gelbe Zoom-Nummer unter jedem Fenster fahren.
<span mobile="Halten Sie Ihren Finger">Bewegen Sie Ihre Maus</span> Ã¼ber fraktale Inhalte, um die Bahn der <em>z</em>-Werte fÃ¼r jeden Ort <em>c</em> zu animieren und die komplexe Randdynamik zu enthÃ¼llen, die Mathematiker fasziniert hat.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Einen Zoom-Pfad erkunden.</b>
Jeder <span mobile="Tipp">Klick</span> auf das Fraktal Ã¶ffnet eine hÃ¶here Zoomstufe an der ausgewÃ¤hlten Stelle, berechnet auf Ihrer GPU, falls verfÃ¼gbar.
Nachdem Sie Ã¼ber eine billionenfache VergrÃ¶ÃŸerung hinaus gezoomt haben, verwenden wir einen StÃ¶rungsalgorithmus mit vierfacher Genauigkeit, der feine Details mit mehr als 30 Ziffern Genauigkeit auflÃ¶st.
Sobald Sie einen interessanten Pfad erstellt haben, der die gewÃ¼nschten Details zeigt, kÃ¶nnen Sie <a class="moviemode">Ihr eigenes Mandelbrot-Deep-Zoom-Video erstellen und herunterladen</a> oder Ihre URL als Lesezeichen setzen, um Ihre Erkundung zu speichern und zu teilen.
Um qualitativ hochwertige Bilder und Videos zu erstellen, berechnet dieser Viewer Subpixel mit einem VerhÃ¤ltnis von <span class="pixelratio">2</span>:1<span mobile="">, und dies kann erhÃ¶ht werden, um prÃ¤zisere Anzeigen zu erstellen</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Weitere Befehle:</b>
<b>I</b> zoomt hinein;
<b mac="&#8984;">Strg</b>-Klick zum direkten Zoomen;
<b>H</b> verkleinert und <b>G</b> vergrÃ¶ÃŸert jedes Fenster;
<b>R</b> Ã¶ffnet Zwischenfenster erneut;
<b>C</b> zentriert alle neu;
<b>T</b> Ã¤ndert das Farbschema;
<b>U</b> hebt unfertige Pixel hervor;
<b mac="&#x23CE;">Enter</b> schaltet Vollbild um;
<b>X</b> erhÃ¶ht und <b>Z</b> verringert den <em>z</em>-Exponenten;
<b>F</b> erhÃ¶ht und <b>D</b> verringert das PixelverhÃ¤ltnis;
<b>A</b> schaltet SeitenverhÃ¤ltnis um;
<b>M</b> erstellt ein Video, das Ihrem Pfad folgt;
<nobr><b>?</b> zeigt diese Hilfe.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a></p>
</div>

<script>
// Internationalization Messages
const Messages = {
  en: {
    center_at_: 'center at ',
    percent_done_after_: '% done after ',
    iters: ' iters',
    pre_rendering_movie: 'Pre-rendering movie...',
    pre_rendering_: 'Pre-rendering ',
    diverges_in_: '\ndiverges in ',
    converges_after_: '\nconverges after ',
    after_: '\nafter ',
    period_: ', period '
  },
  es: {
    center_at_: 'centro en ',
    percent_done_after_: '% completado despuÃ©s de ',
    iters: ' iteraciones',
    pre_rendering_movie: 'Pre-renderizando video...',
    pre_rendering_: 'Pre-renderizando ',
    diverges_in_: '\ndiverge en ',
    converges_after_: '\nconverge despuÃ©s de ',
    after_: '\ndespuÃ©s de ',
    period_: ', perÃ­odo '
  },
  zh: {
    center_at_: 'ä¸­å¿ƒä½äºŽ ',
    percent_done_after_: '% å®Œæˆï¼Œå·²è¿­ä»£ ',
    iters: ' æ¬¡',
    pre_rendering_movie: 'æ­£åœ¨é¢„æ¸²æŸ“è§†é¢‘...',
    pre_rendering_: 'æ­£åœ¨é¢„æ¸²æŸ“ ',
    diverges_in_: '\nåœ¨ ',
    converges_after_: '\nåœ¨ ',
    after_: '\nåœ¨ ',
    period_: ' åŽå‘æ•£ï¼Œå‘¨æœŸ '
  },
  'zh-TW': {
    center_at_: 'ä¸­å¿ƒä½æ–¼ ',
    percent_done_after_: '% å®Œæˆï¼Œå·²è¿­ä»£ ',
    iters: ' æ¬¡',
    pre_rendering_movie: 'æ­£åœ¨é æ¸²æŸ“å½±ç‰‡...',
    pre_rendering_: 'æ­£åœ¨é æ¸²æŸ“ ',
    diverges_in_: '\nåœ¨ ',
    converges_after_: '\nåœ¨ ',
    after_: '\nåœ¨ ',
    period_: ' å¾Œç™¼æ•£ï¼Œé€±æœŸ '
  },
  ar: {
    center_at_: 'Ø§Ù„Ù…Ø±ÙƒØ² ÙÙŠ ',
    percent_done_after_: '% Ù…ÙƒØªÙ…Ù„ Ø¨Ø¹Ø¯ ',
    iters: ' ØªÙƒØ±Ø§Ø±',
    pre_rendering_movie: 'Ø¬Ø§Ø±Ù Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³Ø¨Ù‚ Ù„Ù„ÙÙŠØ¯ÙŠÙˆ...',
    pre_rendering_: 'Ø¬Ø§Ø±Ù Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³Ø¨Ù‚ ',
    diverges_in_: '\nÙŠØªØ¨Ø§Ø¹Ø¯ ÙÙŠ ',
    converges_after_: '\nÙŠØªÙ‚Ø§Ø±Ø¨ Ø¨Ø¹Ø¯ ',
    after_: '\nØ¨Ø¹Ø¯ ',
    period_: 'ØŒ Ø§Ù„ÙØªØ±Ø© '
  },
  id: {
    center_at_: 'pusat di ',
    percent_done_after_: '% selesai setelah ',
    iters: ' iterasi',
    pre_rendering_movie: 'Pra-rendering video...',
    pre_rendering_: 'Pra-rendering ',
    diverges_in_: '\ndivergen dalam ',
    converges_after_: '\nkonvergen setelah ',
    after_: '\nsetelah ',
    period_: ', periode '
  },
  pt: {
    center_at_: 'centro em ',
    percent_done_after_: '% concluÃ­do apÃ³s ',
    iters: ' iteraÃ§Ãµes',
    pre_rendering_movie: 'PrÃ©-renderizando vÃ­deo...',
    pre_rendering_: 'PrÃ©-renderizando ',
    diverges_in_: '\ndiverge em ',
    converges_after_: '\nconverge apÃ³s ',
    after_: '\napÃ³s ',
    period_: ', perÃ­odo '
  },
  fr: {
    center_at_: 'centre Ã  ',
    percent_done_after_: '% terminÃ© aprÃ¨s ',
    iters: ' itÃ©rations',
    pre_rendering_movie: 'PrÃ©-rendu de la vidÃ©o...',
    pre_rendering_: 'PrÃ©-rendu ',
    diverges_in_: '\ndiverge en ',
    converges_after_: '\nconverge aprÃ¨s ',
    after_: '\naprÃ¨s ',
    period_: ', pÃ©riode '
  },
  ja: {
    center_at_: 'ä¸­å¿ƒ: ',
    percent_done_after_: '% å®Œäº†ã€',
    iters: ' å›žåå¾©',
    pre_rendering_movie: 'å‹•ç”»ã‚’ãƒ—ãƒ¬ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­...',
    pre_rendering_: 'ãƒ—ãƒ¬ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¸­ ',
    diverges_in_: '\n',
    converges_after_: '\n',
    after_: '\n',
    period_: ' å›žåå¾©å¾Œã«ç™ºæ•£ã€å‘¨æœŸ '
  },
  ru: {
    center_at_: 'Ñ†ÐµÐ½Ñ‚Ñ€ Ð² ',
    percent_done_after_: '% Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¾ Ð¿Ð¾ÑÐ»Ðµ ',
    iters: ' Ð¸Ñ‚ÐµÑ€Ð°Ñ†Ð¸Ð¹',
    pre_rendering_movie: 'ÐŸÑ€ÐµÐ´Ð²Ð°Ñ€Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ½Ð´ÐµÑ€Ð¸Ð½Ð³ Ð²Ð¸Ð´ÐµÐ¾...',
    pre_rendering_: 'ÐŸÑ€ÐµÐ´Ð²Ð°Ñ€Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ€ÐµÐ½Ð´ÐµÑ€Ð¸Ð½Ð³ ',
    diverges_in_: '\nÑ€Ð°ÑÑ…Ð¾Ð´Ð¸Ñ‚ÑÑ Ð·Ð° ',
    converges_after_: '\nÑÑ…Ð¾Ð´Ð¸Ñ‚ÑÑ Ð¿Ð¾ÑÐ»Ðµ ',
    after_: '\nÐ¿Ð¾ÑÐ»Ðµ ',
    period_: ', Ð¿ÐµÑ€Ð¸Ð¾Ð´ '
  },
  de: {
    center_at_: 'Zentrum bei ',
    percent_done_after_: '% abgeschlossen nach ',
    iters: ' Iterationen',
    pre_rendering_movie: 'Video wird vorgerendert...',
    pre_rendering_: 'Vorrendering ',
    diverges_in_: '\ndivergiert in ',
    converges_after_: '\nkonvergiert nach ',
    after_: '\nnach ',
    period_: ', Periode '
  }
};

// Global MSG object for current language
let MSG = Messages.en;

// Global selected language (for URL preservation)
let SELECTED_LANG = 'en';
let LANG_FROM_URL = false;

// Detect and display the appropriate language
(function() {
  // Get language from URL parameter or browser setting
  const urlParams = new URLSearchParams(window.location.search);
  const urlLang = urlParams.get('lang');
  const browserLang = navigator.language.toLowerCase();
  const userLang = urlLang || browserLang;

  // List of supported languages
  const supportedLangs = ['en', 'es', 'zh', 'zh-tw', 'ar', 'id', 'pt', 'fr', 'ja', 'ru', 'de'];

  // Try exact match first, then base language code (e.g., zh-TW -> zh-tw, then zh)
  let selectedLang = 'en';
  if (supportedLangs.includes(userLang)) {
    selectedLang = userLang;
  } else {
    const baseLang = userLang.split('-')[0];
    selectedLang = supportedLangs.includes(baseLang) ? baseLang : 'en';
  }

  // Set globals
  MSG = Messages[selectedLang] || Messages['en'];
  SELECTED_LANG = selectedLang;
  LANG_FROM_URL = !!urlLang && supportedLangs.includes(urlLang);

  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', applyLanguage);
  } else {
    applyLanguage();
  }

  function applyLanguage() {
    const langDivs = document.querySelectorAll('#text [lang]');
    langDivs.forEach(div => {
      const divLang = div.getAttribute('lang').toLowerCase();
      div.style.display = divLang === selectedLang ? '' : 'none';
    });
  }
})();
</script>
<!-- BEGIN_MP4MUXER_LIBRARY -->
<!-- mp4-muxer library (tree-shaken, 31505 bytes) -->
<!-- Source: https://www.npmjs.com/package/mp4-muxer -->
<!-- Built with: ./build.sh -->
<script>
(()=>{var Ee=(e,t,s)=>{if(!t.has(e))throw TypeError("Cannot "+s)},i=(e,t,s)=>(Ee(e,t,"read from private fi\
eld"),s?s.call(e):t.get(e)),d=(e,t,s)=>{if(t.has(e))throw TypeError("Cannot add the same private mem\
ber more than once");t instanceof WeakSet?t.add(e):t.set(e,s)},T=(e,t,s,r)=>(Ee(e,t,"write to privat\
e field"),r?r.call(e,s):t.set(e,s),s),st=(e,t,s,r)=>({set _(a){T(e,t,a,s)},get _(){return i(e,t,r)}}),
m=(e,t,s)=>(Ee(e,t,"access private method"),s),p=new Uint8Array(8),B=new DataView(p.buffer),C=e=>[(e%
256+256)%256],c=e=>(B.setUint16(0,e,!1),[p[0],p[1]]),rt=e=>(B.setInt16(0,e,!1),[p[0],p[1]]),Ve=e=>(B.
setUint32(0,e,!1),[p[1],p[2],p[3]]),n=e=>(B.setUint32(0,e,!1),[p[0],p[1],p[2],p[3]]),at=e=>(B.setInt32(
0,e,!1),[p[0],p[1],p[2],p[3]]),V=e=>(B.setUint32(0,Math.floor(e/2**32),!1),B.setUint32(4,e,!1),[p[0],
p[1],p[2],p[3],p[4],p[5],p[6],p[7]]),ze=e=>(B.setInt16(0,2**8*e,!1),[p[0],p[1]]),A=e=>(B.setInt32(0,
2**16*e,!1),[p[0],p[1],p[2],p[3]]),we=e=>(B.setInt32(0,2**30*e,!1),[p[0],p[1],p[2],p[3]]),E=(e,t=!1)=>{
let s=Array(e.length).fill(null).map((r,a)=>e.charCodeAt(a));return t&&s.push(0),s},le=e=>e&&e[e.length-
1],Ae=e=>{let t;for(let s of e)(!t||s.presentationTimestamp>t.presentationTimestamp)&&(t=s);return t},
O=(e,t,s=!0)=>{let r=e*t;return s?Math.round(r):r},Pe=e=>{let t=e*(Math.PI/180),s=Math.cos(t),r=Math.
sin(t);return[s,r,0,-r,s,0,0,0,1]},je=Pe(0),$e=e=>[A(e[0]),A(e[1]),we(e[2]),A(e[3]),A(e[4]),we(e[5]),
A(e[6]),A(e[7]),we(e[8])],K=e=>!e||typeof e!="object"?e:Array.isArray(e)?e.map(K):Object.fromEntries(
Object.entries(e).map(([t,s])=>[t,K(s)])),H=e=>e>=0&&e<2**32,g=(e,t,s)=>({type:e,contents:t&&new Uint8Array(
t.flat(10)),children:s}),w=(e,t,s,r,a)=>g(e,[C(t),Ve(s),r??[]],a),nt=e=>{let t=512;return e.fragmented?
g("ftyp",[E("iso5"),n(t),E("iso5"),E("iso6"),E("mp41")]):g("ftyp",[E("isom"),n(t),E("isom"),e.holdsAvc?
E("avc1"):[],E("mp41")])},ve=e=>({type:"mdat",largeSize:e}),ot=e=>({type:"free",size:e}),re=(e,t,s=!1)=>g(
"moov",null,[ht(t,e),...e.map(r=>lt(r,t)),s?Lt(e):null]),ht=(e,t)=>{let s=O(Math.max(0,...t.filter(h=>h.
samples.length>0).map(h=>{let f=Ae(h.samples);return f.presentationTimestamp+f.duration})),ye),r=Math.
max(...t.map(h=>h.id))+1,a=!H(e)||!H(s),o=a?V:n;return w("mvhd",+a,0,[o(e),o(e),n(ye),o(s),A(1),ze(1),
Array(10).fill(0),$e(je),Array(24).fill(0),n(r)])},lt=(e,t)=>g("trak",null,[ft(e,t),ut(e,t)]),ft=(e,t)=>{
let s=Ae(e.samples),r=O(s?s.presentationTimestamp+s.duration:0,ye),a=!H(t)||!H(r),o=a?V:n,h;return e.
info.type==="video"?h=typeof e.info.rotation=="number"?Pe(e.info.rotation):e.info.rotation:h=je,w("t\
khd",+a,3,[o(t),o(t),n(e.id),n(0),o(r),Array(8).fill(0),c(0),c(0),ze(e.info.type==="audio"?1:0),c(0),
$e(h),A(e.info.type==="video"?e.info.width:0),A(e.info.type==="video"?e.info.height:0)])},ut=(e,t)=>g(
"mdia",null,[dt(e,t),mt(e.info.type==="video"?"vide":"soun"),pt(e)]),dt=(e,t)=>{let s=Ae(e.samples),
r=O(s?s.presentationTimestamp+s.duration:0,e.timescale),a=!H(t)||!H(r),o=a?V:n;return w("mdhd",+a,0,
[o(t),o(t),n(e.timescale),o(r),c(21956),c(0)])},mt=e=>w("hdlr",0,0,[E("mhlr"),E(e),n(0),n(0),n(0),E(
"mp4-muxer-hdlr",!0)]),pt=e=>g("minf",null,[e.info.type==="video"?ct():wt(),vt(),yt(e)]),ct=()=>w("v\
mhd",0,1,[c(0),c(0),c(0),c(0)]),wt=()=>w("smhd",0,0,[c(0),c(0)]),vt=()=>g("dinf",null,[gt()]),gt=()=>w(
"dref",0,0,[n(1)],[Ct()]),Ct=()=>w("url ",0,1),yt=e=>{let t=e.compositionTimeOffsetTable.length>1||e.
compositionTimeOffsetTable.some(s=>s.sampleCompositionTimeOffset!==0);return g("stbl",null,[Tt(e),Ut(
e),xt(e),Wt(e),Ft(e),Nt(e),t?Rt(e):null])},Tt=e=>w("stsd",0,0,[n(1)],[e.info.type==="video"?St(Kt[e.
info.codec],e):Mt(Yt[e.info.codec],e)]),St=(e,t)=>g(e,[Array(6).fill(0),c(1),c(0),c(0),Array(12).fill(
0),c(t.info.width),c(t.info.height),n(4718592),n(4718592),n(0),c(1),Array(32).fill(0),c(24),rt(65535)],
[Qt[t.info.codec](t),t.info.decoderConfig.colorSpace?Et(t):null]),bt={bt709:1,bt470bg:5,smpte170m:6},
kt={bt709:1,smpte170m:6,"iec61966-2-1":13},_t={rgb:0,bt709:1,bt470bg:5,smpte170m:6},Et=e=>g("colr",[
E("nclx"),c(bt[e.info.decoderConfig.colorSpace.primaries]),c(kt[e.info.decoderConfig.colorSpace.transfer]),
c(_t[e.info.decoderConfig.colorSpace.matrix]),C((e.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),
zt=e=>e.info.decoderConfig&&g("avcC",[...new Uint8Array(e.info.decoderConfig.description)]),At=e=>e.
info.decoderConfig&&g("hvcC",[...new Uint8Array(e.info.decoderConfig.description)]),Ot=e=>{if(!e.info.
decoderConfig)return null;let t=e.info.decoderConfig;if(!t.colorSpace)throw new Error("'colorSpace' \
is required in the decoder config for VP9.");let s=t.codec.split("."),r=Number(s[1]),a=Number(s[2]),
f=(Number(s[3])<<4)+(0<<1)+Number(t.colorSpace.fullRange);return w("vpcC",1,0,[C(r),C(a),C(f),C(2),C(
2),C(2),c(0)])},Bt=()=>{let s=(1<<7)+1;return g("av1C",[s,0,0,0])},Mt=(e,t)=>g(e,[Array(6).fill(0),c(
1),c(0),c(0),n(0),c(t.info.numberOfChannels),c(16),c(0),c(0),A(t.info.sampleRate)],[Jt[t.info.codec](
t)]),It=e=>{let t=new Uint8Array(e.info.decoderConfig.description);return w("esds",0,0,[n(58753152),
C(32+t.byteLength),c(1),C(0),n(75530368),C(18+t.byteLength),C(64),C(21),Ve(0),n(130071),n(130071),n(
92307584),C(t.byteLength),...t,n(109084800),C(1),C(2)])},Dt=e=>{let t=3840,s=0,r=e.info.decoderConfig?.
description;if(r){if(r.byteLength<18)throw new TypeError("Invalid decoder description provided for O\
pus; must be at least 18 bytes long.");let a=ArrayBuffer.isView(r)?new DataView(r.buffer,r.byteOffset,
r.byteLength):new DataView(r);t=a.getUint16(10,!0),s=a.getInt16(14,!0)}return g("dOps",[C(0),C(e.info.
numberOfChannels),c(t),n(e.info.sampleRate),ze(s),C(0)])},Ut=e=>w("stts",0,0,[n(e.timeToSampleTable.
length),e.timeToSampleTable.map(t=>[n(t.sampleCount),n(t.sampleDelta)])]),xt=e=>{if(e.samples.every(
s=>s.type==="key"))return null;let t=[...e.samples.entries()].filter(([,s])=>s.type==="key");return w(
"stss",0,0,[n(t.length),t.map(([s])=>n(s+1))])},Wt=e=>w("stsc",0,0,[n(e.compactlyCodedChunkTable.length),
e.compactlyCodedChunkTable.map(t=>[n(t.firstChunk),n(t.samplesPerChunk),n(1)])]),Ft=e=>w("stsz",0,0,
[n(0),n(e.samples.length),e.samples.map(t=>n(t.size))]),Nt=e=>e.finalizedChunks.length>0&&le(e.finalizedChunks).
offset>=2**32?w("co64",0,0,[n(e.finalizedChunks.length),e.finalizedChunks.map(t=>V(t.offset))]):w("s\
tco",0,0,[n(e.finalizedChunks.length),e.finalizedChunks.map(t=>n(t.offset))]),Rt=e=>w("ctts",0,0,[n(
e.compositionTimeOffsetTable.length),e.compositionTimeOffsetTable.map(t=>[n(t.sampleCount),n(t.sampleCompositionTimeOffset)])]),
Lt=e=>g("mvex",null,e.map(Vt)),Vt=e=>w("trex",0,0,[n(e.id),n(1),n(0),n(0),n(0)]),Le=(e,t)=>g("moof",
null,[Pt(e),...t.map(jt)]),Pt=e=>w("mfhd",0,0,[n(e)]),He=e=>{let t=0,s=0,r=0,a=0,o=e.type==="delta";
return s|=+o,o?t|=1:t|=2,t<<24|s<<16|r<<8|a},jt=e=>g("traf",null,[$t(e),Ht(e),qt(e)]),$t=e=>{let t=0;
t|=8,t|=16,t|=32,t|=131072;let s=e.currentChunk.samples[1]??e.currentChunk.samples[0],r={duration:s.
timescaleUnitsToNextSample,size:s.size,flags:He(s)};return w("tfhd",0,t,[n(e.id),n(r.duration),n(r.size),
n(r.flags)])},Ht=e=>w("tfdt",1,0,[V(O(e.currentChunk.startTimestamp,e.timescale))]),qt=e=>{let t=e.currentChunk.
samples.map(M=>M.timescaleUnitsToNextSample),s=e.currentChunk.samples.map(M=>M.size),r=e.currentChunk.
samples.map(He),a=e.currentChunk.samples.map(M=>O(M.presentationTimestamp-M.decodeTimestamp,e.timescale)),
o=new Set(t),h=new Set(s),f=new Set(r),v=new Set(a),S=f.size===2&&r[0]!==r[1],U=o.size>1,X=h.size>1,
Ne=!S&&f.size>1,Re=v.size>1||[...v].some(M=>M!==0),x=0;return x|=1,x|=4*+S,x|=256*+U,x|=512*+X,x|=1024*
+Ne,x|=2048*+Re,w("trun",1,x,[n(e.currentChunk.samples.length),n(e.currentChunk.offset-e.currentChunk.
moofOffset||0),S?n(r[0]):[],e.currentChunk.samples.map((M,se)=>[U?n(t[se]):[],X?n(s[se]):[],Ne?n(r[se]):
[],Re?at(a[se]):[]])])},Xt=e=>g("mfra",null,[...e.map(Gt),Zt()]),Gt=(e,t)=>w("tfra",1,0,[n(e.id),n(63),
n(e.finalizedChunks.length),e.finalizedChunks.map(r=>[V(O(r.startTimestamp,e.timescale)),V(r.moofOffset),
n(t+1),n(1),n(1)])]),Zt=()=>w("mfro",0,0,[n(0)]),Kt={avc:"avc1",hevc:"hvc1",vp9:"vp09",av1:"av01"},Qt={
avc:zt,hevc:At,vp9:Ot,av1:Bt},Yt={aac:"mp4a",opus:"Opus"},Jt={aac:It,opus:Dt},li=Symbol("isTarget"),
ce=class{},Oe=class extends ce{constructor(){super(...arguments),this.buffer=null}},qe=class extends ce{constructor(e){
if(super(),this.options=e,typeof e!="object")throw new TypeError("StreamTarget requires an options o\
bject to be passed to its constructor.");if(e.onData){if(typeof e.onData!="function")throw new TypeError(
"options.onData, when provided, must be a function.");if(e.onData.length<2)throw new TypeError("opti\
ons.onData, when provided, must be a function that takes in at least two arguments (data and positio\
n). Ignoring the position argument, which specifies the byte offset at which the data is to be writt\
en, can lead to broken outputs.")}if(e.chunked!==void 0&&typeof e.chunked!="boolean")throw new TypeError(
"options.chunked, when provided, must be a boolean.");if(e.chunkSize!==void 0&&(!Number.isInteger(e.
chunkSize)||e.chunkSize<1024))throw new TypeError("options.chunkSize, when provided, must be an inte\
ger and not smaller than 1024.")}},ei=class extends ce{constructor(e,t){if(super(),this.stream=e,this.
options=t,!(e instanceof FileSystemWritableFileStream))throw new TypeError("FileSystemWritableFileSt\
reamTarget requires a FileSystemWritableFileStream instance.");if(t!==void 0&&typeof t!="object")throw new TypeError(
"FileSystemWritableFileStreamTarget's options, when provided, must be an object.");if(t&&t.chunkSize!==
void 0&&(!Number.isInteger(t.chunkSize)||t.chunkSize<=0))throw new TypeError("options.chunkSize, whe\
n provided, must be a positive integer")}},W,P,Xe=class{constructor(){this.pos=0,d(this,W,new Uint8Array(
8)),d(this,P,new DataView(i(this,W).buffer)),this.offsets=new WeakMap}seek(e){this.pos=e}writeU32(e){
i(this,P).setUint32(0,e,!1),this.write(i(this,W).subarray(0,4))}writeU64(e){i(this,P).setUint32(0,Math.
floor(e/2**32),!1),i(this,P).setUint32(4,e,!1),this.write(i(this,W).subarray(0,8))}writeAscii(e){for(let t=0;t<
e.length;t++)i(this,P).setUint8(t%8,e.charCodeAt(t)),t%8===7&&this.write(i(this,W));e.length%8!==0&&
this.write(i(this,W).subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.pos),e.contents&&
!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.write(e.contents);else{let t=this.
pos;if(this.writeBoxHeader(e,0),e.contents&&this.write(e.contents),e.children)for(let a of e.children)
a&&this.writeBox(a);let s=this.pos,r=e.size??s-t;this.seek(t),this.writeBoxHeader(e,r),this.seek(s)}}writeBoxHeader(e,t){
this.writeU32(e.largeSize?1:t),this.writeAscii(e.type),e.largeSize&&this.writeU64(t)}measureBoxHeader(e){
return 8+(e.largeSize?8:0)}patchBox(e){let t=this.pos;this.seek(this.offsets.get(e)),this.writeBox(e),
this.seek(t)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;
{let t=this.measureBoxHeader(e);if(e.contents&&(t+=e.contents.byteLength),e.children)for(let s of e.
children)s&&(t+=this.measureBox(s));return t}}};W=new WeakMap;P=new WeakMap;var ae,L,te,G,ne,ge,ti=class extends Xe{constructor(e){
super(),d(this,ne),d(this,ae,void 0),d(this,L,new ArrayBuffer(2**16)),d(this,te,new Uint8Array(i(this,
L))),d(this,G,0),T(this,ae,e)}write(e){m(this,ne,ge).call(this,this.pos+e.byteLength),i(this,te).set(
e,this.pos),this.pos+=e.byteLength,T(this,G,Math.max(i(this,G),this.pos))}finalize(){m(this,ne,ge).call(
this,this.pos),i(this,ae).buffer=i(this,L).slice(0,Math.max(i(this,G),this.pos))}};ae=new WeakMap;L=
new WeakMap;te=new WeakMap;G=new WeakMap;ne=new WeakSet;ge=function(e){let t=i(this,L).byteLength;for(;t<
e;)t*=2;if(t===i(this,L).byteLength)return;let s=new ArrayBuffer(t),r=new Uint8Array(s);r.set(i(this,
te),0),T(this,L,s),T(this,te,r)};var ii=2**24,si=2,Q,F,Z,D,_,fe,Ce,Be,Ge,Me,Ze,Y,ue,Ie=class extends Xe{constructor(e){
super(),d(this,fe),d(this,Be),d(this,Me),d(this,Y),d(this,Q,void 0),d(this,F,[]),d(this,Z,void 0),d(
this,D,void 0),d(this,_,[]),T(this,Q,e),T(this,Z,e.options?.chunked??!1),T(this,D,e.options?.chunkSize??
ii)}write(e){i(this,F).push({data:e.slice(),start:this.pos}),this.pos+=e.byteLength}flush(){if(i(this,
F).length===0)return;let e=[],t=[...i(this,F)].sort((s,r)=>s.start-r.start);e.push({start:t[0].start,
size:t[0].data.byteLength});for(let s=1;s<t.length;s++){let r=e[e.length-1],a=t[s];a.start<=r.start+
r.size?r.size=Math.max(r.size,a.start+a.data.byteLength-r.start):e.push({start:a.start,size:a.data.byteLength})}
for(let s of e){s.data=new Uint8Array(s.size);for(let r of i(this,F))s.start<=r.start&&r.start<s.start+
s.size&&s.data.set(r.data,r.start-s.start);i(this,Z)?(m(this,fe,Ce).call(this,s.data,s.start),m(this,
Y,ue).call(this)):i(this,Q).options.onData?.(s.data,s.start)}i(this,F).length=0}finalize(){i(this,Z)&&
m(this,Y,ue).call(this,!0)}};Q=new WeakMap;F=new WeakMap;Z=new WeakMap;D=new WeakMap;_=new WeakMap;fe=
new WeakSet;Ce=function(e,t){let s=i(this,_).findIndex(f=>f.start<=t&&t<f.start+i(this,D));s===-1&&(s=
m(this,Me,Ze).call(this,t));let r=i(this,_)[s],a=t-r.start,o=e.subarray(0,Math.min(i(this,D)-a,e.byteLength));
r.data.set(o,a);let h={start:a,end:a+o.byteLength};if(m(this,Be,Ge).call(this,r,h),r.written[0].start===
0&&r.written[0].end===i(this,D)&&(r.shouldFlush=!0),i(this,_).length>si){for(let f=0;f<i(this,_).length-
1;f++)i(this,_)[f].shouldFlush=!0;m(this,Y,ue).call(this)}o.byteLength<e.byteLength&&m(this,fe,Ce).call(
this,e.subarray(o.byteLength),t+o.byteLength)};Be=new WeakSet;Ge=function(e,t){let s=0,r=e.written.length-
1,a=-1;for(;s<=r;){let o=Math.floor(s+(r-s+1)/2);e.written[o].start<=t.start?(s=o+1,a=o):r=o-1}for(e.
written.splice(a+1,0,t),(a===-1||e.written[a].end<t.start)&&a++;a<e.written.length-1&&e.written[a].end>=
e.written[a+1].start;)e.written[a].end=Math.max(e.written[a].end,e.written[a+1].end),e.written.splice(
a+1,1)};Me=new WeakSet;Ze=function(e){let s={start:Math.floor(e/i(this,D))*i(this,D),data:new Uint8Array(
i(this,D)),written:[],shouldFlush:!1};return i(this,_).push(s),i(this,_).sort((r,a)=>r.start-a.start),
i(this,_).indexOf(s)};Y=new WeakSet;ue=function(e=!1){for(let t=0;t<i(this,_).length;t++){let s=i(this,
_)[t];if(!(!s.shouldFlush&&!e)){for(let r of s.written)i(this,Q).options.onData?.(s.data.subarray(r.
start,r.end),s.start+r.start);i(this,_).splice(t--,1)}}};var ri=class extends Ie{constructor(e){super(
new qe({onData:(t,s)=>e.stream.write({type:"write",data:t,position:s}),chunked:!0,chunkSize:e.options?.
chunkSize}))}},ye=1e3,ai=["avc","hevc","vp9","av1"],ni=["aac","opus"],oi=2082844800,hi=["strict","of\
fset","cross-track-offset"],l,u,de,k,b,y,j,$,De,N,R,J,Te,Ke,Se,Qe,Ue,Ye,be,Je,xe,et,oe,ke,z,I,We,tt,
ee,me,pe,Fe,q,ie,he,_e,it=class{constructor(e){if(d(this,Te),d(this,Se),d(this,Ue),d(this,be),d(this,
xe),d(this,oe),d(this,z),d(this,We),d(this,ee),d(this,pe),d(this,q),d(this,he),d(this,l,void 0),d(this,
u,void 0),d(this,de,void 0),d(this,k,void 0),d(this,b,null),d(this,y,null),d(this,j,Math.floor(Date.
now()/1e3)+oi),d(this,$,[]),d(this,De,1),d(this,N,[]),d(this,R,[]),d(this,J,!1),m(this,Te,Ke).call(this,
e),e.video=K(e.video),e.audio=K(e.audio),e.fastStart=K(e.fastStart),this.target=e.target,T(this,l,{firstTimestampBehavior:"\
strict",...e}),e.target instanceof Oe)T(this,u,new ti(e.target));else if(e.target instanceof qe)T(this,
u,new Ie(e.target));else if(e.target instanceof ei)T(this,u,new ri(e.target));else throw new Error(`\
Invalid target: ${e.target}`);m(this,be,Je).call(this),m(this,Se,Qe).call(this)}addVideoChunk(e,t,s,r){
if(!(e instanceof EncodedVideoChunk))throw new TypeError("addVideoChunk's first argument (sample) mu\
st be of type EncodedVideoChunk.");if(t&&typeof t!="object")throw new TypeError("addVideoChunk's sec\
ond argument (meta), when provided, must be an object.");if(s!==void 0&&(!Number.isFinite(s)||s<0))throw new TypeError(
"addVideoChunk's third argument (timestamp), when provided, must be a non-negative real number.");if(r!==
void 0&&!Number.isFinite(r))throw new TypeError("addVideoChunk's fourth argument (compositionTimeOff\
set), when provided, must be a real number.");let a=new Uint8Array(e.byteLength);e.copyTo(a),this.addVideoChunkRaw(
a,e.type,s??e.timestamp,e.duration,t,r)}addVideoChunkRaw(e,t,s,r,a,o){if(!(e instanceof Uint8Array))
throw new TypeError("addVideoChunkRaw's first argument (data) must be an instance of Uint8Array.");if(t!==
"key"&&t!=="delta")throw new TypeError("addVideoChunkRaw's second argument (type) must be either 'ke\
y' or 'delta'.");if(!Number.isFinite(s)||s<0)throw new TypeError("addVideoChunkRaw's third argument \
(timestamp) must be a non-negative real number.");if(!Number.isFinite(r)||r<0)throw new TypeError("a\
ddVideoChunkRaw's fourth argument (duration) must be a non-negative real number.");if(a&&typeof a!="\
object")throw new TypeError("addVideoChunkRaw's fifth argument (meta), when provided, must be an obj\
ect.");if(o!==void 0&&!Number.isFinite(o))throw new TypeError("addVideoChunkRaw's sixth argument (co\
mpositionTimeOffset), when provided, must be a real number.");if(m(this,he,_e).call(this),!i(this,l).
video)throw new Error("No video track declared.");if(typeof i(this,l).fastStart=="object"&&i(this,b).
samples.length===i(this,l).fastStart.expectedVideoChunks)throw new Error(`Cannot add more video chun\
ks than specified in 'fastStart' (${i(this,l).fastStart.expectedVideoChunks}).`);let h=m(this,oe,ke).
call(this,i(this,b),e,t,s,r,a,o);if(i(this,l).fastStart==="fragmented"&&i(this,y)){for(;i(this,R).length>
0&&i(this,R)[0].decodeTimestamp<=h.decodeTimestamp;){let f=i(this,R).shift();m(this,z,I).call(this,i(
this,y),f)}h.decodeTimestamp<=i(this,y).lastDecodeTimestamp?m(this,z,I).call(this,i(this,b),h):i(this,
N).push(h)}else m(this,z,I).call(this,i(this,b),h)}addAudioChunk(e,t,s){if(!(e instanceof EncodedAudioChunk))
throw new TypeError("addAudioChunk's first argument (sample) must be of type EncodedAudioChunk.");if(t&&
typeof t!="object")throw new TypeError("addAudioChunk's second argument (meta), when provided, must \
be an object.");if(s!==void 0&&(!Number.isFinite(s)||s<0))throw new TypeError("addAudioChunk's third\
 argument (timestamp), when provided, must be a non-negative real number.");let r=new Uint8Array(e.byteLength);
e.copyTo(r),this.addAudioChunkRaw(r,e.type,s??e.timestamp,e.duration,t)}addAudioChunkRaw(e,t,s,r,a){
if(!(e instanceof Uint8Array))throw new TypeError("addAudioChunkRaw's first argument (data) must be \
an instance of Uint8Array.");if(t!=="key"&&t!=="delta")throw new TypeError("addAudioChunkRaw's secon\
d argument (type) must be either 'key' or 'delta'.");if(!Number.isFinite(s)||s<0)throw new TypeError(
"addAudioChunkRaw's third argument (timestamp) must be a non-negative real number.");if(!Number.isFinite(
r)||r<0)throw new TypeError("addAudioChunkRaw's fourth argument (duration) must be a non-negative re\
al number.");if(a&&typeof a!="object")throw new TypeError("addAudioChunkRaw's fifth argument (meta),\
 when provided, must be an object.");if(m(this,he,_e).call(this),!i(this,l).audio)throw new Error("N\
o audio track declared.");if(typeof i(this,l).fastStart=="object"&&i(this,y).samples.length===i(this,
l).fastStart.expectedAudioChunks)throw new Error(`Cannot add more audio chunks than specified in 'fa\
stStart' (${i(this,l).fastStart.expectedAudioChunks}).`);let o=m(this,oe,ke).call(this,i(this,y),e,t,
s,r,a);if(i(this,l).fastStart==="fragmented"&&i(this,b)){for(;i(this,N).length>0&&i(this,N)[0].decodeTimestamp<=
o.decodeTimestamp;){let h=i(this,N).shift();m(this,z,I).call(this,i(this,b),h)}o.decodeTimestamp<=i(
this,b).lastDecodeTimestamp?m(this,z,I).call(this,i(this,y),o):i(this,R).push(o)}else m(this,z,I).call(
this,i(this,y),o)}finalize(){if(i(this,J))throw new Error("Cannot finalize a muxer more than once.");
if(i(this,l).fastStart==="fragmented"){for(let t of i(this,N))m(this,z,I).call(this,i(this,b),t);for(let t of i(
this,R))m(this,z,I).call(this,i(this,y),t);m(this,pe,Fe).call(this,!1)}else i(this,b)&&m(this,ee,me).
call(this,i(this,b)),i(this,y)&&m(this,ee,me).call(this,i(this,y));let e=[i(this,b),i(this,y)].filter(
Boolean);if(i(this,l).fastStart==="in-memory"){let t;for(let r=0;r<2;r++){let a=re(e,i(this,j)),o=i(
this,u).measureBox(a);t=i(this,u).measureBox(i(this,k));let h=i(this,u).pos+o+t;for(let f of i(this,
$)){f.offset=h;for(let{data:v}of f.samples)h+=v.byteLength,t+=v.byteLength}if(h<2**32)break;t>=2**32&&
(i(this,k).largeSize=!0)}let s=re(e,i(this,j));i(this,u).writeBox(s),i(this,k).size=t,i(this,u).writeBox(
i(this,k));for(let r of i(this,$))for(let a of r.samples)i(this,u).write(a.data),a.data=null}else if(i(
this,l).fastStart==="fragmented"){let t=i(this,u).pos,s=Xt(e);i(this,u).writeBox(s);let r=i(this,u).
pos-t;i(this,u).seek(i(this,u).pos-4),i(this,u).writeU32(r)}else{let t=i(this,u).offsets.get(i(this,
k)),s=i(this,u).pos-t;i(this,k).size=s,i(this,k).largeSize=s>=2**32,i(this,u).patchBox(i(this,k));let r=re(
e,i(this,j));if(typeof i(this,l).fastStart=="object"){i(this,u).seek(i(this,de)),i(this,u).writeBox(
r);let a=t-i(this,u).pos;i(this,u).writeBox(ot(a))}else i(this,u).writeBox(r)}m(this,q,ie).call(this),
i(this,u).finalize(),T(this,J,!0)}};l=new WeakMap;u=new WeakMap;de=new WeakMap;k=new WeakMap;b=new WeakMap;
y=new WeakMap;j=new WeakMap;$=new WeakMap;De=new WeakMap;N=new WeakMap;R=new WeakMap;J=new WeakMap;Te=
new WeakSet;Ke=function(e){if(typeof e!="object")throw new TypeError("The muxer requires an options \
object to be passed to its constructor.");if(!(e.target instanceof ce))throw new TypeError("The targ\
et must be provided and an instance of Target.");if(e.video){if(!ai.includes(e.video.codec))throw new TypeError(
`Unsupported video codec: ${e.video.codec}`);if(!Number.isInteger(e.video.width)||e.video.width<=0)throw new TypeError(
`Invalid video width: ${e.video.width}. Must be a positive integer.`);if(!Number.isInteger(e.video.height)||
e.video.height<=0)throw new TypeError(`Invalid video height: ${e.video.height}. Must be a positive i\
nteger.`);let t=e.video.rotation;if(typeof t=="number"&&![0,90,180,270].includes(t))throw new TypeError(
`Invalid video rotation: ${t}. Has to be 0, 90, 180 or 270.`);if(Array.isArray(t)&&(t.length!==9||t.
some(s=>typeof s!="number")))throw new TypeError(`Invalid video transformation matrix: ${t.join()}`);
if(e.video.frameRate!==void 0&&(!Number.isInteger(e.video.frameRate)||e.video.frameRate<=0))throw new TypeError(
`Invalid video frame rate: ${e.video.frameRate}. Must be a positive integer.`)}if(e.audio){if(!ni.includes(
e.audio.codec))throw new TypeError(`Unsupported audio codec: ${e.audio.codec}`);if(!Number.isInteger(
e.audio.numberOfChannels)||e.audio.numberOfChannels<=0)throw new TypeError(`Invalid number of audio \
channels: ${e.audio.numberOfChannels}. Must be a positive integer.`);if(!Number.isInteger(e.audio.sampleRate)||
e.audio.sampleRate<=0)throw new TypeError(`Invalid audio sample rate: ${e.audio.sampleRate}. Must be\
 a positive integer.`)}if(e.firstTimestampBehavior&&!hi.includes(e.firstTimestampBehavior))throw new TypeError(
`Invalid first timestamp behavior: ${e.firstTimestampBehavior}`);if(typeof e.fastStart=="object"){if(e.
video){if(e.fastStart.expectedVideoChunks===void 0)throw new TypeError("'fastStart' is an object but\
 is missing property 'expectedVideoChunks'.");if(!Number.isInteger(e.fastStart.expectedVideoChunks)||
e.fastStart.expectedVideoChunks<0)throw new TypeError("'expectedVideoChunks' must be a non-negative \
integer.")}if(e.audio){if(e.fastStart.expectedAudioChunks===void 0)throw new TypeError("'fastStart' \
is an object but is missing property 'expectedAudioChunks'.");if(!Number.isInteger(e.fastStart.expectedAudioChunks)||
e.fastStart.expectedAudioChunks<0)throw new TypeError("'expectedAudioChunks' must be a non-negative \
integer.")}}else if(![!1,"in-memory","fragmented"].includes(e.fastStart))throw new TypeError("'fastS\
tart' option must be false, 'in-memory', 'fragmented' or an object.");if(e.minFragmentDuration!==void 0&&
(!Number.isFinite(e.minFragmentDuration)||e.minFragmentDuration<0))throw new TypeError("'minFragment\
Duration' must be a non-negative number.")};Se=new WeakSet;Qe=function(){if(i(this,u).writeBox(nt({holdsAvc:i(
this,l).video?.codec==="avc",fragmented:i(this,l).fastStart==="fragmented"})),T(this,de,i(this,u).pos),
i(this,l).fastStart==="in-memory")T(this,k,ve(!1));else if(i(this,l).fastStart!=="fragmented"){if(typeof i(
this,l).fastStart=="object"){let e=m(this,Ue,Ye).call(this);i(this,u).seek(i(this,u).pos+e)}T(this,k,
ve(!0)),i(this,u).writeBox(i(this,k))}m(this,q,ie).call(this)};Ue=new WeakSet;Ye=function(){if(typeof i(
this,l).fastStart!="object")return;let e=0,t=[i(this,l).fastStart.expectedVideoChunks,i(this,l).fastStart.
expectedAudioChunks];for(let s of t)s&&(e+=8*Math.ceil(2/3*s),e+=4*s,e+=12*Math.ceil(2/3*s),e+=4*s,e+=
8*s);return e+=4096,e};be=new WeakSet;Je=function(){if(i(this,l).video&&T(this,b,{id:1,info:{type:"v\
ideo",codec:i(this,l).video.codec,width:i(this,l).video.width,height:i(this,l).video.height,rotation:i(
this,l).video.rotation??0,decoderConfig:null},timescale:i(this,l).video.frameRate??57600,samples:[],
finalizedChunks:[],currentChunk:null,firstDecodeTimestamp:void 0,lastDecodeTimestamp:-1,timeToSampleTable:[],
compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,compactlyCodedChunkTable:[]}),
i(this,l).audio&&(T(this,y,{id:i(this,l).video?2:1,info:{type:"audio",codec:i(this,l).audio.codec,numberOfChannels:i(
this,l).audio.numberOfChannels,sampleRate:i(this,l).audio.sampleRate,decoderConfig:null},timescale:i(
this,l).audio.sampleRate,samples:[],finalizedChunks:[],currentChunk:null,firstDecodeTimestamp:void 0,
lastDecodeTimestamp:-1,timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,
compactlyCodedChunkTable:[]}),i(this,l).audio.codec==="aac")){let e=m(this,xe,et).call(this,2,i(this,
l).audio.sampleRate,i(this,l).audio.numberOfChannels);i(this,y).info.decoderConfig={codec:i(this,l).
audio.codec,description:e,numberOfChannels:i(this,l).audio.numberOfChannels,sampleRate:i(this,l).audio.
sampleRate}}};xe=new WeakSet;et=function(e,t,s){let a=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,
12e3,11025,8e3,7350].indexOf(t),o=s,h="";h+=e.toString(2).padStart(5,"0"),h+=a.toString(2).padStart(
4,"0"),a===15&&(h+=t.toString(2).padStart(24,"0")),h+=o.toString(2).padStart(4,"0");let f=Math.ceil(
h.length/8)*8;h=h.padEnd(f,"0");let v=new Uint8Array(h.length/8);for(let S=0;S<h.length;S+=8)v[S/8]=
parseInt(h.slice(S,S+8),2);return v};oe=new WeakSet;ke=function(e,t,s,r,a,o,h){let f=r/1e6,v=(r-(h??
0))/1e6,S=a/1e6,U=m(this,We,tt).call(this,f,v,e);return f=U.presentationTimestamp,v=U.decodeTimestamp,
o?.decoderConfig&&(e.info.decoderConfig===null?e.info.decoderConfig=o.decoderConfig:Object.assign(e.
info.decoderConfig,o.decoderConfig)),{presentationTimestamp:f,decodeTimestamp:v,duration:S,data:t,size:t.
byteLength,type:s,timescaleUnitsToNextSample:O(S,e.timescale)}};z=new WeakSet;I=function(e,t){i(this,
l).fastStart!=="fragmented"&&e.samples.push(t);let s=O(t.presentationTimestamp-t.decodeTimestamp,e.timescale);
if(e.lastTimescaleUnits!==null){let a=O(t.decodeTimestamp,e.timescale,!1),o=Math.round(a-e.lastTimescaleUnits);
if(e.lastTimescaleUnits+=o,e.lastSample.timescaleUnitsToNextSample=o,i(this,l).fastStart!=="fragment\
ed"){let h=le(e.timeToSampleTable);h.sampleCount===1?(h.sampleDelta=o,h.sampleCount++):h.sampleDelta===
o?h.sampleCount++:(h.sampleCount--,e.timeToSampleTable.push({sampleCount:2,sampleDelta:o}));let f=le(
e.compositionTimeOffsetTable);f.sampleCompositionTimeOffset===s?f.sampleCount++:e.compositionTimeOffsetTable.
push({sampleCount:1,sampleCompositionTimeOffset:s})}}else e.lastTimescaleUnits=0,i(this,l).fastStart!==
"fragmented"&&(e.timeToSampleTable.push({sampleCount:1,sampleDelta:O(t.duration,e.timescale)}),e.compositionTimeOffsetTable.
push({sampleCount:1,sampleCompositionTimeOffset:s}));e.lastSample=t;let r=!1;if(!e.currentChunk)r=!0;else{
let a=t.presentationTimestamp-e.currentChunk.startTimestamp;if(i(this,l).fastStart==="fragmented"){let o=i(
this,b)??i(this,y),h=i(this,l).minFragmentDuration??1;e===o&&t.type==="key"&&a>=h&&(r=!0,m(this,pe,Fe).
call(this))}else r=a>=.5}r&&(e.currentChunk&&m(this,ee,me).call(this,e),e.currentChunk={startTimestamp:t.
presentationTimestamp,samples:[]}),e.currentChunk.samples.push(t)};We=new WeakSet;tt=function(e,t,s){
let r=i(this,l).firstTimestampBehavior==="strict",a=s.lastDecodeTimestamp===-1;if(r&&a&&t!==0)throw new Error(
`The first chunk for your media track must have a timestamp of 0 (received DTS=${t}).Non-zero first \
timestamps are often caused by directly piping frames or audio data from a MediaStreamTrack into the\
 encoder. Their timestamps are typically relative to the age of thedocument, which is probably what \
you want.

If you want to offset all timestamps of a track such that the first one is zero, set firstTimestampB\
ehavior: 'offset' in the options.
`);if(i(this,l).firstTimestampBehavior==="offset"||i(this,l).firstTimestampBehavior==="cross-track-o\
ffset"){s.firstDecodeTimestamp===void 0&&(s.firstDecodeTimestamp=t);let h;i(this,l).firstTimestampBehavior===
"offset"?h=s.firstDecodeTimestamp:h=Math.min(i(this,b)?.firstDecodeTimestamp??1/0,i(this,y)?.firstDecodeTimestamp??
1/0),t-=h,e-=h}if(t<s.lastDecodeTimestamp)throw new Error(`Timestamps must be monotonically increasi\
ng (DTS went from ${s.lastDecodeTimestamp*1e6} to ${t*1e6}).`);return s.lastDecodeTimestamp=t,{presentationTimestamp:e,
decodeTimestamp:t}};ee=new WeakSet;me=function(e){if(i(this,l).fastStart==="fragmented")throw new Error(
"Can't finalize individual chunks if 'fastStart' is set to 'fragmented'.");if(e.currentChunk){if(e.finalizedChunks.
push(e.currentChunk),i(this,$).push(e.currentChunk),(e.compactlyCodedChunkTable.length===0||le(e.compactlyCodedChunkTable).
samplesPerChunk!==e.currentChunk.samples.length)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.
length,samplesPerChunk:e.currentChunk.samples.length}),i(this,l).fastStart==="in-memory"){e.currentChunk.
offset=0;return}e.currentChunk.offset=i(this,u).pos;for(let t of e.currentChunk.samples)i(this,u).write(
t.data),t.data=null;m(this,q,ie).call(this)}};pe=new WeakSet;Fe=function(e=!0){if(i(this,l).fastStart!==
"fragmented")throw new Error("Can't finalize a fragment unless 'fastStart' is set to 'fragmented'.");
let t=[i(this,b),i(this,y)].filter(f=>f&&f.currentChunk);if(t.length===0)return;let s=st(this,De)._++;
if(s===1){let f=re(t,i(this,j),!0);i(this,u).writeBox(f)}let r=i(this,u).pos,a=Le(s,t);i(this,u).writeBox(
a);{let f=ve(!1),v=0;for(let U of t)for(let X of U.currentChunk.samples)v+=X.size;let S=i(this,u).measureBox(
f)+v;S>=2**32&&(f.largeSize=!0,S=i(this,u).measureBox(f)+v),f.size=S,i(this,u).writeBox(f)}for(let f of t){
f.currentChunk.offset=i(this,u).pos,f.currentChunk.moofOffset=r;for(let v of f.currentChunk.samples)
i(this,u).write(v.data),v.data=null}let o=i(this,u).pos;i(this,u).seek(i(this,u).offsets.get(a));let h=Le(
s,t);i(this,u).writeBox(h),i(this,u).seek(o);for(let f of t)f.finalizedChunks.push(f.currentChunk),i(
this,$).push(f.currentChunk),f.currentChunk=null;e&&m(this,q,ie).call(this)};q=new WeakSet;ie=function(){
i(this,u)instanceof Ie&&i(this,u).flush()};he=new WeakSet;_e=function(){if(i(this,J))throw new Error(
"Cannot add new video or audio chunks after the file has been finalized.")};window.Mp4Muxer={Muxer:it,ArrayBufferTarget:Oe};})();
</script>
<!-- END_MP4MUXER_LIBRARY -->
<script>
// Start the application
const explorer = new MandelbrotExplorer();
explorer.start();
</script>
</div> <!-- closes id=text -->
</body>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W8X6PWJH83"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-W8X6PWJH83');
</script>
</html>
