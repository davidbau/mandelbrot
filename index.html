<title>Mandelbrot</title>
<style>
body { font-family: Arial; background: #888}
td.c { height:1px; width: 1px; }
</style>
<body>
<div id=text style=margin:0;background:#aaa;height:100%;width:100%>
<div style="margin:0;padding:1 4;font-size:9pt;background:#aaa">

<h4 style=margin-top:3;margin-bottom:6>
Javascript Mandelbrot Set Fractal Viewer
</h4>

<p style=margin-top:6;margin-bottom:6>
<em>z<sup>2</sup>+c</em> is iterated for each complex number <em>c</em>.  Points are colored by <a href="http://warp.povusers.org/Mandelbrot/">counting iterations</a> to divergence; black points stay bounded. Click to zoom.

<p style=margin-top:6;margin-bottom:6>
Works best in <a href="http://www.google.com/chrome">Chrome</a>.

<p style=margin-top:8;margin-bototm:0;text-align:right>
- <a href="http://davidbau.com/archives/2009/09/27/mandelbrot.html">David Bau</a>
</div>
</div>

<script>

var gridcols = 5;
var dims = Math.max(32,
  Math.floor((document.body.clientWidth - 64) / gridcols) - 16);
var dims2 = dims * dims;
var surfaces = [];
var gridboards = 0;
var steps = 0;
var unknowncolor = "rgb(0,0,0)";
var convergence = 1.0 / (1 << 21);

document.write(
  '<center><table style=table-layout:fixed ' +
  'border=0 cellpadding=0 cellspacing=16 id=grid>');
for (var r = 0; r < 2; ++r) {
  document.write('<tr>');
  for (var s = 0; s < gridcols; ++s) {
    document.write('<td valign=top ' +
       'style=height:' + dims + ';width:' + dims + '></td>');
  }
  document.write('</tr>');
}
document.write('</table></center>')

function grid() {
  return document.getElementById('grid');
}

grid().rows[1].cells[1].appendChild(document.getElementById('text'));

function compute(m, i, n, z, c, b, converge) {
  if (n[m]) return 0;
  var r = z[m * 2]
  var j = z[m * 2 + 1]
  var ra = r * r - j * j + c[m * 2];
  var ja = 2 * r * j + c[m * 2 + 1];
  var d = ra * ra + ja * ja;
  if (d > 4.0) {
    n[m] = i;
    return 1;
  }
  z[m * 2] = ra;
  z[m * 2 + 1] = ja;
  var rb = b[m * 2];
  if (Math.abs(rb - ra) <= converge) {
    var jb = b[m * 2 + 1];
    if (Math.abs(jb - ja) <= converge) {
      n[m] = -i;
      return 1;
    }
  }
  return 0;
}

function Surface(k, size, re, im) {
  this.k = k;
  this.sizes = [size, re, im];
  this.it = 1;
  var z = this.z = [];
  var c = this.c = [];
  var n = this.n = [];
  var b = this.b = [];
  this.s = null;
  this.un = dims2;
  for (var y = 0; y < dims; y++) {
    var j = (0.5 - (y / dims)) * size + im;
    for (var x = 0; x < dims; x++) {
      var r = ((x / dims) - 0.5) * size + re;
      z.push(r, j);
      c.push(r, j);
      if (r * r + j * j > 4) {
        n.push(1);
        this.un -= 1;
      } else {
        n.push(0);
      }
      b.push(r, j);
    }
  }
  this.fi = (this.un == dims2 ? 0 : 1);
}

Surface.prototype.iterate = function iterate() {
  this.it += 1;
  var converge = convergence / (1 << this.k);
  this.checks();
  this.checkb();
  var count = 0;
  var s = this.s;
  if (s === null) {
    for (var m = 0; m < dims2; ++m) {
      count += compute(m, this.it, this.n, this.z, this.c, this.b, converge);
    }
  } else {
    for (var t = 0; t < s.length; ++t) {
      count += compute(s[t], this.it, this.n, this.z, this.c, this.b, converge);
    }
  }
  this.un -= count;
  if (!this.fi && this.un != dims2) {
    this.fi = this.it;
  }
}

</script>
<script>
Surface.prototype.checks = function checks() {
  if (this.s === null) {
    if (this.un < 4096) {
      var news = [];
      for (var m = 0; m < dims2; ++m) {
        if (this.n[m]) continue;
        news.push(m);
      }
      this.s = news;
    }
  } else if (this.s.length < this.un / 2) {
    var news = [];
    for (var t = 0; t < this.s.length; ++t) {
      if (this.n[this.s[t]]) continue;
      news.push(this.s[t]);
    }
    this.s = news;
  }
}

Surface.prototype.checkb = function checkb() {
  var shift = this.it;
  while (shift & 1) shift = shift >> 1;
  if (shift) return;
  if (s === null) {
    for (var m = 0; m < dims2; ++m) {
      if (this.n[m]) continue;
      this.b[m * 2] = this.z[m * 2];
      this.b[m * 2 + 1] = this.z[m * 2 + 1];
    }
  } else {
    for (var t = 0; t < s.length; ++t) {
      var m = this.s[t];
      if (this.n[m]) continue;
      this.b[m * 2] = this.z[m * 2];
      this.b[m * 2 + 1] = this.z[m * 2 + 1];
    }
  }
}


function drawcolor(k, i) {
  var color = makecolor(k, i);
  var converged = makecolor(k, -i);
  var n = surfaces[k].n;
  var ctx = board(k).getContext('2d');
  for (var m = 0; m < dims2; ++m) {
    if (n[m] == i || n[m] == -i) {
      var x = m % dims;
      var y = (m - x) / dims;
      ctx.fillStyle = n[m] > 0 ? color : converged;
      ctx.fillRect(x, y, 1, 1);
    }
  }
}

function colornum(n) {
  if (n <= 0) { return "0"; }
  if (n < 16) { return (n * 17).toString(10); }
  return "255";
}

function makecolor(k, i) {
  if (i == 0) return unknowncolor;
  if (i < 0) return "rgb(0,0,0)";
  i -= surfaces[k].fi;
  var r = colornum(Math.max(-2, 8 - Math.abs(12 - k)) +
                   ((i - 2) >> ((k + 1) >> 1)));
  var g = colornum((i - 6 - (k >> 1)) >>
                   Math.min(6, ((k + 1) >> 1)));
  var b = colornum(Math.max(0, 12 - k) + ((i - 1) >>
                   Math.min(5, ((k + 1) >> 1))));
  return "rgb(" + r + "," + g + "," + b + ")";
}

function draw(k) {
  if (surfaces.length <= k) return;
  var n = surfaces[k].n;
  var ctx = board(k).getContext('2d');
  for (var m = 0; m < dims2; ++m) {
    var x = m % dims;
    var y = (m - x) / dims;
    ctx.fillStyle = makecolor(k, n[m]);
    ctx.fillRect(x, y, 1, 1);
  }
}

function drawall() {
  for (var k = 0; k < surfaces.length; ++k) {
    draw(k);
  }
}

function tablestring(k) {
  return "<canvas id=b_" + k + " width=" + dims + " height=" + dims + ">" +
         "</canvas>";
}

function progress() {
  var shift = steps++;
  var k = 0;
  while (1 << k & shift) k += 1;
  k = surfaces.length - 1 - (k % surfaces.length);
  surfaces[k].iterate();
  drawcolor(k, surfaces[k].it);
  setTimeout(progress, 0);
}

function absoluteLeft(target) {
  var left = 0;
  while (target) {
    left += target.offsetLeft;
    target = target.offsetParent;
  }
  return left;
}

function absoluteTop(target) {
  var top = 0;
  while (target) {
    top += target.offsetTop;
    target = target.offsetParent;
  }
  return top;
}
  

document.onmousedown = function(e) {
  if (!e) var e = window.target;
  var target = (e.target ? e.target : e.srcElement ? e.srcElement : null);
  if (target.nodeType == 3) target = target.parentNode;
  if (target.id) {
    var m = target.id.match(/b_(\d+)/);
    if (m) {
      var x = e.clientX + document.body.scrollLeft - absoluteLeft(target);
      var y = e.clientY + document.body.scrollTop - absoluteTop(target);
      cellclick(parseInt(m[1]), x + y * dims);
      return false;
    }
  }
  return true;
}

document.onmousemove = function(e) {
  if (!e) var e = window.target;
  var target = (e.target ? e.target : e.srcElement ? e.srcElement : null);
  if (target.nodeType == 3) target = target.parentNode;
  if (target.id) {
    var m = target.id.match(/b_(\d+)/);
    if (m) {
      var x = e.clientX + document.body.scrollLeft - absoluteLeft(target);
      var y = e.clientY + document.body.scrollTop - absoluteTop(target);
      var k = parseInt(m[1]);
      var j = x + y * dims;
      var title = 'c=' +
        formatcomplex(k, surfaces[k].c[j * 2], surfaces[k].c[j * 2 + 1]);
      if (surfaces[k].n[j]) {
        if (surfaces[k].n[j] > 0) {
          title += '\ndiverged in ' + surfaces[k].n[j];
        } else {
          title += '\nconverged';
        }
      } 
      target.setAttribute('title', title);
    }
  }
}

function formatcomplex(k, re, im) {
  var pix = surfaces[k].sizes[0] / dims;
  var digits = 0;
  while (pix < 1.0) {
    pix *= 10;
    digits += 1;
  }
  var rd = '' + Math.abs(re);
  var id = '' + Math.abs(im);
  var rs = re < 0.0 ? '\u2212' : '+';
  var is = im < 0.0 ? '\u2212' : '+';
  if (rd.length > digits + 2) rd = rd.substring(0, digits + 2);
  if (id.length > digits + 2) id = id.substring(0, digits + 2);
  return rs + rd + is + id + 'i';
}

function grid() {
  return document.getElementById('grid');
}

function ensurerow(k) {
  var r = (k - (k % gridcols)) / gridcols;
  var table = grid();
  while (table.rows.length <= r) {
    var index = table.rows.length;
    var row = table.insertRow(index);
    for (var c = 0; c < gridcols; ++c) {
      var cell = row.insertCell(c);
      cell.style.width = dims;
      cell.style.height = dims;
    }
  }
}

function makeboard(k) {
  var table = grid();
  while (gridboards <= k) {
    var c = gridboards % gridcols;
    var r = (gridboards - c) / gridcols;
    table.rows[r].cells[c].innerHTML = tablestring(gridboards);
    gridboards += 1;
  }
}

function showpreview(k) {
  if (k < gridboards) board(k).style.visiblility = 'hidden';
  var table = grid();
  var c = k % gridcols;
  var r = (k - c) / gridcols;
}

function hidepreview(k) {
  board(k).style.visiblility = 'visible';
  var table = grid();
  var c = k % gridcols;
  var r = (k - c) / gridcols;
}

function hideboardspast(k) {
  for (var j = 0; j <= k && j < gridboards; ++j) {
    board(j).style.visibility = 'visible';
  }
  for (var j = k + 1; j < gridboards; ++j) {
    board(j).style.visibility = 'hidden';
  }
}

function board(k) {
  return document.getElementById("b_" + k);
}

function cellclick(k, m) {
  if (k >= surfaces.length) return;
  hideboardspast(k);
  ensurerow(k + 1);
  showpreview(k + 1);
  setTimeout(function() { cellclickdelay(k, m); }, 2);
}

function cellclickdelay(k, m) {
  if (k >= surfaces.length) return;
  makeboard(k + 1);
  hideboardspast(k + 1);
  osize = surfaces[k].sizes[0];
  ore = surfaces[k].sizes[1];
  oim = surfaces[k].sizes[2];
  cx = m % dims;
  cy = (m - cx) / dims;
  nsize = osize / 4;
  nre = ore + ((cx / dims) - 0.5) * osize;
  nim = oim + (0.5 - (cy / dims)) * osize;
  if (surfaces.length > k + 1) surfaces.length = k + 1;
  surfaces.push(new Surface(k + 1, nsize, nre, nim));
  hidepreview(k + 1);
  draw(k + 1);
}

function start() {
  surfaces.push(new Surface(0, 3.0, -0.5, 0.0));
  makeboard(0);
  draw(0);
  hidepreview(0);
  progress();
}

ensurerow(0);
showpreview(0);
setTimeout(start, 0);
</script>
