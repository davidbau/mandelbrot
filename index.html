<!doctype html>
<html>
<head>
<title>Mandelbrot Explorer</title>
<meta name="description" content="Beautiful, fast, and accurate exploration of the Mandelbrot Set online. Click to zoom. Hover to see orbits. M makes a smooth animation of your zoom path.">
<meta name="viewport" content="width=device-width">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="shortcut icon" type="image/png" href="favicon-128x128.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="favicon-180x180.png">
<link rel="apple-touch-icon" type="image/png" sizes="192x192" href="favicon-192x192.png">
<link rel="apple-touch-icon" type="image/png" sizes="512x512" href="favicon-512x512.png">
<!--
Written by David Bau as a Javascript example in 2009; updated in 2020
to handle high device pixel ratios, show orbits, and report periodicity.
Keyboard controls added in 2022, and quad-precision perturbations,
additional exponents, and movie generation added in 2024.

URL options: use ?grid=3 to select 3-column view,
                    &c=-0.14-0.65i to set center,
                and &s=0.5 to set viewed size.

Implementation notes.  To minimize computation, the code identifies both
points that diverge and points that converge.  It uses a method that can
identiify convergence to periodic cylces of arbitrarily long length.
After the number of unknown points is less than half the visual field,
it computes the remaining points sparsely, avoiding iterating over the
already-known points.
-->
<style>
body { font-family: Arial; background: #888; margin: 14px;}
canvas { vertical-align:bottom; cursor:crosshair; user-select: none; }
#grid > div, #text, #movie > div { display: inline-block; margin: 10px;
  position: relative; vertical-align: top; background: rgba(90, 90, 90, 0.5); }
#grid { color: yellow }
#grid > div:only-child .closebox { display: none; }
#grid:empty ~ #text { display: none; }
#text { text-align: left; width: auto; background:#aaa; margin: 10px;
  position:relative;padding:3px 8px;font-size: 11pt }
.closebox { position: absolute; right: 3px; top: 0; cursor: pointer;
  transition: opacity 0.3s; user-select: none; }
.closebox:after { content: '\00d7'; font-size: 20px; }
.closebox:active:after { -webkit-text-stroke: 2px; opacity: 0.8; }
.closebox:hover { font-weight: bold; }
.rect { position: absolute; height: 0; width: 0;
  pointer-events: none; opacity: 0.7; transition: opacity 0.3s; }
.rect:after { content: ''; display: block; position: absolute;
  top: 0; bottom: 0; left: 0; right: 0; border: 1px solid yellow;
  box-shadow: 0px 0px 4px 1px #880; }
.circle .rect:after { border-radius: 100px; }
.hidemarks .rect { opacity: 0; }
.overlay { position: absolute; pointer-events: none; opacity: 0.8;
  top:0; left:0; z-index:1; transition: opacity 0.3s }
.zoomnum { position:absolute; display:inline-block; right:0; bottom:-11pt;
  text-decoration: none; font-size: 11pt; color: yellow; min-width: 25%;
  text-align:right; transition: opacity 0.3s; z-index: 1; cursor: pointer;
  user-select: none; }
.zoomnum[href]:hover { text-decoration: underline; }
body.hidemarks .overlay { opacity: 0; }
body.hidemarks .zoomnum { opacity: 0; }
body.hidemarks #grid .closebox { opacity: 0; }
div.status { display: none; }
div:hover a div.status { /* tooltips */
  display: block; position: absolute; top: 12.5pt; right: 0;
  width: auto; background-color: #ddd; color: #444;
  font: 11pt Arial; text-align: right; white-space: pre;
  padding: 3px 7px; box-shadow: 2px 2px 5px #777;
  pointer-events: none; z-index: 2;
  opacity: 0; transition: opacity 0.25s ease;
}
div:hover a:focus div.status, div:hover a:hover div.status {
  opacity: 0.95;
}
body.starting div#b_0:after { display: flex; position: absolute;
  top: 0; left: 0; width: 100%; height: 100%; align-items: center;
  justify-content: center; content:"Starting..."; color: white;
  z-index: -1; background: rgb(32,16,64); }
</style>
</head>
<body class="starting">
<center>
<div id=movie></div>
<div id=grid></div>
<div id=text style="max-width: 442px">
<div class=closebox></div>

<h4 style="margin-top:3px;margin-bottom:6px">
Mandelbrot Set Fractal Viewer
</h4>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> is iterated for each <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">complex number</a> <em>c</em>.  Colors show <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iterations</a> to divergence; black points converge or cycle.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Tap">Click</span> to zoom.</b>  <span mobile="">Click zoom number to enlarge.  Right-click to save images, <b>M</b> to make and save a movie.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Yellow dots show <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbits</a></b>.  Red dots show limit cycles.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>About iterations.</b> This viewer shows more fractal detail over time by refining iterations to infinity as you explore. The longer you wait, the more detail is shown.
After thousands or millions of iterations, you can resolve the finest details in the most complex parts of the fractal.
See information on iterations, progress, and coordinates by <span mobile="tapping">hovering over</a> the yellow zoom number under each window.
<span mobile="Holding your fingertip">Moving your mouse</span> over fractal content will animate the orbit of <em>z</em> values for each location <em>c</em>, revealing the complex boundary dynamics that have fascinated mathematicians.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Making a path.</b>
Each <span mobile="tap">click</span> on the fractal starts a new parallel computataion at a higher zoom level at the selected location; point at a window to prioritize its iterations.
After you zoom beyond trillion-fold magnification, things slow down a bit as a quad-precision perturbation algorithm resolves fine details to more than 30 digits of accuracy.
Once you have crafted an interesting path that shows the detail you want, you can <a class="moviemode">create and download your own Mandelbrot zoom video</a> or bookmark your URL to save and share your path.
To create high-quality images and videos, this viewer computes subpixels with a <span class="pixelratio">2</span>:1 ratio<span mobile="">, and that can be increased to create more precise displays</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>More commands:</b>
<b>I</b> zooms in;
<b mac="&#8984;">Ctrl</b>-click to zoom in-place;
<b>H</b> shrinks and <b>G</b> grows each window;
<b>R</b> reopens midway windows;
<b>C</b> recenters all;
<b>Y</b> changes color scheme;
<b>U</b> highlights unfinished pixels;
<b>X</b> increases and <b>Z</b> decreases the <em>z</em> exponent;
<b>F</b> increases and <b>D</b> decreases the pixel ratio;
<b>M</b> makes a movie that follows your path;
<nobr><b>?</b> shows this help.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a>
</div>

</center>

<script>
class Config {
  constructor() {
    this.vw = window.innerWidth || document.documentElement.clientWidth;
    this.dgc = Math.min(3, Math.ceil(this.vw / 501));
    this.gridcols = this.dgc;
    this.exponent = 2;
    this.firstr = [-0.5, 0];
    this.firstj = [0.0, 0];
    this.firstsize = 3.0;
    this.pixelRatio = Math.max(Math.ceil(window.devicePixelRatio || 1), 2);
    this.zoomfactor = 5;
    this.cssDims = 0;
    this.dims = 0;
    this.dims2 = 0;
    this.ukcs = ["#000", "#888", "#fff", "yellow", "red", "rgb(32,16,64)"];
    this.scheme = 'iceblue';
    this.unknowncolor = "#000";
    this.mobile = ('ontouchstart' in document.documentElement);
    this.mac = (navigator.platform.indexOf('Mac') == 0);
    this.defineColorSchemes();
  }

  defineColorSchemes() {
    this.colorSchemes = {
      iceblue: (i, frac, s) => {
        // Current implementation
        let ff = Math.pow(frac, 2);
        let fr = Math.pow(frac, 0.333);
        let fg = Math.pow(frac, 3);
        let g = intcolor(Math.max(fg, Math.min(fr, i * Math.pow(s, 0.33) / 64)));
        let r = intcolor(Math.min(fr, i * Math.pow(s, 0.22) / 64));
        let b = intcolor(ff / 3 + 0.667);
        return `rgb(${r},${g},${b})`;
      },
      warm: (i, frac, s) => {
        let hue = (Math.log(i + 20) * 200) % 360;
        let chroma = 100 - frac ** 2 * 40;
        let light = 100 * Math.max(frac ** 3, Math.min(frac, i * s ** 0.33 / 64));
        return hclColor(hue, chroma, light);
      },
      /*
      gray: (i, frac) => {
        frac = Math.max(frac, frac > 0.1 ? fracIter : 0);
        let value = Math.floor(frac * 255);
        return `rgb(${value},${value},${value})`;
      },
      */
      // Add more color schemes here
    };
    this.colorSchemes.all = Object.keys(this.colorSchemes);
  }

  initSizes() {
    this.cssDims = Math.max(32, Math.floor((this.vw - 28) / this.gridcols) - 20);
    this.dims = Math.floor(this.cssDims * this.pixelRatio);
    this.dims2 = this.dims * this.dims;
    for (let el of document.getElementsByClassName('pixelratio')) {
      el.innerText = this.pixelRatio;
    }
  }

  updateExponent(newExponent) {
    if (newExponent < 2) { return; }
    this.exponent = newExponent;
    for (let el of document.getElementsByClassName('exponent')) {
      el.innerText = this.exponent;
    }
    if (this.firstsize == 3) {
      this.firstr = [this.exponent > 2 ? 0.0 : -0.5, 0];
      this.firstj = [0.0, 0];
    }
  }

  firststate() {
    return {sizes:[[this.firstsize, this.firstr, this.firstj]], hidden:[]};
  }
}

class Board {
  constructor(k, size, re, im, config) {
    this.k = k;
    this.config = config;
    this.it = 0;
    this.fi = 0;
    this.zz = []; // current iterate for each pixel
    this.cc = []; // current constant for each pixel
    this.nn = []; // iterations when diverged / (neg) converged
    this.bb = []; // recent remembered z
    this.pp = []; // iteration at which converged within epsilon2
    this.ss = null; // sparse list of indexes to compute
    this.un = config.dims2;
    this.di = 0;
    this.hi = [[config.dims2, 0, 0, 1]];
    this.sizes = [size, toQd(re), toQd(im)];
    this.effort = 1;
    this.pix = this.sizes[0] / this.config.dims;
    this.epsilon = Math.min(1e-12, this.pix / 10);
    this.epsilon2 = Math.min(1e-9, this.pix * 10);
  }

  initboard(size, re, im) {
    this.it = 1;
    let c = this.cc;
    let n = this.nn;
    let p = this.pp;
    for (let y = 0; y < this.config.dims; y++) {
      let jFrac = (0.5 - (y / this.config.dims));
      let j = jFrac * size + im[0];
      for (let x = 0; x < this.config.dims; x++) {
        let rFrac = ((x / this.config.dims) - 0.5);
        let r = rFrac * size + re[0];
        c.push(r, j);
        n.push(0);
        p.push(0);
      }
    }
    this.zz = c.slice();
    this.bb = c.slice();
    this.fi = (this.un == this.config.dims2 ? 0 : 1);
  }

  iterate() {
    const i = this.it;
    const z = this.zz;    // current iterate for each pixel
    const c = this.cc;    // current constant for each pixel
    const n = this.nn;    // number of iterations before conv/divergence
    const b = this.bb;    // recent remembered z
    const p = this.pp;    // iteration at which converged within epsilon2
    const pix = this.pix;
    const epsilon = this.epsilon;
    const epsilon2 = this.epsilon2;
    let s = this.ss;    // speedy list of indexes to compute
    let count = 0;
    // head and tail factor i into an odd num and largest power of 2.
    let head = i, tail = 1;
    while ((head & 1) == 0) { head >>= 1; tail <<= 1; }
    if (s === null && this.un <= z.length / 4) {
      let news = [];
      for (let m = 0; m < this.config.dims2; ++m) {
        if (n[m]) continue;
        news.push(m);
      }
      s = this.ss = news;
    }
    if (s === null) {
      if (head <= tail) {
        for (let m = 0; m < this.config.dims2; ++m) {
          if (n[m]) continue;
          b[m * 2] = z[m * 2];
          b[m * 2 + 1] = z[m * 2 + 1];
          p[m] = 0;
        }
      }
      let diverged = 0, a;
      for (let m = 0; m < this.config.dims2; ++m) {
        a = this.compute(m, i, n, z, c, b, p, epsilon, epsilon2);
        if (a) { count += 1; }
        if (a > 0) { diverged += 1; }
      }
      this.un -= count;
      this.di += diverged;
    } else {
      if (s.length > this.un * 1.25) {
        let news = [];
        for (let t = 0; t < s.length; ++t) {
          if (n[s[t]]) continue;
          news.push(s[t]);
        }
        s = this.ss = news;
      }
      if (head <= tail) {
        for (let t = 0; t < s.length; ++t) {
          let m = s[t];
          if (n[m]) continue;
          b[m * 2] = z[m * 2];
          b[m * 2 + 1] = z[m * 2 + 1];
          p[m] = 0;
        }
      }
      let diverged = 0, a;
      for (let t = 0; t < s.length; ++t) {
        a = this.compute(s[t], i, n, z, c, b, p, epsilon, epsilon2);
        if (a) { count += 1; }
        if (a > 0) { diverged += 1; }
      }
      this.un -= count;
      this.di += diverged;
    }
    if (this.hi[0][0] - this.un >= this.config.dims2 / 256) {
      this.hi.unshift([this.un, this.di, i]);
    }
    if (!this.fi && this.un != this.config.dims2) {
      this.fi = i;
    }
    this.it++;
    return count;
  }

  compute(m, i, n, z, c, b, p, epsilon, epsilon2) {
    if (n[m]) return 0;
    let m2 = m * 2;
    let m2i = m2 + 1;
    let r, j, r2, j2, ra, ja, rb, jb, db;
    r = z[m2];
    j = z[m2i];
    r2 = r * r;
    j2 = j * j;
    if (r2 + j2 > 4.0) {
      n[m] = i;
      return 1;
    }
    ra = r2 - j2;
    ja = 2 * r * j;
    for (let ord = 2; ord < this.config.exponent; ord++) {
      let rt = r * ra - j * ja;
      ja = r * ja + j * ra;
      ra = rt;
    }
    ra += c[m2];
    ja += c[m2i];
    z[m2] = ra;
    z[m2i] = ja;
    rb = b[m2];
    jb = b[m2i];
    db = Math.abs(rb - ra) + Math.abs(jb - ja);
    if (db <= epsilon2) {
      if (!p[m]) { p[m] = i; }
      if (db <= epsilon) {
        n[m] = -i;
        return -1;
      }
    }
    return 0;
  }

  draw(ctx) {
    if (this.un == this.config.dims2) {
      this.clearcanvas(ctx);
      return;
    }

    let colorcache = {};
    const fastcolor = (num) => {
      let result = colorcache[num];
      if (!result) {
        result = this.makecolor(num);
        if (colorcache.length < 10000) {
          colorcache[num] = result;
        }
      }
      return result;
    };

    let n = this.nn;
    for (let m = 0; m < this.config.dims2; ++m) {
      let x = m % this.config.dims;
      let y = (m - x) / this.config.dims;
      ctx.fillStyle = fastcolor(n[m]);
      ctx.fillRect(x, y, 1, 1);
    }
  }

  clearcanvas(ctx) {
    ctx.fillStyle = this.makecolor(0);
    ctx.fillRect(0, 0, this.config.dims, this.config.dims);
  }

  drawcolor(ctx, i) {
    let color = this.makecolor(i);
    let converged = this.makecolor(-i);
    let n = this.nn;
    for (let m = 0; m < this.config.dims2; ++m) {
      if (n[m] == i || n[m] == -i) {
        let x = m % this.config.dims;
        let y = (m - x) / this.config.dims;
        ctx.fillStyle = n[m] > 0 ? color : converged;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  }

  makecolor(i) {
    if (i == 0) return this.config.unknowncolor;
    if (i < 0) return 'black';
    let j = 0;
    for (; i < this.hi[j][2]; j += 1) {}
    // frac of pixels done.
    let frac = (this.config.dims2 - this.hi[j][0]) / this.config.dims2;
    return this.config.colorSchemes[this.config.scheme](
       i, frac, this.sizes[0]);
  }

  currentc(j) {
    return [toQd(this.cc[j * 2]), toQd(this.cc[j * 2 + 1])];
  }

  currentz(j) {
    return [toQd(this.zz[j * 2]), toQd(this.zz[j * 2 + 1])];
  }

  uninteresting() {
    // Boring: nothing computed, or done with less than 5 colors
    return this.di <= 0 || (this.un == 0 && this.hi.length <= 5);
  }

  debugStatus() {
    const debugGraph = this.renderHiGraph(600, 300);
    return `<img src="${debugGraph}" style="width:300px;height:150px">`;
  }

  renderHiGraph(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    const hi = this.hi;
    const scale = [
      (y) => { return y / this.config.dims2; },
      (y) => { return y / this.config.dims2; },
      (y) => { return y / hi[Math.floor(hi.length / 8)][2] / 2; },
      (y) => { return y },
    ];
    const barWidth = width / (hi.length * 4);

    // Background
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);

    // Draw bars
    const colors = ['red', 'green', 'blue', 'purple'];
    hi.forEach((row, i) => {
      row.forEach((value, j) => {
        const x = i * 4 * barWidth + j * barWidth;
        const barHeight = scale[j](value) * (height - 20);
        ctx.fillStyle = colors[j];
        ctx.fillRect(x, height - barHeight - 10, barWidth, barHeight);
      });
    });

    // Draw x-axis
    ctx.strokeStyle = 'black';
    ctx.beginPath();
    ctx.moveTo(0, height - 10);
    ctx.lineTo(width, height - 10);
    ctx.stroke();

    // Add labels
    ctx.font = '20px Arial';
    ctx.fillStyle = 'red';
    ctx.fillText(`Unknown: ${this.un}`, 5, 30);
    ctx.fillStyle = 'green';
    ctx.fillText(`Diverged: ${this.di}`, 5, 60);
    ctx.fillStyle = 'purple';
    ctx.fillText(`iterFrac: ${this.hi[0][3]}`, 5, 90);

    return canvas.toDataURL();
  }
}

class PerturbationBoard extends Board {
  constructor(k, size, re, im, config) {
    super(k, size, re, im, config);
    this.quadIndexes = [];
    this.pertIndexes = [];
    // Bail when perturbation exceeds half the digits of precision
    this.perturbationThreshold = Math.min(0.01, Math.sqrt(1e15 * (size / config.dims)));
    // For scheduling: each step is about 10x effort of default board.
    this.effort = 10;
  }

  initboard(size, re, im) {
    this.it = 1;
    this.cc = new Array(this.config.dims2).fill(null);
    this.nn = new Array(this.config.dims2).fill(0);
    this.pp = new Array(this.config.dims2).fill(0);
    const gridSize = Math.ceil(this.config.dims / 17);
    const step = this.config.dims / gridSize;
    const offset = step / 2;
    const pix = size / this.config.dims;
    re = toQd(re);
    im = toQd(im);

    for (let gy = 0; gy < gridSize; gy++) {
      let ry = Math.floor(gy * step + offset);
      let jFrac = (0.5 - (ry / this.config.dims));
      let ci = qdAdd(im, qdScale(toQd(jFrac), size))
      for (let gx = 0; gx < gridSize; gx++) {
        let rx = Math.floor(gx * step + offset);
        let rFrac = ((rx / this.config.dims) - 0.5);
        let refIndex = ry * this.config.dims + rx;
        let cr = qdAdd(re, qdScale(toQd(rFrac), size));

        // Initialize reference point
        let c = [cr[0], cr[1], ci[0], ci[1]];  // Quad-precision
        this.cc[refIndex] = c;
        this.quadIndexes.push(refIndex);

        // Initialize perturbations around this reference point
        const minY = Math.max(0, Math.floor(ry - offset));
        const maxY = Math.min(this.config.dims - 1, Math.ceil(ry + offset));
        const minX = Math.max(0, Math.floor(rx - offset));
        const maxX = Math.min(this.config.dims - 1, Math.ceil(rx + offset));
        for (let py = minY; py <= maxY; py++) {
          const dci = (ry - py) * pix;
          for (let px = minX; px <= maxX; px++) {
            const dcr = (px - rx) * pix;
            const pertIndex = py * this.config.dims + px;
            if (this.cc[pertIndex] === null) {  // Avoid double-initialization
              this.cc[pertIndex] = [dcr, dci, refIndex];
              this.pertIndexes.push(pertIndex);
            }
          }
        }
      }
    }
    this.zz = this.cc.slice();
    this.bb = this.cc.slice();
  }

  iterate() {
    let i = this.it;
    let head = i, tail = 1;
    while ((head & 1) == 0) { head >>= 1; tail <<= 1; }
    let results = [0, 0, 0];

    // Iterate perturbation points
    const newQuadIndexes = [];
    let cache = { refIndex: null, binZpow: null };
    for (const index of this.pertIndexes) {
      if (!this.computePerturbation(index, cache)) {
        this.convertToQuadPrecision(index);
        newQuadIndexes.push(index);
      }
    }

    // Update index arrays
    if (newQuadIndexes.length > 0) {
      const newPertIndexes = [];
      let qi = 0;
      for (const index of this.pertIndexes) {
        if (newQuadIndexes[qi] == index) {
          qi += 1;
        } else {
          newPertIndexes.push(index);
        }
      }
      this.quadIndexes = this.quadIndexes.concat(newQuadIndexes);
      this.pertIndexes = newPertIndexes;
    }

    // Iterate quad-precision points
    for (const index of this.quadIndexes) {
      if (head <= tail && !this.nn[index]) {
        this.bb[index] = this.zz[index];
        this.pp[index] = 0;
      }
      results[this.compute(index) + 1] += 1;
    }

    // Tally progress
    let diverged = results[2];
    let count = results[0] + diverged;
    this.un -= count;
    this.di += diverged;
    if (this.hi[0][0] - this.un >= this.config.dims2 / 256) {
      const iterFrac = (i - this.hi[0][2]) / i;
      this.hi.unshift([this.un, this.di, i, iterFrac]);
    }
    if (!this.fi && this.un != this.config.dims2) {
      this.fi = i;
    }

    // Trim finished pixels from array.
    if (this.pertIndexes.length + this.quadIndexes.length > this.un * 1.25) {
      const trimmedQuadIndexes = []
      for (const index of this.quadIndexes) {
        if (this.nn[index]) continue;
        trimmedQuadIndexes.push(index);
      }
      // Switch to full quad when perturbations are a small fraction of the work
      if (this.pertIndexes.length < trimmedQuadIndexes.length * 0.5) {
        for (const index of this.pertIndexes) {
          this.convertToQuadPrecision(index);
          trimmedQuadIndexes.push(index);
        }
        this.pertIndexes = [];
      }
      this.quadIndexes = trimmedQuadIndexes;
    }

    this.it++;
    return count;
  }

  compute(m) {
    // Quad-precision compute
    if (this.nn[m]) return 0;
    let r = this.zz[m].slice(0, 2);
    let j = this.zz[m].slice(2, 4);
    let cr = this.cc[m].slice(0, 2);
    let cj = this.cc[m].slice(2, 4);

    let r2 = qdSquare(r);
    let j2 = qdSquare(j);
    if (qdGt(qdAdd(r2, j2), 4)) {
      this.nn[m] = this.it;
      return 1;
    }
    let ra = qdSub(r2, j2);
    let ja = qdMul(qdDouble(r), j);
    for (let ord = 2; ord < this.config.exponent; ord++) {
      let rt = qdSub(qdMul(r, ra), qdMul(j, ja));
      ja = qdAdd(qdMul(r, ja), qdMul(j, ra));
      ra = rt;
    }
    ra = qdAdd(ra, cr);
    ja = qdAdd(ja, cj);
    this.zz[m] = [...ra, ...ja];
    let rb = this.bb[m].slice(0, 2);
    let jb = this.bb[m].slice(2, 4);
    let db = qdAdd(qdAbs(qdSub(rb, ra)), qdAbs(qdSub(jb, ja)));
    db = db[0] + db[1];
    if (db <= this.epsilon2) {
      if (!this.pp[m]) { this.pp[m] = this.it; }
      if (db <= this.epsilon) {
        this.nn[m] = -this.it;
        return -1;
      }
    }
    return 0;
  }

  computePerturbation(index, cache) {
    const [cr, ci, refIndex] = this.cc[index];
    const [dr, di] = this.zz[index];

    // Switch to quad when approaching convergence.
    if (this.nn[refIndex] || this.pp[refIndex]) return false;

    // Compute binomial powers of z
    if (cache.refIndex !== refIndex) {
      const [zr, zr0, zi, zi0] = this.zz[refIndex];
      cache.refIndex = refIndex;
      cache.binZpow = this.computeBinZpow(zr, zi);
    }
    const binZpow = cache.binZpow;

    // Compute in (z+d)^n - z^n = nz^(n-1) d + (n(n-1)/2)z^(n-2) d^2...
    let r = dr;
    let i = di;
    for (const [bzr, bzi] of binZpow) {
      r += bzr;
      i += bzi;
      const rNew = r * dr - i * di;
      i = r * di + i * dr;
      r = rNew;
    }

    // Add perturbation in c
    r += cr;
    i += ci;

    if (this.isThresholdExceeded(r, i)) {
      return false;
    }

    this.zz[index] = [r, i];
    return true;
  }

  computeBinZpow(zr, zi) {
    const binZpow = [];
    let zrCurrent = zr, ziCurrent = zi;
    let coeff = this.config.exponent;

    for (let k = 1; k < this.config.exponent - 1; k++) {
      binZpow.push([coeff * zrCurrent, coeff * ziCurrent]);

      // Update z power
      const zrNew = zrCurrent * zr - ziCurrent * zi;
      ziCurrent = zrCurrent * zi + ziCurrent * zr;
      zrCurrent = zrNew;

      // Update coefficient for next iteration
      coeff *= (this.config.exponent - k) / (k + 1);
    }

    // Add the last element without computing the next z power or coefficient
    if (this.config.exponent > 1) {
      binZpow.push([coeff * zrCurrent, coeff * ziCurrent]);
    }

    return binZpow;
  }

  isThresholdExceeded(dr, di) {
    return Math.max(Math.abs(dr), Math.abs(di)) > this.perturbationThreshold;
  }

  isEscaped(r, i) {
    return r * r + i * i > 4;
  }

  convertToQuadPrecision(index) {
    const [dr, di] = this.zz[index];
    const [cr, ci, refIndex] = this.cc[index];
    this.zz[index] = qdcAdd(this.zz[refIndex], [dr, 0, di, 0]);
    this.cc[index] = qdcAdd(this.cc[refIndex], [cr, 0, ci, 0]);
  }

  isQuadPrecision(index) {
    return this.cc[index].length === 4;
  }

  currentc(j) {
    if (this.isQuadPrecision(j)) {
      const [re1, re2, im1, im2] = this.cc[j];
      return [[re1, re2], [im1, im2]];
    } else {
      const [dr, di, refIndex] = this.cc[j];
      const ref = this.cc[refIndex];
      const r = qdcAdd([ref[0], ref[1], ref[2], ref[3]], [dr, 0, di, 0]);
      return [[r[0], r[1]], [r[2], r[3]]];
    }
  }

  currentz(j) {
    if (this.isQuadPrecision(j)) {
      const [re1, re2, im1, im2] = this.zz[j];
      return [[re1, re2], [im1, im2]];
    } else {
      const refIndex = this.cc[j][2];
      const [dr, di] = this.zz[j];
      const ref = this.zz[refIndex];
      const r = qdcAdd([ref[0], ref[1], ref[2], ref[3]], [dr, 0, di, 0]);
      return [[r[0], r[1]], [r[2], r[3]]];
    }
  }

  draw(ctx) {
    let colorcache = {};
    const fastcolor = (num) => {
      let result = colorcache[num];
      if (!result) {
        result = this.makecolor(num);
        if (colorcache.length < 10000) {
          colorcache[num] = result;
        }
      }
      return result;
    };

    for (let m = 0; m < this.config.dims2; ++m) {
      let x = m % this.config.dims;
      let y = (m - x) / this.config.dims;
      ctx.fillStyle = fastcolor(this.nn[m]);
      ctx.fillRect(x, y, 1, 1);
    }
  }

  debugStatus() {
    return `pert: ${this.pertIndexes.length}, ` +
           `quad: ${this.quadIndexes.length}\n` +
           super.debugStatus();
  }
}

class Grid {
  constructor(config) {
    this.config = config;
    this.boards = [];
    this.gridboards = 0;
    this.focusk = null;
    this.urlListeners = [];
    this.zoomListeners = [];
  }

  makeBoard(k, size, re, im) {
    // Threshold for switching to PerturbationBoard
    const perturbationThreshold = 1e-15;

    if (size / this.config.dims < perturbationThreshold) {
      return new PerturbationBoard(k, size, re, im, this.config);
    } else {
      return new Board(k, size, re, im, this.config);
    }
  }

  currentGridState() {
    let state = { hidden: [], sizes: [] };
    for (let k = 0; k < this.boards.length; k++) {
      if (this.hiddencanvas(k)) {
        state.hidden.push(k);
      }
      state.sizes.push(this.boards[k].sizes);
    }
    return state;
  }

  updateLayout(state = null) {
    if (this.currentUpdateProcess) {
      this.currentUpdateProcess.abort();
    }
    if (state === null) {
      state = this.currentGridState();
    }
    this.config.initSizes();

    // Recreate the grid
    let gridElement = document.getElementById('grid');
    gridElement.innerHTML = '';
    this.gridboards = 0;

    // Recreate all canvases
    for (let k = 0; k < state.sizes.length; k++) {
      this.makecanvas(k);
      if (state.hidden.indexOf(k) >= 0) { this.hidecanvas(k); }
    }
    this.truncateboards(0);
    this.currentUpdateProcess = this.createUpdateProcess(state);
    this.currentUpdateProcess.start();
  }

  createUpdateProcess(state) {
    let aborted = false;
    let currentIndex = 0;

    const processNext = () => {
      if (aborted || currentIndex >= state.sizes.length) {
        if (!aborted) {
          this.notifyurl();
          this.notifyzoom();
        }
        this.currentUpdateProcess = null;
        return;
      }

      const k = currentIndex;
      if (!this.boards[k]) {
        this.boards[k] = this.makeBoard(k, state.sizes[k][0], state.sizes[k][1], state.sizes[k][2]);
      }
      this.boards[k].initboard(state.sizes[k][0], state.sizes[k][1], state.sizes[k][2]);
      this.boards[k].draw(this.canvas(k).getContext('2d'));
      if (state.hidden.indexOf(k) >= 0) { this.hidecanvas(k); }
      currentIndex++;
      setTimeout(processNext, 0);
    };

    return {
      start: () => {
        if (this.config.gridcols == 1) {
          setTimeout(processNext, 100);
        } else {
          processNext();
        }
      },
      abort: () => { aborted = true; }
    };
  }

  makecanvas(k) {
    let gd = document.getElementById('grid');
    while (this.gridboards <= k) {
      let dd = document.createElement('div');
      dd.id = 'b_' + this.gridboards;
      dd.innerHTML = this.canvasstring(this.gridboards);
      dd.className = 'hidemarks';
      gd.appendChild(dd);
      this.gridboards += 1;
    }
  }

  canvasstring(k) {
    let factor = 3.0 / (k < this.boards.length ? this.boards[k].sizes[0] :
      this.config.firstsize / Math.pow(this.config.zoomfactor, k));
    factor = formatScale(factor);
    return `<canvas width="${this.config.dims}" height="${this.config.dims}"` +
           ` style="height:${this.config.cssDims}px;width:${this.config.cssDims}px;">` +
           '</canvas>' +
           '<div class="closebox"></div>' +
           '<div class="rect"></div>' +
           `<canvas class=overlay width=${this.config.dims} height="${this.config.dims}"` +
           ` style="height:${this.config.cssDims}px;width:${this.config.cssDims}px;">` +
           '</canvas>' +
           `<a class="zoomnum" target="_blank" href="?grid=1">${factor}` +
           '<div class="status"></div></a>';
  }

  hidecanvas(k) {
    this.canvas(k).parentElement.style.display = 'none';
  }

  showcanvas(k) {
    this.canvas(k).parentElement.style.display = '';
  }

  hiddencanvas(k) {
    let b = this.canvas(k);
    return b && b.parentElement.style.display == 'none';
  }

  grid() {
    return document.getElementById('grid');
  }

  canvas(k) {
    let b = document.getElementById("b_" + k);
    return b && b.firstElementChild;
  }

  closebutton(k) {
      const board = this.canvas(k);
      return board && board.nextElementSibling;
  }

  rect(k) {
      const closeBtn = this.closebutton(k);
      return closeBtn && closeBtn.nextElementSibling;
  }

  overlay(k) {
      const rect = this.rect(k);
      return rect && rect.nextElementSibling;
  }

  truncateboards(k) {
    if (this.boards.length > k) {
      this.boards.length = k;
    }
  }

  removeboardspast(k) {
    if (this.gridboards > k) {
      for (let j = k + 1; j < this.gridboards; ++j) {
        this.canvas(j).parentElement.remove();
      }
      this.gridboards = k + 1;
    }
  }

  showAllBoards() {
    for (let j = 0; j < this.gridboards; ++j) {
      this.showcanvas(j);
    }
    this.notifyzoom();
  }

  truncatehiddenboards() {
    let j = this.gridboards - 1;
    for (; j > 0; j--) {
      if (!this.hiddencanvas(j)) {
        break;
      }
    }
    this.truncateboards(j + 1);
    this.removeboardspast(j);
    if (j == 0) {
      this.showcanvas(j);
    }
  }

  updateProgress(overtarget, k) {
    if (overtarget.tagName == 'A' && overtarget.classList.contains('zoomnum')) {
      if (this.config.mobile) {
        overtarget.removeAttribute('href');
      } else {
        overtarget.href = this.bigurl(k);
      }

      let statusDiv = overtarget.querySelector('.status');
      if (!statusDiv) return;

      // Regular status
      let regularStatus = 'center at ' +
        formatcomplex(k, this.boards[k].sizes[1], this.boards[k].sizes[2])
          .replaceAll('-', '\u2212') + '\n' +
        Math.floor(1000 * (1.0 - this.boards[k].un / this.config.dims2))/10.0  + '% done ' +
        'after ' + this.boards[k].it + ' iters';
      statusDiv.textContent = regularStatus;

      // Debug status
      if (overtarget.showDebug) {
        statusDiv.innerHTML += '\n' + this.boards[k].debugStatus();
      }
    }
    if (overtarget.matches(':hover')) {
      setTimeout(() => this.updateProgress(overtarget, k), 100);
    }
  }

  bigurl(k) {
    if (k >= this.boards.length) return;
    let osize = this.boards[k].sizes[0];
    let oexp = '';
    if (this.config.exponent != 2) {
      oexp = '&exponent=' + this.config.exponent;
    }
    let ore = this.boards[k].sizes[1];
    let oim = this.boards[k].sizes[2];
    return '?s=' + formatSize(osize) + oexp + '&c=' + formatcomplex(k, ore, oim) + '&grid=1';
  }

  clearseq(k) {
    const overlayElement = this.overlay(k);
    if (overlayElement) {
      let ctx = overlayElement.getContext('2d');
      ctx.clearRect(0, 0, this.config.dims, this.config.dims);
    }
  }

  onurlchange(callback) {
    this.urlListeners.push(callback);
  }

  notifyurl() {
    for (let cb of this.urlListeners) {
      cb();
    }
  }

  onzoomchange(callback) {
    this.zoomListeners.push(callback);
  }

  notifyzoom() {
    for (let cb of this.zoomListeners) {
      cb();
    }
  }
}

class ZoomManager {
  constructor(config, grid) {
    this.config = config;
    this.grid = grid;
    this.grid.onzoomchange(() => this.updateZoomRectangles());
  }

  showZoomRect(k, x, y, zf) {
    let s = this.grid.rect(k).style;
    let border = 1;
    let cssClass = '';
    if (zf > 50) {
      // Make rectangle visible if it is tiny.
      zf = 25;
      cssClass = 'circle';
    }
    this.grid.rect(k).parentElement.className = cssClass;
    s.top = (y * this.config.cssDims - this.config.cssDims / 2 / zf - border) + 'px';
    s.left = (x * this.config.cssDims - this.config.cssDims / 2 / zf - border) + 'px';
    s.width = (this.config.cssDims / zf + 2 * border) + 'px';
    s.height = (this.config.cssDims / zf + 2 * border) + 'px';
  }

  removeZoomRect(k) {
    let s = this.grid.rect(k).style;
    s.top = s.left = s.width = s.height = '';
    this.grid.rect(k).parentElement.className = 'hidemarks';
  }

  updateZoomRectangles() {
    let prevBoard = null;
    let prevK = 0;
    for (let k = 0; k < this.grid.boards.length; k++) {
      if (this.grid.hiddencanvas(k)) { continue; }
      let currBoard = this.grid.boards[k].sizes;
      if (prevBoard != null) {
        let x = qdSub(currBoard[1], prevBoard[1])[0] / prevBoard[0] + 0.5;
        let y = 0.5 - qdSub(currBoard[2], prevBoard[2])[0] / prevBoard[0];
        let zf = prevBoard[0] / currBoard[0];
        this.showZoomRect(prevK, x, y, zf);
      }
      prevBoard = currBoard;
      prevK = k;
    }
    if (prevBoard !== null) {
      this.removeZoomRect(prevK);
    }
  }

  zoomInAtCurrentPosition(hideCurrent) {
    let k = this.grid.boards.length - 1;
    if (this.grid.boards[k].uninteresting()) { return; }
    let osize = this.grid.boards[k].sizes[0];
    let ore = this.grid.boards[k].sizes[1];
    let oim = this.grid.boards[k].sizes[2];
    let rre = 0.5;
    if (k == 0 && qdEq(ore, -0.5) && qdEq(oim, 0)) {
      // Myreberg / Feigenbaum point
      ore = [-1.4011551890920506, 1.196330130384937e-17];
      rre = (ore[0] - this.grid.boards[0].sizes[1][0]) / this.grid.boards[0].sizes[0] + 0.5;
    }
    this.showZoomRect(k, rre, 0.5, this.config.zoomfactor);
    let nsize = osize / this.config.zoomfactor;
    let newBoard = this.grid.makeBoard(k + 1, nsize, ore, oim);
    newBoard.initboard(nsize, ore, oim);
    this.grid.boards.push(newBoard);
    this.grid.makecanvas(k + 1);
    if (hideCurrent) {
      this.grid.canvas(k).parentElement.style.display = 'none';
      this.updateZoomRectangles();
    }
    this.grid.removeboardspast(k + 1);
    this.grid.canvas(k + 1).parentElement.className = 'hidemarks';
    this.grid.canvas(k + 1).parentElement.scrollIntoView({ behavior: 'smooth' });
    newBoard.draw(this.grid.canvas(k + 1).getContext('2d'));
    this.grid.notifyurl();
  }

  cellclick(k, m, hideCurrent) {
    // Only accept clicks on cells with something computed in them.
    if (k >= this.grid.boards.length || this.grid.boards[k].uninteresting() ||
         this.grid.currentUpdateProcess) return;
    this.grid.truncateboards(k + 1);
    this.grid.removeboardspast(k + 1);
    setTimeout(() => { this.cellclickdelay(k, m, hideCurrent); }, 1);
  }

  cellclickdelay(k, m, hideCurrent) {
    if (k >= this.grid.boards.length || this.grid.currentUpdateProcess) return;
    let osize = this.grid.boards[k].sizes[0];
    let ore = this.grid.boards[k].sizes[1];
    let oim = this.grid.boards[k].sizes[2];
    let cx = m % this.config.dims;
    let cy = (m - cx) / this.config.dims;
    this.grid.removeboardspast(k + 1);
    this.showZoomRect(k, cx / this.config.dims, cy / this.config.dims, this.config.zoomfactor);
    this.grid.truncateboards(k + 1);
    // Do slow parts after a moment.
    setTimeout(() => {
      let nsize = osize / this.config.zoomfactor;
      let nre = qdAdd(ore, [((cx / this.config.dims) - 0.5) * osize, 0]);
      let nim = qdAdd(oim, [(0.5 - (cy / this.config.dims)) * osize, 0]);
      let newBoard = this.grid.makeBoard(k + 1, nsize, nre, nim);
      newBoard.initboard(nsize, nre, nim);
      this.grid.boards.push(newBoard);
      this.grid.makecanvas(k + 1);
      if (hideCurrent) {
        this.grid.canvas(k).parentElement.style.display = 'none';
        this.updateZoomRectangles();
      }
      this.grid.canvas(k + 1).parentElement.className = 'hidemarks';
      this.grid.canvas(k + 1).parentElement.scrollIntoView({ behavior: 'smooth' });
      newBoard.draw(this.grid.canvas(k + 1).getContext('2d'));
      this.grid.showcanvas(k + 1);
      this.grid.notifyurl();
    }, 10);
  }

  centerBoards() {
    let k = this.grid.boards.length - 1;
    let ore = this.grid.boards[k].sizes[1];
    let oim = this.grid.boards[k].sizes[2];
    this.showZoomRect(
      0, 0.5 + (ore[0] - this.grid.boards[0].sizes[1][0]) / this.grid.boards[0].sizes[0],
         0.5 - (oim[0] - this.grid.boards[0].sizes[2][0]) / this.grid.boards[0].sizes[0],
         this.grid.boards[0].sizes[0] / this.grid.boards[1].sizes[0]);
    for (k = 1; k < this.grid.boards.length - 1; k += 1) {
      this.showZoomRect(
          k, 0.5, 0.5, this.grid.boards[k].sizes[0] / this.grid.boards[k+1].sizes[0]);
      if (qdCompare(this.grid.boards[k].sizes[1], ore) ||
          qdCompare(this.grid.boards[k].sizes[2], oim)) {
        let nsize = this.grid.boards[k].sizes[0];
        this.grid.boards[k] = this.grid.makeBoard(k + 1, nsize, ore, oim);
        this.grid.boards[k].clearcanvas(this.grid.canvas(k).getContext('2d'));
        this.grid.boards[k].initboard(nsize, ore, oim);
        this.grid.boards[k].draw(this.grid.canvas(k).getContext('2d'));
        this.grid.clearseq(k);
      }
    }
    this.grid.notifyurl();
  }
}

class URLHandler {
  constructor(config, grid) {
    this.config = config;
    this.grid = grid;
    this.grid.onurlchange(x => this.updateurl());
  }

  updateurl() {
    if (history.replaceState) {
      history.replaceState(null, '', this.currenturl());
    }
  }

  parseUrl() {
    let startstate = { hidden: [], sizes: [] };
    let opts = document.location.search.split('&');
    for (let j in opts) {
      let m;
      if (null !== (m = opts[j].match(/exponent=(\d+)/))) {
        this.config.exponent = Math.max(2, parseInt(m[1]));
        if (this.config.exponent > 2) { this.config.firstr = [0.0, 0]; }
        for (let el of document.getElementsByClassName('exponent')) {
          el.innerText = this.config.exponent;
        }
      }
      if (null !== (m = opts[j].match(/grid=(\d+)/))) {
        this.config.gridcols = Math.max(1, parseInt(m[1]));
      }
      if (null !== (m = opts[j].match(/s=([-+]?\d?\.?\d+(?:e[-+]\d+)?)/))) {
        this.config.firstsize = parseFloat(m[1]);
      }
      if (null !== (m = opts[j].match(/pixelratio=(\d+)/))) {
        this.config.pixelRatio = Math.max(1, parseInt(m[1]));
      }
      if (null !== (m = opts[j].match(/c=([-+\d\.ei,]+)/))) {
        for (let coords of m[1].split(',')) {
          m = coords.match(/([-+]?\d?\.?\d+(?:e[-+]\d+)?)(?:([-+]\d?\.?\d+(?:e[-+]\d+)?)i)?/);
          startstate.sizes.push([
            this.config.firstsize / Math.pow(this.config.zoomfactor, startstate.sizes.length),
            m != null && m[1] ? qdParse(m[1]) : (startstate.sizes.length > 0 ?
                startstate.sizes[startstate.sizes.length - 1][1] : this.config.firstr),
            m != null && m[2] ? qdParse(m[2]) : (startstate.sizes.length > 0 ?
                startstate.sizes[startstate.sizes.length - 1][2] : this.config.firstj)
          ]);
        }
      }
      if (null !== (m = opts[j].match(/h=([\d,]+)/))) {
        startstate.hidden = m[1].split(',').map(x=>parseInt(x));
      }
      if (null !== (m = opts[j].match(/scheme=(\w+)/))) {
        if (this.config.colorSchemes.all.includes(m[1])) {
          this.config.scheme = m[1];
        }
      }
    }
    if (startstate.sizes.length == 0) {
      startstate.sizes = this.config.firststate().sizes;
    }

    return startstate;
  }

  currenturl() {
    let state = this.grid.currentGridState();
    let compactc = '';
    let commas = '';
    let prev = [this.config.firstr, this.config.firstj];
    let prevj = -1;
    for (let j = 0; j <= state.sizes.length; j++) {
      if (j < state.sizes.length &&
          !qdCompare(state.sizes[j][1], prev[0]) &&
          !qdCompare(state.sizes[j][2], prev[1])) {
        commas += ',';
      } else {
        if (prevj >= 0) {
          compactc += formatcomplex(j - 1, state.sizes[prevj][1], state.sizes[prevj][2]) + ',';
        }
        compactc += commas;
        if (j < state.sizes.length) {
          commas = '';
          prev = [state.sizes[j][1], state.sizes[j][2]];
          prevj = j;
        }
      }
    }
    compactc = compactc.slice(0, -1);
    let url =
           (state.sizes[0][0] != 3.0 ? '&s=' + formatSize(this.grid.boards[0].sizes[0]) : '') +
           (this.config.exponent != 2 ? '&exponent=' + this.config.exponent : '') +
           (compactc.length ? '&c=' + compactc : '') +
           (this.config.gridcols != this.config.dgc ? '&grid=' + this.config.gridcols : '') +
           (state.hidden.length ? '&h=' + state.hidden : '') +
           (this.config.scheme != 'iceblue' ? '&scheme=' + this.config.scheme : '') +
           (this.config.pixelRatio != 2 ? '&pixelratio=' + this.config.pixelRatio : '');
    return '?' + url.replace('&', '');
  }
}

class EventHandler {
  constructor(explorer) {
    this.explorer = explorer;
  }

  setup() {
    document.onmousedown = this.onmousedown.bind(this);
    document.onmousemove = this.onmousemove.bind(this);
    document.body.onkeydown = this.onkeydown.bind(this);
    document.body.onmouseover = this.onmouseover.bind(this);
    document.body.onmousedown = (e) => {
      if (e.target.className == 'closebox') {
        e.stopPropagation();
      }
    };
    document.body.onclick = (e) => {
      if (e.target.className == 'closebox' && !explorer.grid.currentUpdateProcess) {
        e.target.parentElement.style.display = 'none';
        this.explorer.grid.truncatehiddenboards();
        this.explorer.zoomManager.updateZoomRectangles();
        this.explorer.urlHandler.updateurl();
      }
    };
  }

  onmousedown(e) {
    let target = this.eventtarget(e);
    if (this.explorer.movieMode.active && (target.id != 'moviescale')) {
      this.explorer.movieMode.toggle();
    }
    if (e.button != 0) { return true; }
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (e.target.tagName == 'A') {
        if (m && !this.explorer.config.mobile) {
          e.target.href = this.explorer.grid.bigurl(m[1]);
        }
        return true;
      }
      if (m) {
        let p = this.pointInTarget(e, target);
        let k = parseInt(m[1]);
        this.explorer.zoomManager.cellclick(k, p.x + p.y * this.explorer.config.dims,
          e.metaKey || e.ctrlKey);
        return false;
      }
    }
    return true;
  }

  onmousemove(e) {
    let target = this.eventtarget(e);
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (m) {
        let p = this.pointInTarget(e, target);
        let k = parseInt(m[1]);
        let j = p.x + p.y * this.explorer.config.dims;
        this.explorer.orbitComputer.updateOrbit(k, j, target);
      }
    }
  }

  onkeydown(e) {
    if (this.explorer.movieMode.active &&
        ['Shift', 'Alt', 'Control', 'Meta', 'CapsLock'].indexOf(e.key) == -1) {
      this.explorer.movieMode.toggle();
      return;
    }
    // Pressing backspace will delete the last zoom.
    if (e.key == 'Backspace' && this.explorer.grid.boards.length > 1 &&
        !this.explorer.grid.currentUpdateProcess) {
      let k = this.explorer.grid.boards.length - 1;
      this.explorer.grid.truncateboards(k);
      this.explorer.grid.removeboardspast(k - 1);
      this.explorer.grid.truncatehiddenboards();
      this.explorer.urlHandler.updateurl();
    }
    // Pressing C will center all the zoom positions.
    if (e.key == 'c' && this.explorer.grid.boards.length > 1) {
      this.explorer.zoomManager.centerBoards();
    }
    // Pressing Y will cycle through the color schemes.
    if (e.key == 'y') {
      this.explorer.cycleColorScheme();
    }
    // Pressing U will cycle through the uncomputed colors.
    if (e.key == 'u') {
      this.explorer.cycleUnknownColor();
    }
    // Pressing I will zoom in at the same position.
    if (e.key == 'i') {
      this.explorer.zoomManager.zoomInAtCurrentPosition(e.metaKey || e.ctrlKey);
    }
    // Pressing ? will show the help window
    if (e.key == '?') {
      document.getElementById('text').style.display = 'block';
    }
    // G reduces the grid column count
    if (e.key === 'g' && this.explorer.config.gridcols > 1) {
      this.explorer.config.gridcols -= 1;
      this.explorer.grid.updateLayout();
    }
    // H increases the grid column count
    if (e.key === 'h') {
      this.explorer.config.gridcols += 1;
      this.explorer.grid.updateLayout();
    }
    // R will restore any hidden boards
    if (e.key === 'r') {
      this.explorer.grid.showAllBoards();
      this.explorer.urlHandler.updateurl();
    }
    // Increase the exponent
    if (e.key === 'x') {
      this.explorer.config.updateExponent(this.explorer.config.exponent + 1);
      this.explorer.grid.updateLayout(this.explorer.config.firststate());
    }
    // Decrease the exponent
    if (e.key === 'z' && this.explorer.config.exponent > 2) {
      this.explorer.config.updateExponent(this.explorer.config.exponent - 1);
      this.explorer.grid.updateLayout(this.explorer.config.firststate());
    }
    // Increase the pixel ratio
    if (e.key === 'f') {
      this.explorer.config.pixelRatio += 1;
      this.explorer.grid.updateLayout();
    }
    // Decrease the pixel ratio
    if (e.key === 'd' && this.explorer.config.pixelRatio > 1) {
      this.explorer.config.pixelRatio -= 1;
      this.explorer.grid.updateLayout();
    }
    // Toggle movie mode
    if (e.key === 'm' && this.explorer.grid.boards.length > 1) {
      this.explorer.movieMode.toggle();
    }
  }

  onmouseover(e) {
    document.body.className = 'hidemarks';
    this.explorer.grid.focusk = null;
    let target = this.eventtarget(e);
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (m) {
        let k = parseInt(m[1]);
        this.explorer.grid.focusk = k;
        if (this.explorer.grid.boards.length <= k) return;
        document.body.className = '';
        let overtarget = e.target;
        if (overtarget.tagName == 'A') {
          overtarget.showDebug = e.ctrlKey || e.metaKey;
          this.explorer.grid.updateProgress(overtarget, k);
        }
      } else if (target.id.startsWith('movie') && (!e.target || e.target.id != 'movie')) {
        document.body.className = '';
      }
    }
  }

  eventtarget(e) {
    let target = (e.target ? e.target : e.srcElement ? e.srcElement : null);
    while (target) {
      if (target.id) { return target; }
      target = target.parentNode;
    }
    return null;
  }

  pointInTarget(ev, target) {
    let se = document.scrollingElement || document.body;
    let x = (ev.clientX + se.scrollLeft - this.absoluteLeft(target)) *
            this.explorer.config.pixelRatio;
    let y = (ev.clientY + se.scrollTop - this.absoluteTop(target)) *
            this.explorer.config.pixelRatio;
    return { x: Math.round(x), y: Math.round(y) };
  }

  absoluteLeft(target) {
    let left = 0;
    while (target) {
      left += target.offsetLeft;
      target = target.offsetParent;
    }
    return left;
  }

  absoluteTop(target) {
    let top = 0;
    while (target) {
      top += target.offsetTop;
      target = target.offsetParent;
    }
    return top;
  }
}

class MovieMode {
  constructor(explorer) {
    this.explorer = explorer;
    this.active = false;
    this.movieCanvas = null;
    this.movieCtx = null;
    this.animationFrame = null;
    this.frameCanvases = [];
    this.mediaRecorder = null;
    this.recordedChunks = [];
    this.isRecording = false;
    this.recordedBlob = null;
    this.recordingMimeType = null;
    this.recordingMimeTypes = [
      'video/webm; codecs="vp8"',
      'video/webm; codecs="avc1.640029"',
      'video/webm',
      'video/mp4; codecs="avc1.640029"',
      'video/mp4',
    ];
  }

  toggle() {
    this.active = !this.active;
    this.explorer.scheduler.computationPaused = this.active;
    if (this.active) {
      this.startMovie();
    } else {
      this.stopMovie();
    }
  }

  startMovie() {
    this.explorer.grid.grid().style.display = 'none';
    this.explorer.movieContainer.style.display = 'block';
    this.createMovieCanvas();
    this.explorer.movieContainer.scrollIntoView({ behavior: 'smooth' });
    setTimeout(() => {
      document.body.className = '';
      this.preRenderFrames(() => {
        this.startMovieAnimation();
      });
    }, 20);
  }

  stopMovie() {
    this.explorer.grid.grid().style.display = 'block';
    this.explorer.movieContainer.style.display = 'none';
    this.stopMovieAnimation();
    this.removeMovieCanvas();
  }

  createMovieCanvas() {
    this.explorer.movieContainer.innerHTML = '<div>' +
      `<canvas width=${this.explorer.config.dims} height=${this.explorer.config.dims} ` +
      `style="width:${this.explorer.config.cssDims}px;` +
      `height:${this.explorer.config.cssDims}px"></canvas>` +
      `<a id="moviescale" class="zoomnum">Rendering movie...</a></div>`;
    this.movieCanvas = this.explorer.movieContainer.firstElementChild.firstElementChild;
    this.movieCtx = this.movieCanvas.getContext('2d');
    this.movieCtx.drawImage(this.explorer.grid.canvas(0), 0, 0);
  }

  removeMovieCanvas() {
    while (this.explorer.movieContainer.firstChild) {
      this.explorer.movieContainer.removeChild(this.explorer.movieContainer.firstChild);
    }
    this.movieCanvas = null;
    this.movieCtx = null;
  }

  preRenderFrames(after) {
    this.frameCanvases = [];
    let queueOneFrame = (k, after) => {
      return () => {
        let status = document.getElementById('moviescale');
        if (status) {
          status.textContent =
            `Rendering ${formatScale(3.0 / this.explorer.grid.boards[k].sizes[0])}`;
        }
        let canvas1 = null;
        let canvas2 = null;
        const n = this.explorer.grid.boards[k].nn;
        // Render with k-1 palette
        if (k > 0) {
          canvas1 = document.createElement('canvas');
          canvas1.width = canvas1.height = this.explorer.config.dims;
          const ctx1 = canvas1.getContext('2d');
          for (let y = 0; y < this.explorer.config.dims; y++) {
            for (let x = 0; x < this.explorer.config.dims; x++) {
              const m = y * this.explorer.config.dims + x;
              const i = n[m];
              ctx1.fillStyle = this.explorer.grid.boards[k - 1].makecolor(i);
              ctx1.fillRect(x, y, 1, 1);
            }
          }
          if (this.explorer.config.unknowncolor != '#000') {
            ctx1.strokeStyle = 'yellow';
            ctx1.lineWidth = this.explorer.config.pixelRatio * this.explorer.config.zoomfactor;
            ctx1.strokeRect(0, 0, this.explorer.config.dims, this.explorer.config.dims);
          }
        }
        // Render with k+1 palette
        if (k < this.explorer.grid.boards.length - 1) {
          canvas2 = document.createElement('canvas');
          canvas2.width = canvas2.height = this.explorer.config.dims;
          const ctx2 = canvas2.getContext('2d');
          for (let y = 0; y < this.explorer.config.dims; y++) {
            for (let x = 0; x < this.explorer.config.dims; x++) {
              const m = y * this.explorer.config.dims + x;
              const i = n[m];
              ctx2.fillStyle = this.explorer.grid.boards[k + 1].makecolor(i);
              ctx2.fillRect(x, y, 1, 1);
            }
          }
        }
        this.frameCanvases.push({ prev: canvas1, next: canvas2 });
        setTimeout(after, 1);
      };
    }
    for (let k = this.explorer.grid.boards.length - 1; k >= 0; k--) {
      after = queueOneFrame(k, after);
    }
    setTimeout(after, 0);
  }

  startMovieAnimation() {
    let frame = 0;
    let framesteps = 300;
    let endpause = 180;
    let endrecord = 60;
    const totalFrames = (this.explorer.grid.boards.length - 1) * framesteps;

    const scaleElement = document.getElementById('moviescale');
    scaleElement.removeAttribute('href');

    if (!this.isRecording) {
      this.recordedBlob = null;
      this.isRecording = true;
      this.startRecording();
    }

    const animate = () => {
      const kk = Math.min(frame, totalFrames) / framesteps;
      this.drawMovieFrame(kk);
      frame = (frame + 1) % (totalFrames + endpause);

      if (this.isRecording && frame > totalFrames + endrecord) {
        this.stopRecording();
        this.isRecording = false;
      }

      this.animationFrame = requestAnimationFrame(animate);
    };
    animate();
  }

  stopMovieAnimation() {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    this.recordedBlob = null;
  }

  startRecording() {
    const stream = this.movieCanvas.captureStream(30); // 30 FPS

    this.recordingMimeType = null;
    this.recordedChunks = [];
    for (let tryType of this.recordingMimeTypes) {
       if (MediaRecorder.isTypeSupported(tryType)) {
          this.recordingMimeType = tryType;
          break;
       }
    }
    if (this.recordingMimeType == null) {
      console.error('Neither MP4 nor WebM recording is supported');
      return;
    }

    this.mediaRecorder = new MediaRecorder(stream, {
      mimeType: this.recordingMimeType,
      videoBitsPerSecond: 10000000,
    });

    this.mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        this.recordedChunks.push(event.data);
      }
    };

    this.mediaRecorder.onstop = () => {
      this.recordedBlob = new Blob(this.recordedChunks, { type: this.recordingMimeType });
      this.recordedChunks = [];
      this.updateDownloadLink();
    };

    this.mediaRecorder.start(1000); // one-second blobs
  }

  stopRecording() {
    this.mediaRecorder.stop();
  }

  updateDownloadLink() {
    const scaleElement = document.getElementById('moviescale');
    const extension = (this.recordingMimeType.includes('mp4') ? 'mp4' : 'webm');
    scaleElement.textContent = 'Download ' + extension;
    scaleElement.href = URL.createObjectURL(this.recordedBlob);
    const k = this.explorer.grid.boards.length - 1;
    const board = this.explorer.grid.boards[k];
    scaleElement.download = 'mandelbrot' +
              formatcomplex(k, board.sizes[1], board.sizes[2]) +
              '-' + board.it + '.' + extension;
  }

  drawMovieFrame(kk) {
    if (this.movieCtx == null) { return; }
    const k = Math.floor(kk);
    const t = kk - k;
    const sourceBoard = this.explorer.grid.boards[k];
    const targetBoard = k+1 < this.explorer.grid.boards.length ?
                        this.explorer.grid.boards[k+1] : sourceBoard;
    const sourceSize = sourceBoard.sizes[0];
    const targetSize = targetBoard.sizes[0];
    const zoomRatio = targetSize / sourceSize;

    // Use zoom ratio for exponential interpolation
    const mulT = Math.pow(zoomRatio, t);
    const expT = (zoomRatio == 1.0 ? t : (mulT - 1) / (zoomRatio - 1));
    const colorT = expT * expT;
    const interpolatedSize = sourceSize * mulT;

    // Use spline interpolation for center coordinates
    const sourceCenter = [sourceBoard.sizes[1], sourceBoard.sizes[2]];
    const targetCenter = [targetBoard.sizes[1], targetBoard.sizes[2]];

    const p0 = k > 0 ? [
        this.explorer.grid.boards[k-1].sizes[1],
        this.explorer.grid.boards[k-1].sizes[2]] : sourceCenter;
    const p1 = sourceCenter;
    const p2 = targetCenter
    const p3 = k+2 < this.explorer.grid.boards.length ? [
        this.explorer.grid.boards[k+2].sizes[1],
        this.explorer.grid.boards[k+2].sizes[2]] : targetCenter;
    const interpolatedCenter = catmullRomSpline(p0, p1, p2, p3, t);

    // Clear the movie canvas
    this.movieCtx.fillStyle = this.explorer.grid.boards[k].makecolor(1);
    this.movieCtx.fillRect(0, 0, this.explorer.config.dims, this.explorer.config.dims);

    // Draw the current frame
    const scale = sourceSize / interpolatedSize;
    const offsetX = qdMul(qdSub(interpolatedCenter[0], sourceCenter[0]),
                          [this.explorer.config.dims / sourceSize, 0])[0];
    const offsetY = qdMul(qdSub(sourceCenter[1], interpolatedCenter[1]),
                          [this.explorer.config.dims / sourceSize, 0])[0];
    this.movieCtx.save();
    this.movieCtx.imageSmoothingEnabled = true;
    this.movieCtx.imageSmoothingQuality = 'high';
    this.movieCtx.translate(this.explorer.config.dims / 2, this.explorer.config.dims / 2);
    this.movieCtx.scale(scale, scale);
    this.movieCtx.translate(-this.explorer.config.dims / 2 - offsetX, -this.explorer.config.dims / 2 - offsetY);
    this.movieCtx.globalAlpha = 1;
    this.movieCtx.drawImage(this.explorer.grid.canvas(k), 0, 0);

    // Blend the color palette of the next frame
    if (this.frameCanvases[k].next) {
      this.movieCtx.globalAlpha = colorT;
      this.movieCtx.drawImage(this.frameCanvases[k].next, 0, 0);
    }
    this.movieCtx.restore();

    // Draw the next frame
    if (k < this.explorer.grid.boards.length - 1) {
      const targetScale = targetSize / interpolatedSize;
      const targetOffsetX = qdMul(qdSub(interpolatedCenter[0], targetCenter[0]),
                                  [this.explorer.config.dims / targetSize, 0])[0];
      const targetOffsetY = qdMul(qdSub(targetCenter[1], interpolatedCenter[1]),
                                  [this.explorer.config.dims / targetSize, 0])[0];
      this.movieCtx.save();
      this.movieCtx.imageSmoothingEnabled = true;
      this.movieCtx.imageSmoothingQuality = 'high';
      this.movieCtx.translate(this.explorer.config.dims / 2, this.explorer.config.dims / 2);
      this.movieCtx.scale(targetScale, targetScale);
      this.movieCtx.translate(-this.explorer.config.dims / 2 - targetOffsetX, -this.explorer.config.dims / 2 - targetOffsetY);
      this.movieCtx.globalAlpha = 1;
      this.movieCtx.drawImage(this.frameCanvases[k + 1].prev, 0, 0);
      this.movieCtx.globalAlpha = colorT;
      this.movieCtx.drawImage(this.explorer.grid.canvas(k + 1), 0, 0);
      this.movieCtx.restore();
    }

    // Update scale text
    if (!this.recordedBlob) {
      const currentScale = (3.0 / this.explorer.config.firstsize) *
          (Math.pow(this.explorer.config.zoomfactor, kk));
      document.getElementById('moviescale').textContent = formatScale(currentScale);
    }
  }
}

class Scheduler {
  constructor(explorer) {
    this.explorer = explorer;
    this.computationPaused = false;
    this.steps = 0;
    this.startTime = 0;
    this.endTime = 0;
  }

  start() {
    this.startTime = (new Date).getTime();
    this.progress();
  }

  progress() {
    if (this.computationPaused) {
      setTimeout(() => this.progress(), 100); // Check less frequently when paused
      return;
    }
    try {
      // Contribute to every unfinished cell
      let pri = this.explorer.grid.boards.map((_, index) => index)
        .filter(k => this.explorer.grid.boards[k])
        .filter(k => this.explorer.grid.boards[k].un > 0)
        .filter(k => !this.explorer.grid.hiddencanvas(k));
      if (this.steps % 2) {
        // Prioritize most unfinished half the time.
        let boards = this.explorer.grid.boards;
        pri = pri.sort((a, b) => boards[b].un - boards[a].un);
      } else {
        // Prioritize the most recent half the time.
        pri = pri.reverse();
        // Allow the user to prioritize by pointing the mouse.
        if (this.explorer.grid.focusk != null) {
          let focused = this.explorer.grid.focusk;
          pri.sort((a, b) => (a === focused ? -1 : b === focused ? 1 : 0));
        }
      }
      if (pri.length) {
        // Exponential scheduling policy
        let shift = Math.floor(this.steps++ / 2);
        let p = 0;
        while (1 << p & shift) { p += 1; }
        let k = pri[Math.min(p, pri.length - 1)];
        // Do at least 1000 pixel-steps.
        const board = this.explorer.grid.boards[k];
        const ctx = this.explorer.grid.canvas(k)?.getContext('2d');
        for (let amt = 0; board.un > 0 && amt < 1000; amt += (board.un * board.effort + 1)) {
          let count = board.iterate();
          if (count > 0 && ctx) {
            board.drawcolor(ctx, board.it - 1);
          }
        }
      } else {
        if (!this.endTime) {
          this.endTime = (new Date).getTime();
        }
        setTimeout(() => this.progress(), 100); // Check less frequently when no work
        return;
      }
    } catch (e) {
      console.log(e);
    }
    setTimeout(() => this.progress(), 0);
  }
}

class OrbitComputer {
  constructor(explorer) {
    this.explorer = explorer;
    this.orbitinterval = null;
    this.orbittimeout = null;
  }

  updateOrbit(k, j, target) {
    this.stopOrbitProcess();
    const orb = [];

    const updateorbit = () => {
      const [neworb, cyc, ongoing, title] = this.calculateOrbit(k, j, orb);
      this.displayOrbit(k, neworb, cyc, target, title, orb.length > 0);
      orb.push(...neworb);
      if (!ongoing) { this.stopOrbitInterval(); }
      return ongoing;
    };

    if (updateorbit()) {
      this.orbitinterval = setInterval(updateorbit, 53);
    }
  }

  stopOrbitInterval() {
    if (this.orbitinterval) {
      clearInterval(this.orbitinterval);
      this.orbitinterval = null;
    }
  }

  stopOrbitProcess() {
    this.stopOrbitInterval();
    if (this.orbittimeout) {
      clearTimeout(this.orbittimeout);
      this.orbittimeout = null;
    }
  }

  calculateOrbit(k, j, oldOrb) {
    let cyc = [];
    let orb = [];
    let ongoing = false;
    let title = '';
    let board = this.explorer.grid.boards[k];

    if (board && j >= 0 && j < this.explorer.config.dims2) {
      let c = board.currentc(j);
      let z = board.currentz(j);

      // Calculate a further orbit beyond the old orbit.
      let finished = Math.max(board.pp[j], board.nn[j]);
      let whole = Math.min(finished || Math.max(board.it, 8));
      let more = Math.min(whole - oldOrb.length / 4, 53);
      if (oldOrb.length) {
        let s = oldOrb.slice(oldOrb.length - 4);
        orb = this.suborbit([[s[0], s[1]], [s[2], s[3]]], c, more + 1);
        orb.splice(0, 4);
      } else {
        orb = this.suborbit(c, c, more);
      }
      if (!finished || (orb.length + oldOrb.length) / 4 < finished) {
        ongoing = true;
      }
      // Calculate a cycle and any messages
      title = 'c=' + formatcomplex(k, ...c).replaceAll('-', '\u2212');
      if (board.nn[j]) {
        if (board.nn[j] > 0) {
          title += '\ndiverges in ' + board.nn[j];
        } else {
          let period = this.figureperiod(board.pp[j]);
          if (period == 1) {
            title += '\nconverges after ' + board.pp[j];
          } else {
            title += '\nafter ' + board.pp[j] + ', period ' + period;
          }
          let clen = this.figureperiod(board.pp[j]);
          cyc = this.suborbit(z, c, clen);
        }
      } else {
        ongoing = true;
      }
    }
    return [orb, cyc, ongoing, title];
  }

  displayOrbit(k, orb, cyc, target, title, preserve) {
    target.setAttribute('title', title);
    if (!preserve) {
      this.explorer.grid.clearseq(k);
    }
    this.showseq(k, orb, 'yellow');
    this.showseq(k, cyc, 'red');

    const orbitonallboards = () => {
      for (let i = 0; i < this.explorer.grid.boards.length; i++) {
        if (!this.explorer.grid.hiddencanvas(i) && i != k) {
          if (!preserve) {
            this.explorer.grid.clearseq(i);
          }
          this.showseq(i, orb, 'yellow');
          this.showseq(i, cyc, 'red');
        }
      }
    };
    this.orbittimeout = setTimeout(orbitonallboards, 1);
  }

  suborbit(z, c, len) {
    let [r, j] = z;
    let [cr, cj] = c;

    let result = [r[0], r[1], j[0], j[1]];
    while (result.length < len * 4) {
      let j2 = qdSquare(j);
      let ja = qdMul(qdDouble(r), j);
      let r2 = qdSquare(r);
      let ra = qdSub(r2, j2);
      for (let ord = 2; ord < this.explorer.config.exponent; ord++) {
        let rt = qdSub(qdMul(r, ra), qdMul(j, ja));
        ja = qdAdd(qdMul(r, ja), qdMul(j, ra));
        ra = rt;
      }
      r = qdAdd(ra, cr);
      j = qdAdd(ja, cj);
      result.push(r[0], r[1], j[0], j[1]);
    }
    return result;
  }

  figureperiod(i) {
    // Reverse the computation that was done for exponential backoff.
    let head = i, tail = 1;
    while (head > tail) { head >>= 1; tail <<= 1; }
    return i - (head * tail) + 1;
  }

  showseq(k, seq, color) {
    if (k >= this.explorer.grid.boards.length) { return; }
    let ctx = this.explorer.grid.overlay(k).getContext('2d');
    ctx.fillStyle = color;
    let [s, cr, cj] = this.explorer.grid.boards[k].sizes;
    for (let i = 0; i < seq.length; i += 4) {
      let r = [seq[i], seq[i+1]];
      let j = [seq[i+2], seq[i+3]];
      let x = (qdSub(r, cr)[0] / s + 0.5) * this.explorer.config.dims;
      let y = (qdSub(cj, j)[0] / s + 0.5) * this.explorer.config.dims;
      if (x >= 0 && y >= 0 && x < this.explorer.config.dims && y < this.explorer.config.dims) {
        ctx.beginPath();
        ctx.arc(x, y, 1 * this.explorer.config.pixelRatio, 0, 2 * Math.PI, false);
        ctx.fill();
      }
    }
  }
}

class RedrawProcess {
  constructor(explorer) {
    this.boards = explorer.grid.boards;
    this.canvasGetter = (index) => explorer.grid.canvas(index);
    this.currentIndex = 0;
    this.timer = null;
  }
  start() {
    this.stop();  // Ensure any existing cycle is stopped
    this.currentIndex = 0;
    this.drawNext();
  }
  stop() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
  drawNext() {
    if (this.currentIndex < this.boards.length) {
      const board = this.boards[this.currentIndex];
      const canvas = this.canvasGetter(this.currentIndex);
      if (canvas && board) {
        const ctx = canvas.getContext('2d');
        board.draw(ctx);
      }
      this.currentIndex++;
      this.timer = setTimeout(() => this.drawNext(), 0);
    } else {
      this.stop();
    }
  }
}

class MandelbrotExplorer {
  constructor() {
    this.config = new Config();
    this.grid = new Grid(this.config);
    this.zoomManager = new ZoomManager(this.config, this.grid);
    this.urlHandler = new URLHandler(this.config, this.grid);
    this.eventHandler = new EventHandler(this);
    this.movieMode = new MovieMode(this);
    this.scheduler = new Scheduler(this);
    this.orbitComputer = new OrbitComputer(this);
    this.movieContainer = document.getElementById('movie');
    this.redrawProcess = new RedrawProcess(this);
  }

  start() {
    let startState = this.urlHandler.parseUrl();
    this.config.initSizes();
    this.initPlatform();
    this.grid.updateLayout(startState);
    this.eventHandler.setup();
    this.scheduler.start();
  }

  cycleUnknownColor() {
    let ind = (this.config.ukcs.indexOf(this.config.unknowncolor) + 1) % this.config.ukcs.length;
    this.config.unknowncolor = this.config.ukcs[ind];
    for (let k = 0; k < this.grid.boards.length; ++k) {
      this.grid.boards[k].drawcolor(this.grid.canvas(k).getContext('2d'), 0);
    }
  }

  cycleColorScheme() {
    const schemes = this.config.colorSchemes.all;
    const currentIndex = schemes.indexOf(this.config.scheme);
    const nextIndex = (currentIndex + 1) % schemes.length;
    this.config.scheme = schemes[nextIndex];
    this.redrawProcess.start();
    this.urlHandler.updateurl();
  }

  initPlatform() {
    for (let el of document.querySelectorAll('#text')) {
      if (this.config.cssDims < 360) {
        // Two columns plus margin minus padding
        el.style.maxWidth = (this.config.cssDims * 2 + 20 - 16) + 'px';
      } else {
        // One column minus padding
        el.style.maxWidth = (this.config.cssDims - 16) + 'px';
      }
    }
    if (this.config.mac) {
      for (let el of document.querySelectorAll('[mac]')) {
        el.innerHTML = el.getAttribute('mac');
      }
    }
    if (this.config.mobile) {
      for (let el of document.querySelectorAll('[mobile]')) {
        el.innerHTML = el.getAttribute('mobile');
      }
    }
    for (let el of document.querySelectorAll('.moviemode')) {
      el.href = '#movie';
      el.onclick = (() => {
        if (this.grid.boards.length > 1) {
          this.movieMode.toggle();
        }
        return true;
      });
    }
  }
}

// Utility functions
function formatScale(scale) {
  if (scale < 10) {
    return +scale.toFixed(1) + 'x';
  } else if (scale < 100000) {
    return +scale.toFixed(0) + 'x';
  } else {
    return scale.toExponential(2);
  }
}

function formatSize(s) {
  return parseFloat(s.toPrecision(
              Math.max(2, -Math.ceil(Math.log(s)/2.5))));
}

function formatcomplex(k, re, im) {
  let pix = explorer.grid.boards[k].pix;
  let digits = 0;
  while (pix < 1.0) {
    pix *= 10;
    digits += 1;
  }
  re = toQd(re);
  im = toQd(im);
  let rd = qdFixed(qdAbs(re), digits)
  let id = qdFixed(qdAbs(im), digits)
  let rs = re[0] < 0.0 ? '-' : '+';
  let is = im[0] < 0.0 ? '-' : '+';
  return rs + rd + is + id + 'i';
}

function catmullRom1D(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const c0 = (-t3 + 2*t2 - t) / 2;
  // c1 = (3*t3 - 5*t2 + 2) / 2; // unneeded since p1 = 0
  const c2 = (-3*t3 + 4*t2 + t) / 2;
  const c3 = (t3 - t2) / 2;
  // Compute offsets from p1 for numerical stability.
  const s0 = qdSub(p0, p1);
  const s2 = qdSub(p2, p1);
  const s3 = qdSub(p3, p1);
  return qdAdd(qdAdd(qdAdd(qdScale(s0, c0),
           qdScale(s3, c3)), qdScale(s2, c2)), p1);
}

function catmullRomSpline(p0, p1, p2, p3, t) {
  return [
    catmullRom1D(p0[0], p1[0], p2[0], p3[0], t),
    catmullRom1D(p0[1], p1[1], p2[1], p3[1], t)
  ];
}

function hclColor(h, c, l) {
  // Normalize hue to be between 0 and 360 degrees
  // Chroma and Luminance should be between 0 and 100.
  h = h % 360;
  if (h < 0) h += 360;
  c = Math.min(Math.max(c, 0), 100);
  l = Math.min(Math.max(l, 0), 100);

  // Convert to radians
  const hRad = h * Math.PI / 180;

  // Constants for conversion
  const u = Math.cos(hRad) * c;
  const v = Math.sin(hRad) * c;

  // Direct conversion from HCL to RGB
  let r = l + 0.09551990792716 * u + 0.05406649830715 * v;
  let g = l - 0.03947567534454 * u - 0.01829165033556 * v;
  let b = l - 0.19638676772419 * u - 0.45388640918783 * v;

  // Apply gamma correction and convert to eight-bit value
  [r, g, b] = [r, g, b].map((x) => {
    return intcolor(gammaCorrect(x / 100));
  });
  return `rgb(${r},${g},${b})`
}

function gammaCorrect(channel) {
  if (channel <= 0.0031308) {
    return 12.92 * channel;
  } else {
    return 1.055 * Math.pow(channel, 1/2.4) - 0.055;
  }
}

function intcolor(n) {
  if (n <= 0) { return "0"; }
  if (n >= 1) { return "255"; }
  return (n * 255).toString(10);
}

// Start the application
const explorer = new MandelbrotExplorer();
explorer.start();

//////////// quad-precision (qd, double double) utilities ///////////

function toQd(x) {
  return Array.isArray(x) ? x : [x, 0];
}

function fast2Sum(a, b) {
  let s = a + b;
  let t = b - (s - a);
  return [s, t];
}

function slow2Sum(a, b) {
  let s = a + b;
  let c = s - a;
  return [s, (a - (s - c)) + (b - c)];
}

function qdSplit(a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  return [x, y];
}

function twoProduct(a, b) {
  let p = a * b;
  let [ah, al] = qdSplit(a);
  let [bh, bl] = qdSplit(b);
  let err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  return [p, err];
}

function twoSquare(a) {
  let p = a * a;
  let [ah, al] = qdSplit(a);
  let err = ((ah * ah - p) + 2 * ah * al) + al * al;
  return [p, err];
}

function qdAdd(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [h1, h2] = slow2Sum(a1, b1);
  let [l1, l2] = slow2Sum(a0, b0);
  let [v1, v2] = fast2Sum(h1, h2 + l1);
  return fast2Sum(v1, v2 + l2);
}

function qdMul(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [p1, p2] = twoProduct(a1, b1);
  return fast2Sum(p1, p2 + a1 * b0 + b1 * a0);
}

function qdDouble(a) {
  return [a[0] * 2, a[1] * 2];
}

function qdScale(q, s) {
  let [q1, q0] = q;
  let [p1, p2] = twoProduct(q1, s);
  return fast2Sum(p1, p2 + s * q0);
}

function qdSquare(a) {
  let [a1, a0] = a;
  let [p1, p2] = twoSquare(a1);
  return fast2Sum(p1, p2 + 2 * a1 * a0);
}

function qdcPow(q, n) {
  if (n === 1) return q;
  if (n === 2) return qdcSquare(q);
  if (n === 3) return qdcMul(qdSquare(q), q);
  let result = [1, 0, 0, 0];
  let base = q;
  while (n > 0) {
    if (n % 2 === 1) { result = qdcMul(result, base); }
    base = qdcSquare(base);
    n = Math.floor(n / 2);
  }
  return result;
}

function qdNegate(a) {
  let [a1, a0] = a;
  return [-a1, -a0];
}

function qdSub(a, b) {
  return qdAdd(a, qdNegate(b));
}

function qdDiv(a, b) {
  let reciprocal = qdReciprocal(b);
  return qdMul(a, reciprocal);
}

function qdReciprocal(b, iters = 2) {
  if (b[0] === 0 && b[1] === 0) {
    return [NaN, 0];  // Return NaN for division by zero
  }
  // Refine the approximation using Newton-Raphson iteration
  let x = [1 / b[0], 0];
  for (let i = 0; i < iters; i++) {
    x = qdMul(x, qdSub([2, 0], qdMul(x, b)));
  }
  return x;
}

// Complex operations in quad precision
function qdcAdd(a, b) {
  let realSum = qdAdd([a[0], a[1]], [b[0], b[1]]);
  let imagSum = qdAdd([a[2], a[3]], [b[2], b[3]]);
  return [realSum[0], realSum[1], imagSum[0], imagSum[1]];
}

// Complex subtraction in quad precision
function qdcSub(a, b) {
  let realDiff = qdSub([a[0], a[1]], [b[0], b[1]]);
  let imagDiff = qdSub([a[2], a[3]], [b[2], b[3]]);
  return [realDiff[0], realDiff[1], imagDiff[0], imagDiff[1]];
}

// Complex multiplication in quad precision
function qdcMul(a, b) {
  let ac = qdMul([a[0], a[1]], [b[0], b[1]]);
  let bd = qdMul([a[2], a[3]], [b[2], b[3]]);
  let adbc = qdMul(qdAdd([a[0], a[1]], [a[2], a[3]]), qdAdd([b[0], b[1]], [b[2], b[3]]));
  let real = qdSub(ac, bd);
  let imag = qdSub(adbc, qdAdd(ac, bd));
  return [real[0], real[1], imag[0], imag[1]];
}

// Complex doubling in quad precision
function qdcDouble(a) {
  let realDouble = qdDouble([a[0], a[1]]);
  let imagDouble = qdDouble([a[2], a[3]]);
  return [realDouble[0], realDouble[1], imagDouble[0], imagDouble[1]];
}

// Complex squaring in quad precision
function qdcSquare(a) {
  let a0a0 = qdSquare([a[0], a[1]]);
  let a1a1 = qdSquare([a[2], a[3]]);
  let a0a1 = qdMul([a[0], a[1]], [a[2], a[3]]);
  let real = qdSub(a0a0, a1a1);
  let imag = qdDouble(a0a1);
  return [real[0], real[1], imag[0], imag[1]];
}

// Complex absolute value in quad precision
function qdcAbs(a) {
  let a0a0 = qdSquare([a[0], a[1]]);
  let a1a1 = qdSquare([a[2], a[3]]);
  return qdAdd(a0a0, a1a1);
}

function qdParse(s) {
  s = s.trim().toLowerCase();
  if (s === "infinity" || s === "+infinity") return [Infinity, 0];
  if (s === "-infinity") return [-Infinity, 0];
  if (s === "nan") return [NaN, 0];
  let sign = 1;
  if (s[0] === '-') {
    sign = -1;
    s = s.slice(1);
  } else if (s[0] === '+') {
    s = s.slice(1);
  }
  let e = 0;
  let parts = s.split('e');
  if (parts.length > 1) {
    s = parts[0];
    e = parseInt(parts[1]);
  }
  let decimalPos = s.indexOf('.');
  if (decimalPos !== -1) {
    s = s.replace('.', '');
    e -= s.length - decimalPos;
  }
  s = s.replace(/^0+/, '');
  if (s === '') return [0, 0];
  let result = [0, 0];
  for (let digit of s) {
    result = qdAdd(qdMul(result, [10, 0]), [parseInt(digit), 0]);
  }
  if (e !== 0) {
    result = qdMul(result, qdPow10(e));
  }
  if (sign === -1) {
    result = qdNegate(result);
  }
  return result;
}

function qdPow10(e) {
  if (e === 0) return [1, 0];
  let result = [1, 0];
  if (e < 0) return qdReciprocal(qdPow10(-e));
  return [10 ** e, 0];
}

function qdFloor(q) {
  let [a, b] = q;
  let fl = Math.floor(a);
  let [r0, r1] = qdSub([a, b], [fl, 0]);
  if (r0 < 0 || (r0 === 0 && r1 < 0)) {
    fl -= 1;
  }
  return [fl, 0];
}

function qdCompare(a, b) {
  if (a[0] < b[0]) return -1;
  if (a[0] > b[0]) return 1;
  if (a[1] < b[1]) return -1;
  if (a[1] > b[1]) return 1;
  return 0;
}

function qdLt(a, s) {
  return a[0] + a[1] < s;
}

function qdGt(a, s) {
  return a[0] + a[1] > s;
}

function qdEq(a, s) {
  return a[0] == s && a[1] == 0;
}

function qdAbs(q) {
  return (q[0] + q[1] < 0) ? qdNegate(q) : q;
}

function qdFixed(q, digits = 0) {
  // With fixed-point notation, digits specifies the number of digits after the decimal point.
  return qdFormat(q, digits, true);
}

const qdTen = [10, 0];

function qdFormat(q, digits = 'auto', useFixedPoint = false) {
  // With scientific notation, digits specifies the number of significant digits.
  let [a, b] = q;
  let s = a < 0 || (a === 0 && b < 0) ? '-' : '';
  let autoFormat = (digits == 'auto');
  if (autoFormat) {
     digits = 32;
  }
  q = qdAbs(q);
  if (!isFinite(a) || !isFinite(b)) return a.toString();
  if (a === 0 && b === 0) {
     if (autoFormat) return '0';
     if (useFixedPoint) digits += 1;
     return '0' + (digits > 1 ? '.' + '0'.repeat(digits - 1) : '');
  }
  // Scale q to be between 1 and 10, avoiding cumulative rounding
  let e = 0;
  let ex = [1, 0];
  while (qdCompare(q, qdMul(ex, qdTen)) >= 0) {
    e += 1;
    ex = qdPow10(e);
  }
  if (e == 0) {
    while (qdLt(qdMul(ex, q), 1)) {
      e -= 1;
      ex = qdPow10(-e);
    }
  }
  if (e) {
    q = (e > 0 ? qdDiv(q, ex) : qdMul(q, ex));
  }
  if (!qdLt(q, 10)) { // Hit boundary condition
    q = qdDiv(q, qdTen);
    e += 1;
  }
  let result = '';
  let nonzeroDigits = digits;
  if (useFixedPoint && !autoFormat) {
     nonzeroDigits = nonzeroDigits + e + 1;
  }
  for (let i = 0; i < nonzeroDigits + 1; i++) {
    let floorQ = qdFloor(q);
    let digit = floorQ[0];
    result += digit;
    q = qdSub(q, floorQ);
    q = qdMul(q, qdTen);
  }
  if (autoFormat) {
    if (parseInt(result.slice(result.length - 3)) > 970 ||
      parseInt(result.slice(result.length - 3)) < 30 ||
      parseInt(result.slice(result.length - 2)) > 92) {
      nonzeroDigits -= 1; // round to one fewer digit
    }
  }
  // Rounding
  if (nonzeroDigits < 0) {
    // No nonzero signficant digits? Treat as zero.
    result = '?';
    nonzeroDigits = 0;
    e = 0;
  } else if (parseInt(result[nonzeroDigits]) >= 5) {
    result = result.slice(0, nonzeroDigits) + '?';
    let carry = 1;
    for (let i = nonzeroDigits - 1; i >= 0; i--) {
      let digit = parseInt(result[i]) + carry;
      if (digit < 10) {
        result = result.slice(0, i) + digit + result.slice(i + 1);
        carry = 0;
        break;
      } else {
        result = result.slice(0, i) + '0' + result.slice(i + 1);
        carry = 1;
      }
    }
    if (carry) {
      result = '1' + result;
      nonzeroDigits += 1;
      e++;
    }
  }
  result = result.slice(0, nonzeroDigits);
  epart = '';
  if (!useFixedPoint && (!autoFormat || e < -6 || e > 32)) {
    // Scientific notation
    if (result.length > 1) {
      result = result[0] + '.' + result.slice(1);
    }
    if (e !== 0) {
      epart = 'e' + e;
    }
  } else {
    // Fixed-point notation
    if (e >= 0) {
      result = result.padEnd(e + 1, '0');
      result = result.slice(0, e + 1) + '.' + result.slice(e + 1);
    } else {
      result = '0.' + '0'.repeat(-e - 1) + result;
    }
    // Ensure the correct number of digits after the decimal point
    let [intPart, fracPart] = result.split('.');
    if (digits <= 0) {
      result = intPart;
    } else {
      fracPart = (fracPart || '').padEnd(digits, '0');
      result = intPart + '.' + fracPart;
    }
  }
  if (autoFormat) {
    // Auto digit selection: trim trailing zeros
    result = result.replace(/\.0+$|(\.\d*[1-9])0+$/, "$1");
  }
  return s + result + epart;
}
</script>
</body>
<script src="https://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-242212-1";
urchinTracker();
</script>
</html>
