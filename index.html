<!doctype html>
<html>
<head>
<title>Mandelbrot Explorer</title>
<meta name="description" content="Beautiful, fast, and accurate exploration of the Mandelbrot Set in your browser. Click to zoom. Hover to see orbits. M makes a smooth animation of your zoom path.">
<meta name="viewport" content="width=device-width">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="shortcut icon" type="image/png" href="favicon-128x128.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="favicon-180x180.png">
<link rel="apple-touch-icon" type="image/png" sizes="192x192" href="favicon-192x192.png">
<link rel="apple-touch-icon" type="image/png" sizes="512x512" href="favicon-512x512.png">
<!--
Written by David Bau as a Javascript example in 2009; updated in 2020
to handle high device pixel ratios, show orbits, and report periodicity.
Keyboard controls added in 2022, and quad-precision added in 2024.

URL options: use ?grid=3 to select 3-column view,
                   c=-0.14-0.65i to set center,
               and s=0.5 to set viewed size.

Implementation notes.  To minimize computation, the code identifies both
points that diverge and points that converge.  It uses a method that can
identiify convergence to periodic cylces of arbitrarily long length.
After the number of unknown points is less than half the visual field,
it computes the remaining points sparsely, avoiding iterating over the
already-known points.
-->
<style>
body { font-family: Arial; background: #888; margin: 16px 0;}
td { position: relative; vertical-align: top;}
canvas { vertical-align:bottom;cursor:crosshair }
#grid > div, #text, #movie > div { display: inline-block; margin: 8px;
  position: relative; vertical-align: top }
#grid { color: yellow }
#grid > div:only-child .closebox { display: none; }
#text { text-align: left; width: 439px; max-width: 82%; background:#aaa;
  position:relative;padding:1px 4px;font-size:9pt }
.closebox { position: absolute; right: 3px; top: 0; cursor: pointer;
  transition: opacity 0.3s }
.closebox::after { content: '\00d7'; font-size: 20px; }
.closebox:hover { font-weight: bold; }
.rect { position: absolute; outline: 1px solid yellow; height: 0; width: 0;
  pointer-events: none; opacity: 0.7; transition: opacity 0.3s; }
.hidemarks .rect { opacity: 0; }
.overlay { position: absolute; pointer-events: none; opacity: 0.8;
  top:0; left:0; z-index:1; transition: opacity 0.3s }
.zoomnum { position:absolute; display:inline-block; right:0; bottom:-12px;
  text-decoration: none; font-size:12px; color: yellow; min-width: 25%;
  text-align:right; transition: opacity 0.3s; z-index: 1; cursor: pointer }
.zoomnum[href]:hover { text-decoration: underline; }
td#b_0 { background-color: navy; vertical-align: middle; }
td#b_0 p { color:white; text-align: center; font-size: 16px; }
body.hidemarks .overlay { opacity: 0; }
body.hidemarks .zoomnum { opacity: 0; }
body.hidemarks #grid .closebox { opacity: 0; }
a[status]::after { /* tooltips */
 position: absolute; bottom: -2.2rem; right: 0; width: auto;
 background-color: #ddd; color: #444; font: 9pt Arial;
 padding: 3px 7px; box-shadow: 2px 2px 5px #777;
 content: attr(status); text-align: right; white-space: pre;
 pointer-events: none; z-index: 2;
 opacity: 0; transition: opacity 0.25s ease;
}
a[status]:focus::after, a[status]:hover::after { opacity: 0.95; }
body.starting div#b_0::after { display: flex; position: absolute;
  top: 0; left: 0; width: 100%; height: 100%; align-items: center;
  justify-content: center; content:"Starting..."; color: white;
  z-index: -1; background: rgb(32,16,64); }
</style>
</head>
<body class="starting">
<center>
<div id=grid></div>

<div id=movie></div>

<div id=text>
<div class=closebox></div>

<h4 style="margin-top:3px;margin-bottom:6px">
Javascript Mandelbrot Set Fractal Viewer
</h4>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> is iterated for each <a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">complex number</a> <em>c</em>.  Points are colored by <a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">counting iterations</a> to divergence; black points converge or cycle.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Click to zoom.</b>  Click zoom number to enlarge.  Right-click to save the fractal.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Yellow dots show <a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbits</a></b>.  Red dots show limit cycles.
Details in popup.
</p>

<p style="margin-top:6px;margin-bottom:6px">
This page shows more fractal detail over time by refining iterations to infinity as you explore: the longer you wait, the more detail is shown.
After you zoom beyond trillion-fold magnification, a quad-precision algorithm resolves fine details to more than 30 digits of accuracy.
The display computes subpixels with a <span class="pixelratio">2</span>:1 ratio.
</p>

<p style="margin-top:6px;margin-bottom:6px">
Keys:
<b>H</b> shrinks and <b>G</b> grows the size of each field;
<b>I</b> zooms in;
<b>R</b> reopens midway windows;
<b>C</b> recenters all;
<b>U</b> highlights unfinished pixels;
<b>X</b> increases and <b>Z</b> decreases the <em>z</em> exponent;
<b>F</b> increases and <b>D</b> decreases the pixel ratio;
<b>M</b> makes a movie that follows your path;
<nobr><b>?</b> shows this help.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a>
</div>

</center>

<script>
// Helper function to convert a regular number to quad-precision
function toQd(x) {
  return Array.isArray(x) ? x : [x, 0];
}

let vw = window.innerWidth || document.documentElement.clientWidth;
let gridcols = Math.max(1, Math.min(3, Math.floor((vw - 32) / 200)));
let exponent = 2;
let firstr = [-0.5, 0];
let firstj = [0.0, 0];
let firstsize = 3.0;
let orbitlength = 100000; // show very long orbits
let pixelRatio = Math.max(Math.ceil(window.devicePixelRatio || 1), 2);
let zoomfactor = 5;

let startstate = { hidden: [], sizes: [] };
let opts = document.location.search.split('&');
for (let j in opts) {
  let m;
  if (null !== (m = opts[j].match(/exponent=(\d+)/))) {
    exponent = Math.max(2, parseInt(m[1]));
    if (exponent > 2) { firstr = [0.0, 0]; }
    for (let el of document.getElementsByClassName('exponent')) {
      el.innerText = exponent;
    }
  }
  if (null !== (m = opts[j].match(/grid=(\d+)/))) {
    gridcols = Math.max(1, parseInt(m[1]));
  }
  if (null !== (m = opts[j].match(/s=([-+]?\d?\.?\d+(?:e[-+]\d+)?)/))) {
    firstsize = parseFloat(m[1]);
  }
  if (null !== (m = opts[j].match(/pixelratio=(\d+)/))) {
    pixelRatio = Math.max(1, parseInt(m[1]));
  }
  if (null !== (m = opts[j].match(/c=([-+\d\.ei,]+)/))) {
    for (let coords of m[1].split(',')) {
      m = coords.match(/([-+]?\d?\.?\d+(?:e[-+]\d+)?)(?:([-+]\d?\.?\d+(?:e[-+]\d+)?)i)?/);
      startstate.sizes.push([
        firstsize / Math.pow(zoomfactor, startstate.sizes.length),
        m != null && m[1] ? qdParse(m[1]) : (startstate.sizes.length > 0 ?
            startstate.sizes[startstate.sizes.length - 1][1] : firstr),
        m != null && m[2] ? qdParse(m[2]) : (startstate.sizes.length > 0 ?
            startstate.sizes[startstate.sizes.length - 1][2] : firstj)
      ]);
    }
  }
  if (null !== (m = opts[j].match(/h=([\d,]+)/))) {
    startstate.hidden = m[1].split(',').map(x=>parseInt(x));
  }
}

if (startstate.sizes.length == 0) {
  startstate.sizes.push([firstsize, firstr, firstj]);
}

let cssDims = Math.max(32,
  Math.floor((vw - 48) / gridcols) - 16);
let dims = Math.floor(cssDims * pixelRatio);
let dims2 = dims * dims;

let it = [];  // the current iteration num
let cc = [];  // the constant at every pixel
let zz = [];  // the current iterate value
let bb = [];  // the recent value at iteration r
let pp = [];  // the point at which the value was first closer than epsilon2
let nn = [];  // the number of iterations until divergence (or convergence, neg)
let un = [];  // number of uncomputed pixels
let di = [];  // number of known diverged pixels
let hi = [];  // history of up to 256 of [uncomputed, iter]
let ss = [];  // list of uncomputed indexes
let fi = [];  // 1 if finished.
let sizes = [];
let gridboards = 0;
let steps = 0;
let ukcs = ["#000", "#888", "#fff", "yellow", "red", "rgb(32,16,64)"];
let unknowncolor = ukcs[0];
let focusk = null;

let currentUpdateProcess = null;

function start() {
  updatePixelRatioUI();
  updateGridLayout(startstate);
  progress();
}

function updateGridLayout(state = null) {
  if (currentUpdateProcess) {
    currentUpdateProcess.abort();
  }
  cssDims = Math.max(32, Math.floor((vw - 48) / gridcols) - 16);
  dims = Math.floor(cssDims * pixelRatio);
  dims2 = dims * dims;
  if (state == null) {
    state = currentGridState();
  }

  // Recreate the grid
  let gridElement = grid();
  gridElement.innerHTML = '';
  gridboards = 0;

  // Recreate all canvases
  for (let k = 0; k < state.sizes.length; k++) {
    makeboard(k);
    if (state.hidden.indexOf(k) >= 0) { hideboard(k); }
  }
  updatePixelRatioUI();

  currentUpdateProcess = createUpdateProcess(state);
  currentUpdateProcess.start();
}

function currentGridState() {
  let state = { hidden: [], sizes: [] };
  for (let k = 0; k < sizes.length; k++) {
    if (hiddenboard(k)) {
      state.hidden.push(k);
    }
    state.sizes.push(sizes[k]);
  }
  return state;
}

function createUpdateProcess(state) {
  let aborted = false;
  let currentIndex = 0;

  function processNext() {
    if (aborted || currentIndex >= state.sizes.length) {
      if (!aborted) {
        updateurl();
        updateZoomRectangles();
      }
      currentUpdateProcess = null;
      return;
    }

    const k = currentIndex;
    setboard(k, state.sizes[k][0], state.sizes[k][1], state.sizes[k][2]);
    draw(k);
    if (state.hidden[k]) { hideboard(k); }
    currentIndex++;
    setTimeout(processNext, 0);
  }

  return {
    start: function() {
      processNext();
    },
    abort: function() {
      aborted = true;
    },
    restart: function() {
      aborted = false;
      currentIndex = 0;
      this.start();
    }
  };
}

function abortGridLayout() {
  if (currentUpdateProcess) {
    currentUpdateProcess.abort();
  }
}

function updatePixelRatioUI() {
  for (let el of document.getElementsByClassName('pixelratio')) {
    el.innerText = pixelRatio;
  }
}

function updateExponent(newExponent) {
  if (newExponent < 2) { return; }
  exponent = newExponent;
  for (let el of document.getElementsByClassName('exponent')) {
    el.innerText = exponent;
  }
  abortGridLayout();
  truncateboards(1);
  removeboardspast(0);
  if (firstsize == 3) {
    firstr = [exponent > 2 ? 0.0 : -0.5, 0];
    firstj = [0.0, 0];
  }
  setboard(0, firstsize, firstr, firstj);
  makeboard(0);
  draw(0);
  clearseq(0);
  updateZoomRectangles();
  updateurl();
}

function updateZoomRectangles() {
  let prevBoard = null;
  let prevK = 0;
  for (let k = 0; k < sizes.length; k++) {
    if (hiddenboard(k)) { continue; }
    let currBoard = sizes[k];
    if (prevBoard != null) {
      let x = (currBoard[1][0] - prevBoard[1][0]) / prevBoard[0] + 0.5;
      let y = 0.5 - (currBoard[2][0] - prevBoard[2][0]) / prevBoard[0];
      let zf = prevBoard[0] / currBoard[0];
      showrect(prevK, x, y, zf);
    }
    prevBoard = currBoard;
    prevK = k;
  }
}

function cycle(m, z, c, p) {
  let len = figureperiod(p[m]);
  return suborbit(m, z, c, len);
}

function orbit(m, c, len) {
  return suborbit(m, c, c, len);
}

function suborbit(m, z, c, len) {
  let m2 = m * 2;
  let m2i = m2 + 1;

  // Always convert to quad precision
  let r = toQd(z[m2]);
  let j = toQd(z[m2i]);
  let cr = toQd(c[m2]);
  let cj = toQd(c[m2i]);

  let result = [r[0], r[1], j[0], j[1]];
  while (result.length < len * 4) {
    let j2 = qdSquare(j);
    let ja = qdMul(qdDouble(r), j);
    let r2 = qdSquare(r);
    let ra = qdSub(r2, j2);
    for (let ord = 2; ord < exponent; ord++) {
      let rt = qdSub(qdMul(r, ra), qdMul(j, ja));
      ja = qdAdd(qdMul(r, ja), qdMul(j, ra));
      ra = rt;
    }
    r = qdAdd(ra, cr);
    j = qdAdd(ja, cj);
    result.push(r[0], r[1], j[0], j[1]);
  }
  return result;
}

function compute(m, i, n, z, c, b, p, epsilon, epsilon2) {
  if (n[m]) return 0;
  let m2 = m * 2;
  let m2i = m2 + 1;
  let useQuad = Array.isArray(z[0]);

  let r, j, r2, j2, ra, ja, rb, jb, db;

  if (useQuad) {
    r = z[m2]
    j = z[m2i]

    let r2 = qdSquare(r);
    let j2 = qdSquare(j);
    if (qdGt(qdAdd(r2, j2), 4)) {
      n[m] = i;
      return 1;
    }
    ra = qdSub(r2, j2);
    ja = qdMul(qdDouble(r), j);
    for (let ord = 2; ord < exponent; ord++) {
      let rt = qdSub(qdMul(r, ra), qdMul(j, ja));
      ja = qdAdd(qdMul(r, ja), qdMul(j, ra));
      ra = rt;
    }
    ra = qdAdd(ra, c[m2]);
    ja = qdAdd(ja, c[m2i]);
    z[m2] = ra;
    z[m2i] = ja;
    rb = b[m2];
    jb = b[m2i];
    db = qdAdd(qdAbs(qdSub(rb, ra)), qdAbs(qdSub(jb, ja)));
    db = db[0] + db[1];
  } else {
    r = z[m2];
    j = z[m2i];
    r2 = r * r;
    j2 = j * j;
    if (r2 + j2 > 4.0) {
      n[m] = i;
      return 1;
    }
    ra = r2 - j2;
    ja = 2 * r * j;
    for (let ord = 2; ord < exponent; ord++) {
      let rt = r * ra - j * ja;
      ja = r * ja + j * ra;
      ra = rt;
    }
    ra += c[m2];
    ja += c[m2i];
    z[m2] = ra;
    z[m2i] = ja;
    rb = b[m2];
    jb = b[m2i];
    db = Math.abs(rb - ra) + Math.abs(jb - ja);
  }

  if (db <= epsilon2) {
    if (!p[m]) { p[m] = i; }
    if (db <= epsilon) {
      n[m] = -i;
      return -1;
    }
  }
  return 0;
}

function iterate(k) {
  let i = ++it[k];  // total iteration count
  let z = zz[k];    // current iterate for each pixel
  let c = cc[k];    // current constant for each pixel
  let n = nn[k];    // number of iterations before conv/divergence
  let b = bb[k];    // recent remembered z
  let p = pp[k];    // iteration at which converged within epsilon2
  let s = ss[k];    // speedy list of indexes to compute
  let pix = sizes[k][0] / dims;  // current for quad-precision check
  let epsilon = Math.min(1e-12, pix);
  let epsilon2 = Math.min(1e-9, pix * 10000);
  // head and tail factor i into an odd num and largest power of 2.
  let head = i, tail = 1;
  while ((head & 1) == 0) { head >>= 1; tail <<= 1; }
  if (s === null && un[k] <= z.length / 4) {
    let news = [];
    for (let m = 0; m < dims2; ++m) {
      if (n[m]) continue;
      news.push(m);
    }
    s = ss[k] = news;
  }
  if (s === null) {
    if (head <= tail) {
      for (let m = 0; m < dims2; ++m) {
        if (n[m]) continue;
        b[m * 2] = z[m * 2];
        b[m * 2 + 1] = z[m * 2 + 1];
        p[m] = 0;
      }
    }
    let count = 0, diverged = 0, a;
    for (let m = 0; m < dims2; ++m) {
      a = compute(m, i, n, z, c, b, p, epsilon, epsilon2);
      if (a) { count += 1; }
      if (a > 0) { diverged += 1; }
    }
    un[k] -= count;
    di[k] += diverged;
  } else {
    if (s.length > un[k] * 1.25) {
      let news = [];
      for (let t = 0; t < s.length; ++t) {
        if (n[s[t]]) continue;
        news.push(s[t]);
      }
      s = ss[k] = news;
    }
    if (head <= tail) {
      for (let t = 0; t < s.length; ++t) {
        let m = s[t];
        if (n[m]) continue;
        b[m * 2] = z[m * 2];
        b[m * 2 + 1] = z[m * 2 + 1];
        p[m] = 0;
      }
    }
    let count = 0, diverged = 0, a;
    for (let t = 0; t < s.length; ++t) {
      a = compute(s[t], i, n, z, c, b, p, epsilon, epsilon2);
      if (a) { count += 1; }
      if (a > 0) { diverged += 1; }
    }
    un[k] -= count;
    di[k] += diverged;
  }
  if (hi[k][0][0] - un[k] >= dims2 / 256) {
    hi[k].unshift([un[k], di[k], i]);
  }
  if (!fi[k] && un[k] != dims2) {
    fi[k] = i;
  }
}

function setboard(k, size, re, im) {
  for (let j = Math.min(it.length, k); j <= k; j++) { 
    it[j] = 0;
    fi[j] = 0;
    zz[j] = [];
    cc[j] = [];
    nn[j] = [];
    bb[j] = [];
    pp[j] = [];
    ss[j] = null;
    un[j] = dims2;
    di[j] = 0;
    hi[j] = [[dims2, 0, 0]];
    sizes[j] = [0, [0, 0], [0, 0]];
  }
  sizes[k] = [size, toQd(re), toQd(im)];
  it[k] = 1;
  let c = cc[k];
  let n = nn[k];
  let p = pp[k];
  let useQuad = (size / dims) < 1e-15;
  for (let y = 0; y < dims; y++) {
    let jFrac = (0.5 - (y / dims));
    let j = (useQuad
        ? qdAdd(toQd(im), qdMul(toQd(jFrac), toQd(size)))
        : jFrac * size + im[0]);
    for (let x = 0; x < dims; x++) {
      let rFrac = ((x / dims) - 0.5);
      if (useQuad) {
        let r = qdAdd(toQd(re), qdMul(toQd(rFrac), toQd(size)));
        c.push(r, j);
        let r2j2 = qdAdd(qdMul(r, r), qdMul(j, j));
        if (qdGt(r2j2, 4)) {
          n.push(1);
          p.push(0);
          un[k] -= 1;
        } else {
          n.push(0);
          p.push(0);
        }
      } else {
        let r = rFrac * size + re[0];
        c.push(r, j);
        if (r * r + j * j > 4) {
          n.push(1);
          p.push(0);
          un[k] -= 1;
        } else {
          n.push(0);
          p.push(0);
        }
      }
    }
  }
  zz[k] = c.slice();
  bb[k] = c.slice();
  fi[k] = (un[k] == dims2 ? 0 : 1);
}

function truncateboards(k) {
  if (it.length > k) {
    it.length = k;
    cc.length = k;
    zz.length = k;
    bb.length = k;
    pp.length = k;
    nn.length = k;
    un.length = k;
    di.length = k;
    hi.length = k;
    ss.length = k;
    fi.length = k;
    sizes.length = k;
  }
}

function clearseq(k) {
  let ctx = overlay(k).getContext('2d');
  ctx.clearRect(0, 0, dims, dims);
}

function showseq(k, seq, color) {
  let ctx = overlay(k).getContext('2d');
  ctx.fillStyle = color;
  let sc = sizes[k];
  let s = sc[0];
  let cr = sc[1];
  let cj = sc[2];
  for (let i = 0; i < seq.length; i += 4) {
    let r = [seq[i], seq[i+1]];
    let j = [seq[i+2], seq[i+3]];
    let x = (qdSub(r, cr)[0] / s + 0.5) * dims;
    let y = (qdSub(cj, j)[0] / s + 0.5) * dims;
    if (x >= 0 && y >= 0 && x < dims && y < dims) {
      ctx.beginPath();
      ctx.arc(x, y, 1 * pixelRatio, 0, 2 * Math.PI, false);
      ctx.fill();
    }
  }
}

function drawcolor(k, i) {
  let color = makecolor(k, i);
  let converged = makecolor(k, -i);
  let n = nn[k];
  let ctx = board(k).getContext('2d');
  for (let m = 0; m < dims2; ++m) {
    if (n[m] == i || n[m] == -i) {
      let x = m % dims;
      let y = (m - x) / dims;
      ctx.fillStyle = n[m] > 0 ? color : converged;
      ctx.fillRect(x, y, 1, 1);
    }
  }
}

function clearboard(k) {
  let ctx = board(k).getContext('2d');
  ctx.fillStyle = makecolor(k, 0);
  ctx.fillRect(0, 0, dims, dims);
}

function colornum(n) {
  if (n <= 0) { return "0"; }
  if (n < 16) { return (n * 17).toString(10); }
  return "255";
}

function intcolor(n) {
  if (n <= 0) { return "0"; }
  if (n >= 1) { return "255"; }
  return (n * 255).toString(10);
}

function makecolor(k, i) {
  if (i == 0) return unknowncolor;
  if (i < 0) return 'black';
  let j = 0;
  for (; i < hi[k][j][2]; j += 1) {}
  let frac = (dims2 - hi[k][j][0]) / dims2; // frac of pixels done.
  let len = hi[k].length, half = Math.floor((len + j) / 2);
  let s = sizes[k][0];
  let ff = Math.pow(frac, 2);
  let fr = Math.pow(frac, 0.333);
  let fg = Math.pow(frac, 3);
  let g = intcolor(Math.max(fg, Math.min(fr, i * Math.pow(s, 0.33) / 64)));
  let r = intcolor(Math.min(fr, i * Math.pow(s, 0.22) / 64));
  let b = intcolor(ff / 3 + 0.667);
  return "rgb(" + r + "," + g + "," + b + ")";
}

function draw(k) {
  let colorcache = {};
  function fastcolor(num) {
    let result = colorcache[num];
    if (!result) {
      result = makecolor(k, num);
      if (colorcache.length < 10000) {
        colorcache[num] = result;
      }
    }
    return result;
  }
  if (nn.length <= k) return;
  let n = nn[k];
  let ctx = board(k).getContext('2d');
  for (let m = 0; m < dims2; ++m) {
    let x = m % dims;
    let y = (m - x) / dims;
    ctx.fillStyle = fastcolor(n[m]);
    ctx.fillRect(x, y, 1, 1);
  }
}

function drawall() {
  for (let k = 0; k < nn.length; ++k) {
    draw(k);
  }
}

function makeboard(k) {
  let gd = grid();
  while (gridboards <= k) {
    let dd = document.createElement('div');
    dd.id = 'b_' + gridboards;
    dd.innerHTML = boardstring(gridboards);
    dd.className = 'hidemarks';
    gd.appendChild(dd);
    gridboards += 1;
  }
}

function formatScale(scale) {
  if (scale < 10) {
    return +scale.toFixed(1) + 'x';
  } else if (scale < 100000) {
    return +scale.toFixed(0) + 'x';
  } else {
    return scale.toExponential(2);
  }
}

function boardstring(k) {
  let factor = 3.0 / (k < sizes.length ? sizes[k][0] :
    firstsize / Math.pow(zoomfactor, k));
  factor = formatScale(factor);
  return '<canvas width=' + dims + ' height=' + dims +
         ' style="height:' + cssDims + 'px;width:' + cssDims + 'px;">' +
         '</canvas>' +
         '<div class="closebox"></div>' +
         '<div class="rect"></div>' +
         '<canvas class=overlay width=' + dims + ' height=' + dims +
         ' style="height:' + cssDims + 'px;width:' + cssDims + 'px;">' +
         '</canvas>' +
         '<a class="zoomnum" target="_blank" href="?grid=1">' + factor +
         '</a>';
}

function progress() {
  if (computationPaused) {
    setTimeout(progress, 100); // Check less frequently when paused
    return;
  }
  try {
    // Contribute to every unfinished cell
    let pri = Array.from(sizes.keys())
      .filter(k => un[k] > 0 && !hiddenboard(k));
    if (steps % 2) {
      // Prioritize most unfinished half the time.
      pri = pri.sort((a, b) => un[b] - un[a]);
    } else {
      // Prioritize the most recent half the time.
      pri = pri.reverse();
      // Allow the user to prioritize by pointing the mouse.
      if (focusk != null) {
        pri.sort((a, b) => (a === focusk && -1) || (b === focusk && 1) || 0);
      }
    }
    // Exponential scheduling policy
    let shift = Math.floor(steps++ / 2);
    let p = 0;
    while (1 << p & shift) { p += 1; }
    let k = pri[Math.min(p, pri.length)];
    // Do at least 1000 pixel-steps.
    let u = un[k];
    for (let amt = 0; u > 0 && amt < 1000; amt += (u + 1)) {
      iterate(k);
      if (un[k] < u) {
        drawcolor(k, it[k]);
        u = un[k];
      }
    }
  } catch (e) {
    console.log(e);
  }
  setTimeout(progress, 0);
}

function absoluteLeft(target) {
  let left = 0;
  while (target) {
    left += target.offsetLeft;
    target = target.offsetParent;
  }
  return left;
}

function absoluteTop(target) {
  let top = 0;
  while (target) {
    top += target.offsetTop;
    target = target.offsetParent;
  }
  return top;
}

function eventtarget(e) {
  let target = (e.target ? e.target : e.srcElement ? e.srcElement : null);
  while (target) {
    if (target.id) { return target; }
    target = target.parentNode;
  }
  return null;
}

function pointInTarget(ev, target) {
  let se = document.scrollingElement || document.body;
  let x = (ev.clientX + se.scrollLeft - absoluteLeft(target)) * pixelRatio;
  let y = (ev.clientY + se.scrollTop - absoluteTop(target)) * pixelRatio;
  return { x: Math.round(x), y: Math.round(y) };
}

document.onmousedown = function(e) {
  let target = eventtarget(e);
  if (movieMode && (target.id != 'moviescale')) { toggleMovieMode(); }
  if (e.button != 0) { return true; }
  if (target) {
    let m = target.id.match(/b_(\d+)/);
    if (e.target.tagName == 'A') {
      if (m) { e.target.href = bigurl(m[1]); }
      return true;
    }
    if (m) {
      let p = pointInTarget(e, target);
      cellclick(parseInt(m[1]), p.x + p.y * dims);
      return false;
    }
  }
  return true;
}

let orbitinterval = null;
let orbittimeout = null;
document.onmousemove = function(e) {
  let target = eventtarget(e);
  if (orbitinterval) {
    clearInterval(orbitinterval);
    orbitinterval = null;
  }
  if (orbittimeout) {
    clearTimeout(orbittimeout);
    orbittimeout= null;
  }
  if (target) {
    let m = target.id.match(/b_(\d+)/);
    if (m) {
      let p = pointInTarget(e, target);
      let k = parseInt(m[1]);
      let j = p.x + p.y * dims;
      function updateorbit() {
        let orb = [];
        let cyc = [];
        let ongoing = true;
        target.setAttribute('title', '');
        if (cc[k] && j >= 0 && j * 2 < cc[k].length) {
          // Convert to quad precision if necessary
          let cr = Array.isArray(cc[k][j * 2]) ? cc[k][j * 2] : [cc[k][j * 2], 0];
          let cj = Array.isArray(cc[k][j * 2 + 1]) ? cc[k][j * 2 + 1] : [cc[k][j * 2 + 1], 0];
          let title = 'c=' + formatcomplex(k, cr, cj).replaceAll('-', '\u2212');
          let len = Math.min(Math.max(pp[k][j], nn[k][j]) || Math.max(it[k], 8), orbitlength);
          orb = orbit(j, cc[k], len);
          if (nn[k][j]) {
            ongoing = false;
            if (nn[k][j] > 0) {
              title += '\ndiverges in ' + nn[k][j];
            } else {
              let period = figureperiod(pp[k][j]);
              if (period == 1) {
                title += '\nconverges after ' + pp[k][j];
              } else {
                title += '\nafter ' + pp[k][j] + ', period ' + figureperiod(pp[k][j]);
              }
              cyc = cycle(j, zz[k], cc[k], pp[k]);
            }
          }
          target.setAttribute('title', title);
        }
        clearseq(k);
        showseq(k, orb, 'yellow');
        showseq(k, cyc, 'red');
        function orbitonallboards() {
          for (let i = 0; i < sizes.length; i++) {
            if (!hiddenboard(i) && i != k) {
              clearseq(i);
              showseq(i, orb, 'yellow');
              showseq(i, cyc, 'red');
            }
          }
        }
        orbittimeout = setTimeout(orbitonallboards, 1);
        return ongoing;
      }
      if (updateorbit()) {
        orbitinterval = setInterval(updateorbit, 251);
      }
    }
  }
}

document.body.onkeydown = function(e) {
  if (movieMode &&
      ['Shift', 'Alt', 'Control', 'Meta', 'CapsLock'].indexOf(e.key) == -1) {
    toggleMovieMode();
    return;
  }
  // Pressing backspace will delete the last zoom.
  if (e.key == 'Backspace' && sizes.length > 1 && !currentUpdateProcess) {
    let k = sizes.length - 1;
    truncateboards(k);
    removeboardspast(k - 1);
    truncatehiddenboards();
    updateurl();
  }
  // Pressing C will center all the zoom positions.
  if (e.key == 'c' && sizes.length > 1) {
    let k = sizes.length - 1;
    let ore = sizes[k][1];
    let oim = sizes[k][2];
    showrect(0, 0.5 + (ore - sizes[0][1]) / sizes[0][0],
                0.5 - (oim - sizes[0][2]) / sizes[0][0],
                sizes[0][0] / sizes[1][0]);
    for (k = 1; k < sizes.length - 1; k += 1) {
      showrect(k, 0.5, 0.5, sizes[k][0] / sizes[k+1][0]);
      if (qdCompare(sizes[k][1], ore) || qdCompare(sizes[k][2], oim)) {
        clearboard(k);
        setboard(k, sizes[k][0], ore, oim);
        drawcolor(k, 1);
        clearseq(k);
      }
    }
    updateurl();
  }
  // Pressing U will cycle through the uncomputed colors.
  if (e.key == 'u') {
    unknowncolor = ukcs[(ukcs.indexOf(unknowncolor) + 1) % ukcs.length];
    for (let k = 0; k < nn.length; ++k) {
      drawcolor(k, 0);
    }
  }
  // Pressing I will zoom in at the same position.
  if (e.key == 'i') {
    let k = sizes.length - 1;
    if (di[k] == 0) { return; }
    let osize = sizes[k][0];
    let ore = sizes[k][1];
    let oim = sizes[k][2];
    let rre = 0.5;
    if (k == 0 && qdEq(ore, -0.5) && qdEq(oim, 0)) {
      // Myreberg / Feigenbaum point, https://oeis.org/A218453
      // qdParse('-1.40115518909205060052382678789386129222630')
      ore = [-1.4011551890920506, 1.196330130384937e-17];
      rre = (ore[0] - sizes[0][1][0]) / sizes[0][0] + 0.5;
    }
    showrect(k, rre, 0.5, zoomfactor);
    nsize = osize / zoomfactor;
    setboard(k + 1, nsize, ore, oim);
    makeboard(k + 1);
    removeboardspast(k + 1);
    board(k + 1).parentElement.className = 'hidemarks';
    board(k + 1).parentElement.scrollIntoView({ behavior: 'smooth' });
    draw(k + 1);
    updateurl();
  }
  // Pressing ? will show the help window
  if (e.key == '?') {
    document.getElementById('text').style.display = 'block';
  }
  // G reduces the grid column and H increases
  if (e.key === 'g' && gridcols > 1) {
    gridcols -= 1;
    updateGridLayout();
  }
  if (e.key === 'h') {
    gridcols += 1;
    updateGridLayout();
  }
  // R will restore any hidden boards
  if (e.key === 'r') {
    showallboards();
    updateurl();
  }
  // Increase the exponent
  if (e.key === 'x') {
    updateExponent(exponent + 1);
  }
  // Decrease the exponent
  if (e.key === 'z') {
    updateExponent(exponent - 1);
  }
  // Increase the pixel ratio
  if (e.key === 'f') {
    pixelRatio += 1;
    updateGridLayout();
  }
  // Increase the pixel ratio
  if (e.key === 'd' && pixelRatio > 1) {
    pixelRatio -= 1;
    updateGridLayout();
  }
  // Toggle movie mode
  if (e.key === 'm' && sizes.length > 1) {
    toggleMovieMode();
  }
}

document.body.onmouseover = function(e) {
  document.body.className = 'hidemarks';
  focusk = null;
  let target = eventtarget(e);
  if (target) {
    let m = target.id.match(/b_(\d+)/);
    if (m) {
      k = parseInt(m[1]);
      focusk = k;
      if (nn.length <= k) return;
      for (let i = 0; i < gridboards; ++i) {
        board(i).parentElement.className = i < k ? '' : 'hidemarks';
      }
      document.body.className = '';
      let overtarget = e.target;
      function update_progress() {
        if (overtarget.tagName == 'A') {
          overtarget.href = bigurl(k)
          overtarget.setAttribute('status', ('center at ' +
              formatcomplex(k, sizes[k][1], sizes[k][2]).replaceAll('-', '\u2212') +
              '\n' + Math.floor(1000 * (1.0 - un[k] / dims2))/10.0  + '% done ' +
              'after ' + it[k] + ' iters'));
        }
        if (overtarget.matches(':hover')) {
          setTimeout(update_progress, 100);
        }
      }
      update_progress();
    } else if (target.id.startsWith('movie') && (!e.target || e.target.id != 'movie')) {
      document.body.className = '';
    }
  }
}

function figureperiod(i) {
  // Reverse the computation that was done for exponential backoff.
  let head = i, tail = 1;
  while (head > tail) { head >>= 1; tail <<= 1; }
  return i - (head * tail) + 1;
}

function formatscale(s) {
  return parseFloat(s.toPrecision(
              Math.max(2, -Math.ceil(Math.log(s)/2.5))));
}

function formatcomplex(k, re, im) {
  let pix = sizes[k][0] / dims;
  let digits = 0;
  while (pix < 1.0) {
    pix *= 10;
    digits += 1;
  }
  re = toQd(re);
  im = toQd(im);
  let rd = qdFixed(qdAbs(re), digits)
  let id = qdFixed(qdAbs(im), digits)
  let rs = re[0] < 0.0 ? '-' : '+';
  let is = im[0] < 0.0 ? '-' : '+';
  return rs + rd + is + id + 'i';
}

function removeboardspast(k) {
  if (gridboards > k) {
    for (let j = k + 1; j < gridboards; ++j) {
      board(j).parentElement.remove();
    }
    gridboards = k + 1;
  }
}

function showboard(k) {
  board(k).parentElement.style.display = '';
}

function hideboard(k) {
  board(k).parentElement.style.display = 'none';
}

function showallboards() {
  for (let j = 0; j < gridboards; ++j) {
    showboard(j);
  }
  updateZoomRectangles();
}

function hiddenboard(k) {
  let b = board(k);
  return b && b.parentElement.style.display == 'none';
}

function truncatehiddenboards(k) {
  let j = gridboards - 1;
  for (; j > 0; j--) {
    if (!hiddenboard(j)) {
      break;
    }
  }
  truncateboards(j + 1);
  removeboardspast(j);
  if (j == 0) {
    showboard(j);
  }
}

function grid() {
  return document.getElementById('grid');
}

function board(k) {
  let b = document.getElementById("b_" + k);
  return b && b.firstElementChild;
}

function closebutton(k) {
  return board(k).nextElementSibling;
}

function rect(k) {
  return closebutton(k).nextElementSibling;
}

function overlay(k) {
  return rect(k).nextElementSibling;
}

function cellclick(k, m) {
  // Only accept clicks on cells with something computed in them.
  if (k >= sizes.length || di[k] <= 0 || currentUpdateProcess) return;
  truncateboards(k + 2);
  removeboardspast(k + 1);
  setTimeout(function() { cellclickdelay(k, m); }, 1);
}

function cellclickdelay(k, m) {
  if (k >= sizes.length || currentUpdateProcess) return;
  let osize = sizes[k][0];
  let ore = sizes[k][1];
  let oim = sizes[k][2];
  cx = m % dims;
  cy = (m - cx) / dims;
  removeboardspast(k + 1);
  showrect(k, cx / dims, cy / dims, zoomfactor);
  truncateboards(k + 2);
  // Do slow parts after a moment.
  setTimeout(function() {
    nsize = osize / zoomfactor;
    nre = qdAdd(ore, [((cx / dims) - 0.5) * osize, 0]);
    nim = qdAdd(oim, [(0.5 - (cy / dims)) * osize, 0]);
    setboard(k + 1, nsize, nre, nim);
    makeboard(k + 1);
    board(k + 1).parentElement.className = 'hidemarks';
    board(k + 1).parentElement.scrollIntoView({ behavior: 'smooth' });
    draw(k + 1);
    showboard(k + 1);
    updateurl();
  }, 10);
}

function showrect(k, x, y, zf) {
  let s = rect(k).style;
  zf = Math.min(125, zf); // Make rectangle visible if it is tiny.
  board(k).parentElement.className = '';
  s.top = (y * cssDims - cssDims / 2 / zf) + 'px';
  s.left = (x * cssDims - cssDims / 2 / zf) + 'px';
  s.width = (cssDims / zf) + 'px';
  s.height = (cssDims / zf) + 'px';
}

function updateurl() {
  if (history.replaceState) {
    history.replaceState(null, '', currenturl());
  }
}

function currenturl() {
  let state = currentGridState();
  let compactc = '';
  let commas = '';
  let prev = [firstr, firstj];
  let prevj = -1;
  for (let j = 0; j <= state.sizes.length; j++) {
    if (j < state.sizes.length &&
        !qdCompare(state.sizes[j][1], prev[0]) &&
        !qdCompare(state.sizes[j][2], prev[1])) {
      commas += ',';
    } else {
      if (prevj >= 0) {
        compactc += formatcomplex(j - 1, state.sizes[prevj][1], state.sizes[prevj][2]) + ',';
      }
      compactc += commas;
      if (j < state.sizes.length) {
        commas = '';
        prev = [state.sizes[j][1], state.sizes[j][2]];
        prevj = j;
      }
    }
  }
  compactc = compactc.slice(0, -1);
  let url =
         (state.sizes[0][0] != 3.0 ? '&s=' + formatscale(sizes[0][0]) : '') +
         (exponent != 2 ? '&exponent=' + exponent : '') +
         (compactc.length ? '&c=' + compactc : '') +
         (gridcols != 3 ? '&grid=' + gridcols : '') +
         (state.hidden.length ? '&h=' + state.hidden : '') +
         (pixelRatio != 2 ? '&pixelratio=' + pixelRatio : '');
  return '?' + url.replace('&', '');
}

function bigurl(k) {
  if (k >= sizes.length) return;
  let osize = sizes[k][0];
  if (exponent != 2) {
    osize += '&exponent=' + exponent;
  }
  let ore = sizes[k][1];
  let oim = sizes[k][2];
  return '?s=' + formatscale(osize) + '&c=' + formatcomplex(k, ore, oim) + '&grid=1';
}

function removerect(k) {
  let s = rect(k).style;
  s.top = s.left = s.width = s.height = '';
}

let movieCanvas, movieCtx;
let movieContainer = document.getElementById('movie');
let movieMode = false;
let animationFrame = null;
let computationPaused = false;
let frameCanvases = [];
let mediaRecorder;
let recordedChunks = [];
let isRecording = false;
let recordedBlob = null;
let recordingMimeType = null;
let recordingMimeTypes = [
  'video/webm; codecs="vp8"',
  'video/webm; codecs="avc1.640029"',
  'video/webm',
  'video/mp4; codecs="avc1.640029"',
  'video/mp4',
];


function createMovieCanvas() {
  movieContainer.innerHTML = '<div>' +
    `<canvas width=${dims} height=${dims} ` +
    `style="width:${cssDims}px;height:${cssDims}px"></canvas>` +
    `<a id="moviescale" class="zoomnum">Rendering...</a></div>`;
  movieCanvas = movieContainer.firstElementChild.firstElementChild;
  movieCtx = movieCanvas.getContext('2d');
  movieCtx.drawImage(board(0), 0, 0);
}

function removeMovieCanvas() {
  while (movieContainer.firstChild) {
    movieContainer.removeChild(movieContainer.firstChild);
  }
  movieCanvas = null;
  movieCtx = null;
}

function toggleMovieMode() {
  movieMode = !movieMode;
  computationPaused = movieMode;
  if (movieMode) {
    grid().style.display = 'none';
    movieContainer.style.display = 'block';
    createMovieCanvas();
    movieContainer.scrollIntoView({ behavior: 'smooth' });
    setTimeout(function() {
      document.body.className = '';
      preRenderFrames(function() {
        startMovieAnimation();
      });
    }, 20);
  } else {
    grid().style.display = 'block';
    movieContainer.style.display = 'none';
    stopMovieAnimation();
    removeMovieCanvas();
  }
}

function preRenderFrames(after) {
  frameCanvases = [];
  function queueOneFrame(k, after) {
    return (function () {
      document.getElementById('moviescale').textContent =
        `Rendering ${formatScale(3.0 / sizes[k][0])}`;
      let canvas1 = null;
      let canvas2 = null;
      const n = nn[k];
      // Render with k-1 palette
      if (k > 0) {
        canvas1 = document.createElement('canvas');
        canvas1.width = canvas1.height = dims;
        const ctx1 = canvas1.getContext('2d');
        for (let y = 0; y < dims; y++) {
          for (let x = 0; x < dims; x++) {
            const m = y * dims + x;
            const i = n[m];
            ctx1.fillStyle = makecolor(k - 1, i);
            ctx1.fillRect(x, y, 1, 1);
          }
        }
        if (unknowncolor != '#000') {
          ctx1.strokeStyle = 'yellow';
          ctx1.lineWidth = pixelRatio * zoomfactor;
          ctx1.strokeRect(0, 0, dims, dims);
        }
      }
      // Render with k+1 palette
      if (k < sizes.length - 1) {
        canvas2 = document.createElement('canvas');
        canvas2.width = canvas2.height = dims;
        const ctx2 = canvas2.getContext('2d');
        for (let y = 0; y < dims; y++) {
          for (let x = 0; x < dims; x++) {
            const m = y * dims + x;
            const i = n[m];
            ctx2.fillStyle = makecolor(k + 1, i);
            ctx2.fillRect(x, y, 1, 1);
          }
        }
      }
      frameCanvases.push({ prev: canvas1, next: canvas2 });
      setTimeout(after, 1);
    });
  }
  for (let k = sizes.length - 1; k >= 0; k--) {
    after = queueOneFrame(k, after);
  }
  setTimeout(after, 0);
}

function startMovieAnimation() {
  let frame = 0;
  let framesteps = 300;
  let endpause = 180;
  let endrecord = 60;
  const totalFrames = (sizes.length - 1) * framesteps;
  
  const scaleElement = document.getElementById('moviescale');
  scaleElement.removeAttribute('href');

  if (!isRecording) {
    recordedBlob = null;
    isRecording = true;
    startRecording();
  }
  
  function animate() {
    const kk = Math.min(frame, totalFrames) / framesteps;
    drawMovieFrame(kk);
    frame = (frame + 1) % (totalFrames + endpause);
    
    if (isRecording && frame > totalFrames + endrecord) {
      stopRecording();
      isRecording = false;
    }
    
    animationFrame = requestAnimationFrame(animate);
  }
  animate();
}

function stopMovieAnimation() {
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
    animationFrame = null;
  }
  mp4Blob = null;
}

function startRecording() {
  const stream = movieCanvas.captureStream(30); // 30 FPS

  recordingMimeType = null;
  recordedChunks = [];
  for (let tryType of recordingMimeTypes) {
     if (MediaRecorder.isTypeSupported(tryType)) {
        recordingMimeType = tryType;
        break;
     }
  }
  if (recordingMimeType == null) {
    console.error('Neither MP4 nor WebM recording is supported');
    return;
  }
  
  mediaRecorder = new MediaRecorder(stream, {
    mimeType: recordingMimeType,
    videoBitsPerSecond: 10000000,
  });
  
  mediaRecorder.ondataavailable = (event) => {
    if (event.data.size > 0) {
      recordedChunks.push(event.data);
    }
  };
  
  mediaRecorder.onstop = () => {
    recordedBlob = new Blob(recordedChunks, { type: recordingMimeType });
    recordedChunks = [];
    updateDownloadLink();
  };
  
  mediaRecorder.start(1000); // one-second blobs
}

function stopRecording() {
  mediaRecorder.stop();
}

function updateDownloadLink() {
  const scaleElement = document.getElementById('moviescale');
  const extension = (recordingMimeType.includes('mp4') ? 'mp4' : 'webm');
  scaleElement.textContent = 'Download ' + extension;
  scaleElement.href = URL.createObjectURL(recordedBlob);
  const k = sizes.length - 1;
  scaleElement.download = 'mandelbrot' + 
              formatcomplex(k, sizes[k][1], sizes[k][2]) +
              '-' + it[k] +
              '.' + extension;
}

function drawMovieFrame(kk) {
  if (movieCtx == null) { return; }
  const k = Math.floor(kk);
  const t = kk - k;
  const sourceSize = sizes[k][0];
  const targetSize = k+1 < sizes.length ? sizes[k+1][0] : sourceSize;
  const zoomRatio = targetSize / sourceSize;

  // Use zoom ratio for exponential interpolation
  const mulT = Math.pow(zoomRatio, t);
  const expT = (zoomRatio == 1.0 ? t : (mulT - 1) / (zoomRatio - 1));
  const colorT = expT * expT;
  const interpolatedSize = sourceSize * mulT;

  // Use spline interpolation for center coordinates
  const sourceCenter = [sizes[k][1], sizes[k][2]];
  const targetCenter = k+1 < sizes.length ?
             [sizes[k+1][1], sizes[k+1][2]] : sourceCenter;

  const p0 = k > 0 ? [sizes[k-1][1], sizes[k-1][2]] : sourceCenter;
  const p1 = sourceCenter;
  const p2 = targetCenter
  const p3 = k+2 < sizes.length ? [sizes[k+2][1], sizes[k+2][2]] : targetCenter;
  const interpolatedCenter = catmullRomSpline(p0, p1, p2, p3, t);
  // const interpolatedCenter = [qdAdd(qdScale(p1[0], 1-t), qdScale(p2[0], t)),
  //                             qdAdd(qdScale(p1[1], 1-t), qdScale(p2[1], t))];

  // Clear the movie canvas
  // movieCtx.clearRect(0, 0, dims, dims);
  movieCtx.fillStyle = makecolor(k, 1);
  movieCtx.fillRect(0, 0, dims, dims);

  // Draw the current frame
  const scale = sourceSize / interpolatedSize;
  const offsetX = qdMul(qdSub(interpolatedCenter[0], sourceCenter[0]),
                        [dims / sourceSize, 0])[0];
  const offsetY = qdMul(qdSub(sourceCenter[1], interpolatedCenter[1]),
                        [dims / sourceSize, 0])[0];
  movieCtx.save();
  movieCtx.imageSmoothingEnabled = true;
  movieCtx.imageSmoothingQuality = 'high';
  movieCtx.translate(dims / 2, dims / 2);
  movieCtx.scale(scale, scale);
  movieCtx.translate(-dims / 2 - offsetX, -dims / 2 - offsetY);
  movieCtx.globalAlpha = 1;
  movieCtx.drawImage(board(k), 0, 0);

  // Blend the color palette of the next frame
  if (frameCanvases[k].next) {
    movieCtx.globalAlpha = colorT;
    movieCtx.drawImage(frameCanvases[k].next, 0, 0);
  }
  movieCtx.restore();

  // Draw the next frame
  if (k < sizes.length - 1) {
    const targetScale = targetSize / interpolatedSize;
    const targetOffsetX = qdMul(qdSub(interpolatedCenter[0], targetCenter[0]),
                                [dims / targetSize, 0])[0];
    const targetOffsetY = qdMul(qdSub(targetCenter[1], interpolatedCenter[1]),
                                [dims / targetSize, 0])[0];
    movieCtx.save();
    movieCtx.imageSmoothingEnabled = true;
    movieCtx.imageSmoothingQuality = 'high';
    movieCtx.translate(dims / 2, dims / 2);
    movieCtx.scale(targetScale, targetScale);
    movieCtx.translate(-dims / 2 - targetOffsetX, -dims / 2 - targetOffsetY);
    movieCtx.globalAlpha = 1;
    movieCtx.drawImage(frameCanvases[k + 1].prev, 0, 0);
    movieCtx.globalAlpha = colorT;
    movieCtx.drawImage(board(k + 1), 0, 0);
    movieCtx.restore();
  }

  // Update scale text
  if (!recordedBlob) {
    const currentScale = (3.0 / firstsize) * (Math.pow(zoomfactor, kk));
    document.getElementById('moviescale').textContent = formatScale(currentScale);
  }
}

function catmullRom1D(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const c0 = (-t3 + 2*t2 - t) / 2;
  // c1 = (3*t3 - 5*t2 + 2) / 2; // unneeded since p1 = 0
  const c2 = (-3*t3 + 4*t2 + t) / 2;
  const c3 = (t3 - t2) / 2;
  // Compute offsets from p1 for numerical stability.
  const s0 = qdSub(p0, p1);
  const s2 = qdSub(p2, p1);
  const s3 = qdSub(p3, p1);
  return qdAdd(qdAdd(qdAdd(qdScale(s0, c0),
           qdScale(s3, c3)), qdScale(s2, c2)), p1);
}

function catmullRomSpline(p0, p1, p2, p3, t) {
  return [
    catmullRom1D(p0[0], p1[0], p2[0], p3[0], t),
    catmullRom1D(p0[1], p1[1], p2[1], p3[1], t)
  ];
}

document.body.onmousedown = function(e) {
  if (e.target.className == 'closebox') {
    e.stopPropagation();
  }
}
document.body.onclick = function(e) {
  if (e.target.className == 'closebox' && !currentUpdateProcess) {
    e.target.parentElement.style.display = 'none';
    truncatehiddenboards();
    updateZoomRectangles();
    updateurl();
  }
}

if (dims > 800) {
  makeboard(0);
  setTimeout(start, 100);
} else{
  setTimeout(start, 1);
}

//////////// quad-precision (qd, double double), aided by claude.ai ///////////

function fast2Sum(a, b) {
  let s = a + b;
  let t = b - (s - a);
  return [s, t];
}

function slow2Sum(a, b) {
  let s = a + b;
  let c = s - a;
  return [s, (a - (s - c)) + (b - c)];
}

function qdSplit(a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  return [x, y];
}

function twoProduct(a, b) {
  let p = a * b;
  let [ah, al] = qdSplit(a);
  let [bh, bl] = qdSplit(b);
  let err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  return [p, err];
}

function twoSquare(a) {
  let p = a * a;
  let [ah, al] = qdSplit(a);
  let err = ((ah * ah - p) + 2 * ah * al) + al * al;
  return [p, err];
}

function qdAdd(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [h1, h2] = slow2Sum(a1, b1);
  let [l1, l2] = slow2Sum(a0, b0);
  let [v1, v2] = fast2Sum(h1, h2 + l1);
  return fast2Sum(v1, v2 + l2);
}

function qdMul(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [p1, p2] = twoProduct(a1, b1);
  return fast2Sum(p1, p2 + a1 * b0 + b1 * a0);
}

function qdDouble(a) {
  return [a[0] * 2, a[1] * 2];
}

function qdScale(q, s) {
  let [q1, q0] = q;
  let [p1, p2] = twoProduct(q1, s);
  return fast2Sum(p1, p2 + s * q0);
}

function qdSquare(a) {
  let [a1, a0] = a;
  let [p1, p2] = twoSquare(a1);
  return fast2Sum(p1, p2 + 2 * a1 * a0);
}

function qdNegate(a) {
  let [a1, a0] = a;
  return [-a1, -a0];
}

function qdSub(a, b) {
  return qdAdd(a, qdNegate(b));
}

function qdDiv(a, b) {
  let reciprocal = qdReciprocal(b);
  return qdMul(a, reciprocal);
}

function qdReciprocal(b, iters = 2) {
  if (b[0] === 0 && b[1] === 0) {
    return [NaN, 0];  // Return NaN for division by zero
  }
  // Refine the approximation using Newton-Raphson iteration
  let x = [1 / b[0], 0];
  for (let i = 0; i < iters; i++) {
    x = qdMul(x, qdSub([2, 0], qdMul(x, b)));
  }
  return x;
}

function qdParse(s) {
  s = s.trim().toLowerCase();
  if (s === "infinity" || s === "+infinity") return [Infinity, 0];
  if (s === "-infinity") return [-Infinity, 0];
  if (s === "nan") return [NaN, 0];
  let sign = 1;
  if (s[0] === '-') {
    sign = -1;
    s = s.slice(1);
  } else if (s[0] === '+') {
    s = s.slice(1);
  }
  let e = 0;
  let parts = s.split('e');
  if (parts.length > 1) {
    s = parts[0];
    e = parseInt(parts[1]);
  }
  let decimalPos = s.indexOf('.');
  if (decimalPos !== -1) {
    s = s.replace('.', '');
    e -= s.length - decimalPos;
  }
  s = s.replace(/^0+/, '');
  if (s === '') return [0, 0];
  let result = [0, 0];
  for (let digit of s) {
    result = qdAdd(qdMul(result, [10, 0]), [parseInt(digit), 0]);
  }
  if (e !== 0) {
    result = qdMul(result, qdPow10(e));
  }
  if (sign === -1) {
    result = qdNegate(result);
  }
  return result;
}

function qdPow10(e) {
  if (e === 0) return [1, 0];
  let result = [1, 0];
  for (let i = 0; i < Math.abs(e); i++) {
    result = qdMul(result, [10, 0]);
  }
  return (e < 0) ? qdReciprocal(result) : result;
}

function qdFloor(q) {
  let [a, b] = q;
  let fl = Math.floor(a);
  let [r0, r1] = qdSub([a, b], [fl, 0]);
  if (r0 < 0 || (r0 === 0 && r1 < 0)) {
    fl -= 1;
  }
  return [fl, 0];
}

function qdCompare(a, b) {
  if (a[0] < b[0]) return -1;
  if (a[0] > b[0]) return 1;
  if (a[1] < b[1]) return -1;
  if (a[1] > b[1]) return 1;
  return 0;
}

function qdLt(a, s) {
  return a[0] + a[1] < s;
}

function qdGt(a, s) {
  return a[0] + a[1] > s;
}

function qdEq(a, s) {
  return a[0] == s && a[1] == 0;
}

function qdAbs(q) {
  return (q[0] + q[1] < 0) ? qdNegate(q) : q;
}

function qdFixed(q, digits = 0) {
  // With fixed-point notation, digits specifies the number of digits after the decimal point.
  return qdFormat(q, digits, true);
}

const qdTen = [10, 0];

function qdFormat(q, digits = 'auto', useFixedPoint = false) {
  // With scientific notation, digits specifies the number of significant digits.
  let [a, b] = q;
  let s = a < 0 || (a === 0 && b < 0) ? '-' : '';
  let autoFormat = (digits == 'auto');
  if (autoFormat) {
     digits = 32;
  }
  q = qdAbs(q);
  if (!isFinite(a) || !isFinite(b)) return a.toString();
  if (a === 0 && b === 0) {
     if (autoFormat) return '0';
     if (useFixedPoint) digits += 1;
     return '0' + (digits > 1 ? '.' + '0'.repeat(digits - 1) : '');
  }
  // Scale q to be between 1 and 10, avoiding cumulative rounding
  let e = 0;
  let ex = [1, 0];
  while (qdCompare(q, qdMul(ex, qdTen)) >= 0) {
    ex = qdMul(ex, qdTen);
    e += 1;
  }
  while (qdLt(qdMul(ex, q), 1)) {
    ex = qdMul(ex, qdTen);
    e -= 1;
  }
  if (e) {
    q = (e > 0 ? qdDiv(q, ex) : qdMul(q, ex));
  }
  if (!qdLt(q, 10)) { // Hit boundary condition
    q = qdDiv(q, qdTen);
    e += 1;
  }
  let result = '';
  let nonzeroDigits = digits;
  if (useFixedPoint && !autoFormat) {
     nonzeroDigits = nonzeroDigits + e + 1;
  }
  for (let i = 0; i < nonzeroDigits + 1; i++) {
    let floorQ = qdFloor(q);
    let digit = floorQ[0];
    result += digit;
    q = qdSub(q, floorQ);
    q = qdMul(q, qdTen);
  }
  if (autoFormat) {
    if (parseInt(result.slice(result.length - 3)) > 970 ||
      parseInt(result.slice(result.length - 3)) < 30 ||
      parseInt(result.slice(result.length - 2)) > 92) {
      nonzeroDigits -= 1; // round to one fewer digit
    }
  }
  // Rounding
  if (parseInt(result[nonzeroDigits]) >= 5) {
    let carry = 1;
    for (let i = nonzeroDigits - 1; i >= 0; i--) {
      let digit = parseInt(result[i]) + carry;
      if (digit < 10) {
        result = result.slice(0, i) + digit + result.slice(i + 1);
        carry = 0;
        break;
      } else {
        result = result.slice(0, i) + '0' + result.slice(i + 1);
        carry = 1;
      }
    }
    if (carry) {
      result = '1' + result;
      e++;
    }
  }
  result = result.slice(0, nonzeroDigits);
  epart = '';
  if (!useFixedPoint && (!autoFormat || e < -6 || e > 32)) {
    // Scientific notation
    if (result.length > 1) {
      result = result[0] + '.' + result.slice(1);
    }
    if (e !== 0) {
      epart = 'e' + e;
    }
  } else {
    // Fixed-point notation
    if (e >= 0) {
      result = result.padEnd(e + 1, '0');
      result = result.slice(0, e + 1) + '.' + result.slice(e + 1);
    } else {
      result = '0.' + '0'.repeat(-e - 1) + result;
    }
    // Ensure the correct number of digits after the decimal point
    let [intPart, fracPart] = result.split('.');
    if (digits <= 0) {
      result = intPart;
    } else {
      fracPart = (fracPart || '').padEnd(digits, '0');
      result = intPart + '.' + fracPart;
    }
  }
  if (autoFormat) {
    // Auto digit selection: trim trailing zeros
    result = result.replace(/\.0+$|(\.\d*[1-9])0+$/, "$1");
  }
  return s + result + epart;
}
</script>
</body>
<script src="https://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-242212-1";
urchinTracker();
</script>
</html>
