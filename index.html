<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>Mandelbrot Set Fractal Explorer</title>
<meta name="description" content="Beautiful, fast, and precise exploration of the
Mandelbrot Set online. Click to zoom. Hover to see orbits. M makes a smooth movie of
your zoom path.">
<meta name="viewport" content="width=device-width">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="shortcut icon" type="image/png" href="favicon-128x128.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="favicon-180x180.png">
<link rel="apple-touch-icon" type="image/png" sizes="192x192" href="favicon-192x192.png">
<link rel="apple-touch-icon" type="image/png" sizes="512x512" href="favicon-512x512.png">
<link rel="canonical" href="https://mandelbrot.page/">
<!--
Written by David Bau as a Javascript example in 2009; updated in 2020
to handle high device pixel ratios, show orbits, and report periodicity.
Keyboard controls added in 2022, and double-double precision perturbations,
additional exponents, movie generation and web workers added in 2024.
Claude code added GPU support in 2025.

URL options: ?grid=3           to select 3-column view,
                &c=-0.14-0.65i to set center (can chain: c=re+im,re+im,...),
                &z=25          zoom (1.0=default, higher=more zoomed),
                &a=16:9        aspect ratio (default is 1:1 square),
         &exponent=3           exponent (default is 2),
            &theme=warm        color theme (warm/neon/iceblue/tiedye/gray),
              &unk=000         unknown pixel color (hex or CSS color name),
                &h=1,2         hide views by index (comma-separated),
       &pixelratio=2           subpixel resolution,
             &lang=es          language (en/es/zh/zh-tw/ar/id/pt/fr/ja/ru/de),
              &gpu=0           disable GPU acceleration,
            &board=gpuz        force algorithm (cpu/gpu/gpuz/ddz/qdz/
                               adaptive/qdcpu),
           &inherit=0          disable parent-to-child inheritance,
             &debug=w,s        debug flags (w,s,n,t,b,r,inherit).

Implementation notes.  To minimize computation, the code identifies both
points that diverge and points that converge.  It uses a method that can
identify convergence to periodic cycles of arbitrarily long length.
After the number of unknown points is less than half the visual field,
it computes the remaining points sparsely, avoiding iterating over the
already-known points.
-->
<style>
body { font-family: Arial; background: #888; margin: 14px; text-align: center; }
canvas { vertical-align:bottom; cursor:crosshair; user-select: none; }
#grid > div, #text { display: inline-block; margin: 10px;
  position: relative; vertical-align: top; background: rgba(90, 90, 90, 0.5); }
#movie > div { display: inline-block; margin: 10px;
  position: relative; vertical-align: top; background: black; }
#grid { color: yellow; }
#grid > div:only-child .closebox { display: none; }
#grid:empty ~ #text { display: none; }
#text { text-align: left; width: auto; background:#aaa; margin: 10px;
  position:relative;padding:3px 8px;font-size: 11pt; }
.exponent { line-height: 0; }
.closebox { position: absolute; right: 3px; top: 0; cursor: pointer;
  transition: opacity 0.3s; user-select: none; }
.closebox:after { content: '\00d7'; font-size: 20px; }
.closebox:active:after { -webkit-text-stroke: 2px; opacity: 0.8; }
.closebox:hover { font-weight: bold; }
.rect { position: absolute; height: 0; width: 0;
  pointer-events: none; opacity: 0.7; transition: opacity 0.3s; }
.rect:after { content: ''; display: block; position: absolute;
  top: 0; bottom: 0; left: 0; right: 0; border: 1px solid yellow;
  box-shadow: 0px 0px 4px 1px #880; }
.circle .rect:after { border-radius: 100px; }
.hidemarks .rect { opacity: 0; }
.overlay { position: absolute; pointer-events: none; opacity: 0.8;
  top:0; left:0; z-index:1; transition: opacity 0.3s; }
.zoomnum { position:absolute; display:inline-block; right:0; bottom:-11pt;
  text-decoration: none; font-size: 11pt; color: yellow; min-width: 25%;
  text-align:right; transition: opacity 0.3s; z-index: 1; cursor: pointer;
  user-select: none; }
.zoomnum[href]:hover { text-decoration: underline; }
body.hidemarks .overlay { opacity: 0; }
body.hidemarks #grid .zoomnum { opacity: 0; }
body.hidemarks #grid .closebox { opacity: 0; }
div a div.status { /* tooltips */
  display: none; position: absolute; top: 17px; right: 0;
  width: auto; background-color: #ddd; color: #444;
  font: 11pt Arial; text-align: right; white-space: pre;
  padding: 3px 7px; box-shadow: 2px 2px 5px #777;
  /* pointer-events: none; */ z-index: 100;
  opacity: 0; transition: opacity 0.25s ease; }
div a div.status.align-left { right: auto; text-align: left; }
#grid div:has(a:hover) { z-index: 10; }  /* Raise view when popup shown */
#grid div:hover a div.status {
  display: block; }
div:hover a:focus div.status, div a:hover div.status {
  display: block;
  opacity: 0.95; }
body.starting div#b_0:after { display: flex; position: absolute;
  top: 0; left: 0; width: 100%; height: 100%; align-items: center;
  justify-content: center; color: white;
  z-index: -1; background: rgb(32,16,64); }
#moviestatus { position: absolute; left: 0; bottom: -11pt;
  font-size: 11pt; color: yellow; }
#fullscreen-button { position: fixed; bottom: 20px; right: 20px; font-size: 36px;
  cursor: pointer; user-select: none; opacity: 0.7; transition: opacity 0.15s;
  color: white; font-weight: bold; z-index: 10; display: none; }
#fullscreen-button:hover { opacity: 1; }
:fullscreen #fullscreen-button { display: none !important; }
/* Fullscreen mode adjustments */
:fullscreen { margin: 0; padding: 0; scroll-snap-type: y proximity;
  overflow-y: scroll; }
:fullscreen body { margin: 0; padding: 0; }
:fullscreen #grid { margin: 0; padding: 0; }
:fullscreen #grid > div {
  margin: 0; padding: 0; background: transparent;
  scroll-snap-align: start; scroll-snap-stop: normal; }
:fullscreen #movie > div { margin: 0; padding: 0; background: black;
  scroll-snap-align: start; }
:fullscreen #text { scroll-snap-align: start; }
:fullscreen canvas { display: block; }
:fullscreen .zoomnum { bottom: 0; }
:fullscreen #moviestatus { bottom: 0; }
:fullscreen div a div.status { top: auto; bottom: 100%; }
</style>
</head>
<body class="starting">
<svg xmlns="http://www.w3.org/2000/svg" style="display:none">
  <symbol id="github-icon" viewBox="0 0 512 512">
    <circle cx="256" cy="256" r="256" fill="#181717"/>
    <path fill="#fff" d="M335 499c-13 0-16-6-16-12l1-70c0-24-8-40-18-48 57-6
      117-28 117-126 0-28-10-51-26-69 3-6 11-32-3-67 0 0-21-7-70 26-42-12-86-12
      -128 0-49-33-70-26-70-26-14 35-6 61-3 67-16 18-26 41-26 69 0 98 59 120
      116 126-7 7-14 18-16 35-15 6-52 17-74-22 0 0-14-24-40-26 0 0-25 0-1 16 0
      0 16 7 28 37 0 0 15 50 86 34l1 44c0 6-3 12-16 12-14 0-12 17-12 17H347s2
      -17-12-17Z"/>
  </symbol>
</svg>
<div id=movie></div>
<div id=grid></div>
<div id=fullscreen-button title="Enter fullscreen (Enter)">⛶</div>
<div id=text style="max-width: 442px">
<div class=closebox></div>

<div lang="en">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Mandelbrot Set Fractal Explorer
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Tap">Click</span> to zoom.</b>
<span mobile="">Right-click to save images, <b>M</b> to make and save a movie
of your zoom path.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> is iterated for each
<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number"
 >complex number</a> <em>c</em>.  Colors show
<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iterations</a>
to divergence; black points
<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">converge or cycle</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Yellow dots show
<a target="mbhelp"
 href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbits</a></b>.
Red dots show limit cycles.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>About iterations.</b> This viewer shows more fractal detail over time by
refining iterations to infinity as you explore. The longer you wait, the more
detail is shown.
After thousands or millions of iterations, you can resolve the finest details
in the most complex parts of the fractal.
See information on iterations, progress, and coordinates by
<span mobile="tapping">hovering over</a> the yellow zoom number under each window.
<span mobile="Holding your fingertip">Moving your mouse</span> over fractal
content will animate the orbit of <em>z</em> values for each location <em>c</em>,
revealing the complex boundary dynamics that have fascinated mathematicians.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Exploring a zoom path.</b>
Each <span mobile="tap">click</span> on the fractal opens a higher zoom level at
the selected location, computed on your GPU if available.
After you zoom beyond trillion-fold magnification, we use double-double
and quad-double precision perturbation algorithms that resolve fine details to more
than 60 digits of accuracy.
Once you have crafted an interesting path that shows the detail you want, you can
<a class="moviemode">create and download your own Mandelbrot deep zoom video</a>
or bookmark your URL to save and share your exploration.
To create high-quality images and videos, this viewer computes subpixels with a
<span class="pixelratio">2</span>:1 ratio<span mobile="">, and that can be
increased to create more precise displays</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>More commands:</b>
<b>I</b> zooms in;
<b mac="&#8984;">Ctrl</b>-click to zoom in-place;
<b>H</b> shrinks and <b>G</b> grows each window;
<b>R</b> reopens midway windows;
<b>C</b> recenters all;
<b>T</b> changes color theme;
<b>U</b> highlights unfinished pixels;
<b mac="Return">Enter</b> toggles full-screen;
<b>X</b> increases and <b>Z</b> decreases the <em>z</em> exponent;
<b>F</b> increases and <b>D</b> decreases the pixel ratio;
<b>A</b> toggles aspect ratio;
<b>M</b> makes a movie that follows your path;
<nobr><b>?</b> shows this help.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<script id="mainCode">
// =============================================================================
// MANDELBROT FRACTAL EXPLORER - APPLICATION ARCHITECTURE
// =============================================================================
//
// This application renders the Mandelbrot set with deep zoom capabilities,
// GPU acceleration, and extended-precision mathematics (DD and QD) for
// trillion-fold magnification.
//
// CORE COMPONENTS:
//
// 1. MandelbrotExplorer - Main application controller (this class below)
//    - Initializes all subsystems
//    - Coordinates application lifecycle
//    - Manages fullscreen mode and theme cycling
//
// 2. StateStore - Centralized state container
//    - Holds all application state in immutable tree
//    - Provides dispatch() to update state via actions
//    - Maintains action log for debugging
//
// 3. Config - Configuration facade
//    - Property getters/setters that delegate to StateStore
//    - Handles viewport sizing and color themes
//    - Maintains backward compatibility
//
// 4. Grid - Canvas and view manager
//    - Creates/destroys View objects for each zoom level
//    - Manages canvas DOM elements
//    - Coordinates with Scheduler for worker threads
//
// 5. View - Individual zoom level rendering
//    - Stores pixel iteration data
//    - Renders to canvas using color themes
//    - Manages multi-resolution compositing
//
// 6. Board subclasses - Fractal computation engines (run in worker threads)
//    - CpuBoard: Basic CPU computation (shallow zoom)
//    - DDZhuoranBoard: DD precision with perturbation theory (CPU, medium zoom)
//    - QDZhuoranBoard: QD precision with perturbation theory (CPU, deep zoom)
//    - GpuBoard: WebGPU with sparse compaction (shallow zoom)
//    - GpuZhuoranBoard: WebGPU with DD perturbation (medium zoom)
//    - AdaptiveGpuBoard: WebGPU with QD perturbation (deep zoom)
//
// UPDATE CYCLE EXAMPLE:
//
//   User clicks canvas to zoom
//     ↓
//   EventHandler → ZoomManager.cellclick()
//     ↓
//   Grid.makeView() creates new View and canvas
//     │
//     ├─→ Scheduler assigns Board to worker thread
//     │     ↓
//     │   Worker computes iterations, sends progress updates
//     │     ↓
//     │   Grid.updateViewFromWorkerResult() updates View
//     │     ↓
//     │   View.color() renders pixels to canvas
//     │
//     └─→ Grid.notifyurl() → URLHandler.updateurl() syncs browser URL
//
// OTHER CLASSES:
//
// - EventHandler: Mouse and keyboard input processing
// - ZoomManager: Zoom rectangle selection and coordinate calculation
// - URLHandler: Browser URL synchronization for bookmarking/sharing
// - Scheduler: Worker thread pool management and load balancing
// - MovieMode: Smooth zoom video recording and MP4 generation
// - OrbitComputer: Hover-to-show orbit visualization
// - RedrawProcess: Progressive rendering coordination
// - ReferenceOrbitThreading: Deep zoom perturbation helper
//
// =============================================================================

// Main application controller that coordinates all subsystems.
class MandelbrotExplorer {
  constructor() {
    // Create unified state store
    this.store = new StateStore();

    // Create subsystems with state store integration
    this.config = new Config(this.store);
    this.grid = new Grid(this.config, this.store);
    this.zoomManager = new ZoomManager(this.config, this.grid);
    this.urlHandler = new URLHandler(this.config, this.grid, this.store);
    this.eventHandler = new EventHandler(this);
    this.movieMode = new MovieMode(this);
    this.orbitComputer = new OrbitComputer(this);
    this.redrawProcess = new RedrawProcess(this);
    this.movieContainer = document.getElementById('movie');
    this.allViewsCompleted = false;

    // Listen for fullscreen changes
    document.addEventListener('fullscreenchange', () => this.onFullscreenChange());

    // Clear native tooltip when hovering over zoom numbers to show custom tooltip
    document.addEventListener('mouseover', (e) => {
      if (e.target.classList.contains('zoomnum') || e.target.closest('.zoomnum')) {
        const isZoomnum = e.target.classList.contains('zoomnum');
        const zoomnum = isZoomnum ? e.target : e.target.closest('.zoomnum');
        const gridDiv = zoomnum.closest('#grid > div');
        if (gridDiv) {
          gridDiv.setAttribute('title', '');
        }
      }
    });
  }

  start() {
    this.startTime = Date.now();
    console.log(new Date);
    let startState = this.urlHandler.parseUrl();
    this.config.initSizes();

    // Fill in default sizes if none were specified in URL
    if (startState.sizes.length === 0) {
      startState.sizes = this.config.firststate().sizes;
    }

    // Convert zoom/size from URL to absolute size
    // zoomFromUrl: {mantissa, exponent} from z= parameter
    // sizeFromUrl: {mantissa, exponent} from s= parameter (legacy)
    let actualSize = null;
    if (this.config.sizeFromUrl !== undefined) {
      // s= parameter: size value directly (e.g., s=1e-15)
      const { mantissa, exponent } = this.config.sizeFromUrl;
      delete this.config.sizeFromUrl;
      const size = mantissa * Math.pow(10, exponent);
      if (size === 0 || !isFinite(size)) {
        console.warn(`Size too extreme, capping at minimum supported size (~3e-310)`);
        actualSize = 3e-310;
      } else {
        actualSize = size;
      }
    } else if (this.config.zoomFromUrl !== undefined) {
      // z= parameter: {mantissa, exponent} for extreme zoom values
      const { mantissa, exponent } = this.config.zoomFromUrl;
      delete this.config.zoomFromUrl;
      // Compute size = firstsize / zoom = (firstsize / mantissa) * 10^(-exponent)
      // Now firstsize has the correct aspect-ratio-adjusted value
      const baseSize = this.config.firstsize / mantissa;
      const size = baseSize * Math.pow(10, -exponent);
      if (size === 0 || !isFinite(size)) {
        // Cap at ~1e310 zoom to ensure pixel sizes remain representable
        console.warn(`Zoom too extreme, capping at maximum supported zoom (~1e310)`);
        actualSize = 3e-310;
      } else {
        actualSize = size;
      }
    }

    if (actualSize !== null) {
      // Fill in sizes with the zoom-adjusted value
      for (let i = 0; i < startState.sizes.length; i++) {
        if (startState.sizes[i][0] === null) {
          startState.sizes[i][0] = actualSize / Math.pow(this.config.zoomfactor, i);
        }
      }
    } else {
      // Fill in sizes with default firstsize
      for (let i = 0; i < startState.sizes.length; i++) {
        if (startState.sizes[i][0] === null) {
          startState.sizes[i][0] = this.config.firstsize / Math.pow(this.config.zoomfactor, i);
        }
      }
    }

    this.initPlatform();
    this.grid.updateLayout(startState);
    this.grid.setupFullscreenButtonHover();
    this.eventHandler.setup();
    this.grid.updateHiddenViews(); // Initial update of hidden boards
  }

  checkAllViewsComplete() {
    if (this.allViewsCompleted) return;

    // Check if all views are done (use unfinished() to account for chaotic pixels after 100k)
    const allDone = this.grid.views.every(view => view && view.unfinished() === 0);

    if (allDone && this.grid.views.length > 0) {
      this.allViewsCompleted = true;
      const elapsed = Date.now() - this.startTime;
      console.log(`All views completed in ${(elapsed / 1000).toFixed(2)}s`);
    }
  }

  cycleUnknownColor(backward) {
    const palette = this.config.unknownColorPalette;
    const inc = backward ? palette.length - 1 : 1;
    const currentIndex = palette.indexOf(this.config.unknowncolor);
    const ind = (currentIndex + inc) % palette.length;
    this.config.setUnknowncolor(palette[ind]);
    // Update div backgrounds instead of redrawing canvases
    for (let k = 0; k < this.grid.views.length; ++k) {
      const canvas = this.grid.canvas(k);
      if (canvas && canvas.parentElement) {
        canvas.parentElement.style.backgroundColor = this.config.unknowncolor;
      }
    }
    this.urlHandler.updateurl();
  }

  cycleColorTheme(backward) {
    const inc = backward ? this.config.colorThemes.all.length - 1 : 1;
    const themes = this.config.colorThemes.all;
    const currentIndex = themes.indexOf(this.config.theme);
    const nextIndex = (currentIndex + inc) % themes.length;
    this.config.setTheme(themes[nextIndex]);
    this.redrawProcess.start();
    this.urlHandler.updateurl();
  }

  toggleFullscreen() {
    if (!document.fullscreenElement) {
      // Save pre-fullscreen settings
      this.preFullscreenGridcols = this.config.gridcols;
      this.preFullscreenAspectRatio = this.config.aspectRatio;

      document.documentElement.requestFullscreen().catch(err => {
        console.log(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  }

  onFullscreenChange() {
    // Update state
    if (this.store) {
      this.store.dispatch(
        this.store.actions.setFullscreen(!!document.fullscreenElement)
      );
    }

    // Exit movie mode if active
    if (this.movieMode.active) {
      this.movieMode.toggle();
    }

    if (document.fullscreenElement) {
      // Entering fullscreen
      // Only process if grid has views
      if (!this.grid.views || this.grid.views.length === 0) {
        return;
      }

      // Delay to allow browser to fully transition to fullscreen
      setTimeout(() => {
        // Calculate fullscreen aspect ratio from actual window dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const viewportAspectRatio = viewportWidth / viewportHeight;

        const oldFirstsize = this.config.firstsize;

        // Set grid to 1 column and aspect ratio to match viewport (batched)
        this.store.dispatch(this.store.actions.updateConfig({
          gridcols: 1,
          aspectRatio: viewportAspectRatio
        }));

        // Get current state before recalculating sizes
        const state = this.grid.currentGridState();

        // Call initSizes to recalculate dimensions for fullscreen
        this.config.initSizes();
        const newFirstsize = this.config.firstsize;

        // Scale all existing view sizes proportionally
        const scaleFactor = newFirstsize / oldFirstsize;
        for (let i = 0; i < state.sizes.length; i++) {
          state.sizes[i][0] *= scaleFactor;
        }

        // Skip initSizes in updateLayout since we already called it
        this.grid.updateLayout(state, true);

        // Only update URL if we have views
        if (this.grid.views && this.grid.views.length > 0) {
          this.urlHandler.updateurl();
        }

        // Scroll to top immediately
        window.scrollTo(0, 0);
      }, 100);  // 100ms delay to allow fullscreen transition
    } else {
      // Exiting fullscreen - restore pre-fullscreen settings
      if (this.preFullscreenGridcols !== undefined && this.grid.views &&
          this.grid.views.length > 0) {
        const oldFirstsize = this.config.firstsize;

        // Restore pre-fullscreen settings (batched)
        this.store.dispatch(this.store.actions.updateConfig({
          gridcols: this.preFullscreenGridcols,
          aspectRatio: this.preFullscreenAspectRatio
        }));

        // Get current state before recalculating sizes
        const state = this.grid.currentGridState();

        // Call initSizes to recalculate dimensions
        this.config.initSizes();
        const newFirstsize = this.config.firstsize;

        // Scale all existing view sizes proportionally
        const scaleFactor = newFirstsize / oldFirstsize;
        for (let i = 0; i < state.sizes.length; i++) {
          state.sizes[i][0] *= scaleFactor;
        }

        // Skip initSizes in updateLayout since we already called it
        this.grid.updateLayout(state, true);
        this.urlHandler.updateurl();
      }
    }
  }

  initPlatform() {
    if (this.config.mac) {
      for (let el of document.querySelectorAll('[mac]')) {
        el.innerHTML = el.getAttribute('mac');
      }
    }
    if (this.config.mobile) {
      for (let el of document.querySelectorAll('[mobile]')) {
        el.innerHTML = el.getAttribute('mobile');
      }
    }
    for (let el of document.querySelectorAll('.moviemode')) {
      el.href = '#movie';
      el.onclick = (() => {
        if (this.grid.views.length > 1) {
          this.movieMode.toggle();
        }
        return true;
      });
    }
    // Set up fullscreen button
    const fullscreenButton = document.getElementById('fullscreen-button');
    if (fullscreenButton) {
      fullscreenButton.onclick = () => {
        this.toggleFullscreen();
      };
    }
  }
}

// Centralized state management with action dispatch pattern.
class StateStore {
  constructor() {
    this.state = this.createInitialState();
    this.actionLog = [];  // For debugging
    this.enableLogging = false;  // Set to true for debugging
  }

  createInitialState() {
    return {
      // Viewport and rendering configuration
      config: {
        // Canvas dimensions
        vw: 0,                    // Viewport width
        gridcols: 1,              // Number of grid columns
        cssDims: 0,               // CSS pixel size
        cssDimsWidth: 0,          // CSS width
        cssDimsHeight: 0,         // CSS height
        dimsWidth: 0,             // Canvas pixel width
        dimsHeight: 0,            // Canvas pixel height
        pixelRatio: 2,            // Device pixel ratio

        // Computation parameters
        exponent: 2,              // Mandelbrot exponent (z^n + c)
        enableGPU: true,          // Allow WebGPU acceleration
        forceBoard: null,         // Force specific board type
        debug: null,              // Debug string for controlling behaviors

        // Display parameters
        theme: 'warm',            // Color theme
        unknowncolor: '#000',     // Color for uncomputed pixels
        zoomfactor: 5,            // Default zoom factor
        aspectRatio: 1.0,         // Default aspect ratio

        // Initial view parameters
        firstsize: 3.0,           // Initial view size

        // Platform detection
        mobile: false,
        mac: false
      },

      // Views (zoom levels)
      views: [],  // Array of { k, sizes: [size, re, im], hidden, parentK }

      // UI state
      ui: {
        mouseDown: false,
        mouseButton: null,
        mousePosition: { x: 0, y: 0 },
        focusedView: null,        // Currently focused view index
        zoomRectangle: null,      // { k, x, y, width, height }
        orbitPoint: null,         // { k, x, y, orbit: [...] }
        movieMode: {
          active: false,
          progress: 0,
          rendering: false
        },
        fullscreen: false
      },

      // Computation status (updated from workers)
      computation: {
        views: {},                // k -> { un, di, ch, it, workerInfo, boardType }
        isComputing: false,
        allCompleted: false
      }
    };
  }

  // Get current state (immutable)
  getState() {
    return this.state;
  }

  // Dispatch an action to update state
  dispatch(action) {
    if (this.enableLogging) {
      console.log('Action:', action.type, action);
      console.log('Old state:', JSON.parse(JSON.stringify(this.state)));
    }

    const oldState = this.state;
    this.state = this.reducer(this.state, action);

    if (this.enableLogging) {
      console.log('New state:', JSON.parse(JSON.stringify(this.state)));
      this.actionLog.push({ action, oldState, newState: this.state, timestamp: Date.now() });
    }
  }

  // Reducer: pure function that computes new state from old state + action
  reducer(state, action) {
    switch (action.type) {
      // Configuration updates
      case 'CONFIG_INIT_SIZES': {
        const { vw, gridcols, cssDims, cssDimsWidth, cssDimsHeight,
                dimsWidth, dimsHeight, pixelRatio, firstsize } = action;
        return {
          ...state,
          config: {
            ...state.config,
            vw,
            gridcols,
            cssDims,
            cssDimsWidth,
            cssDimsHeight,
            dimsWidth,
            dimsHeight,
            pixelRatio,
            firstsize
          }
        };
      }

      case 'CONFIG_SET_ASPECT_RATIO':
        return {
          ...state,
          config: { ...state.config, aspectRatio: action.aspectRatio }
        };

      case 'CONFIG_SET_THEME':
        return {
          ...state,
          config: { ...state.config, theme: action.theme }
        };

      case 'CONFIG_SET_PIXEL_RATIO':
        return {
          ...state,
          config: { ...state.config, pixelRatio: action.pixelRatio }
        };

      case 'CONFIG_SET_UNKNOWN_COLOR':
        return {
          ...state,
          config: { ...state.config, unknowncolor: action.unknowncolor }
        };

      case 'CONFIG_UPDATE':
        return {
          ...state,
          config: { ...state.config, ...action.config }
        };

      // UI state updates
      case 'UI_MOUSE_DOWN':
        return {
          ...state,
          ui: {
            ...state.ui,
            mouseDown: true,
            mouseButton: action.button,
            mousePosition: action.position
          }
        };

      case 'UI_MOUSE_UP':
        return {
          ...state,
          ui: {
            ...state.ui,
            mouseDown: false,
            mouseButton: null
          }
        };

      case 'UI_MOUSE_MOVE':
        return {
          ...state,
          ui: {
            ...state.ui,
            mousePosition: action.position
          }
        };

      case 'UI_SET_FOCUSED_VIEW':
        return {
          ...state,
          ui: { ...state.ui, focusedView: action.k }
        };

      case 'UI_MOVIE_MODE_TOGGLE':
        return {
          ...state,
          ui: {
            ...state.ui,
            movieMode: {
              ...state.ui.movieMode,
              active: !state.ui.movieMode.active
            }
          }
        };

      case 'UI_SET_FULLSCREEN':
        return {
          ...state,
          ui: { ...state.ui, fullscreen: action.fullscreen }
        };

      // Computation status updates
      case 'COMPUTATION_UPDATE_VIEW': {
        const { k, un, di, ch, it, workerInfo, boardType } = action;
        return {
          ...state,
          computation: {
            ...state.computation,
            views: {
              ...state.computation.views,
              [k]: { un, di, ch, it, workerInfo, boardType }
            }
          }
        };
      }

      default:
        return state;
    }
  }

  // Action creators (convenience methods)
  actions = {
    // Config actions
    initSizes: (sizes) => ({ type: 'CONFIG_INIT_SIZES', ...sizes }),
    setAspectRatio: (aspectRatio) => ({ type: 'CONFIG_SET_ASPECT_RATIO', aspectRatio }),
    setTheme: (theme) => ({ type: 'CONFIG_SET_THEME', theme }),
    setPixelRatio: (pixelRatio) => ({ type: 'CONFIG_SET_PIXEL_RATIO', pixelRatio }),
    setUnknownColor: (unknowncolor) => ({ type: 'CONFIG_SET_UNKNOWN_COLOR', unknowncolor }),
    updateConfig: (config) => ({ type: 'CONFIG_UPDATE', config }),

    // UI actions
    mouseDown: (button, position) => ({ type: 'UI_MOUSE_DOWN', button, position }),
    mouseUp: () => ({ type: 'UI_MOUSE_UP' }),
    mouseMove: (position) => ({ type: 'UI_MOUSE_MOVE', position }),
    setFocusedView: (k) => ({ type: 'UI_SET_FOCUSED_VIEW', k }),
    toggleMovieMode: () => ({ type: 'UI_MOVIE_MODE_TOGGLE' }),
    setFullscreen: (fullscreen) => ({ type: 'UI_SET_FULLSCREEN', fullscreen }),

    // Computation actions
    updateComputationView: (k, data) => ({
      type: 'COMPUTATION_UPDATE_VIEW',
      k,
      un: data.un,
      di: data.di,
      ch: data.ch,
      it: data.it,
      workerInfo: data.workerInfo,
      boardType: data.boardType
    })
  };
}

// Global configuration: display dimensions, palettes, and render settings.
class Config {
  // Constants for iteration and convergence
  static MAX_CHAOTIC_ITERATIONS = 100000;

  // Constants for display and zoom
  static DEFAULT_ZOOM_FACTOR = 5;
  static DEFAULT_ASPECT_RATIO = 1.0;
  static WIDESCREEN_ASPECT_RATIO = 16 / 9;
  static CENTER_COORDINATE = 0.5;

  // Feigenbaum / Myrberg point (real-axis accumulation point of period doubling)
  // OEIS A218453: 65-digit precision, parsed to quad-double (QD) format
  static get FEIGENBAUM_POINT_QD() {
    if (!this._FEIGENBAUM_POINT_QD) {
      this._FEIGENBAUM_POINT_QD = decimalToQD(
        '-1.4011551890920506005238267878938612922263080433973196089372614966');
    }
    return this._FEIGENBAUM_POINT_QD;
  }

  constructor(store) {
    this.store = store;

    // Initialize viewport width
    document.body.style.overflowY = 'scroll';
    const vw = document.documentElement.clientWidth || (window.innerWidth - 20);
    document.body.style.overflowY = '';

    // Calculate initial values
    const dgc = Math.min(2, Math.ceil(vw / 501));
    const pixelRatio = Math.max(Math.ceil(window.devicePixelRatio || 1), 2);
    const mobile = ('ontouchstart' in document.documentElement);
    const mac = (navigator.platform.indexOf('Mac') === 0);

    // Initialize state
    this.store.dispatch(this.store.actions.updateConfig({
      vw,
      gridcols: dgc,
      exponent: 2,
      enableGPU: true,
      enableInheritance: true,
      forceBoard: null,
      firstrQD: [-0.5, 0, 0, 0],
      firstjQD: [0.0, 0, 0, 0],
      firstsize: 3.0,
      pixelRatio,
      zoomfactor: Config.DEFAULT_ZOOM_FACTOR,
      aspectRatio: Config.DEFAULT_ASPECT_RATIO,
      theme: 'warm',
      unknowncolor: '#000',
      mobile,
      mac
    }));

    // Color palette options (not stored in state)
    this.unknownColorPalette = ["#000", "transparent", "#fff", "yellow", "red", "rgb(32,16,64)"];
    this.defineColorThemes();
  }

  // Read-only property getters (set once in constructor/URL or computed)
  get vw() { return this.store.getState().config.vw; }
  get cssDimsWidth() { return this.store.getState().config.cssDimsWidth; }
  get cssDimsHeight() { return this.store.getState().config.cssDimsHeight; }
  get dimsWidth() { return this.store.getState().config.dimsWidth; }
  get dimsHeight() { return this.store.getState().config.dimsHeight; }
  get zoomfactor() { return this.store.getState().config.zoomfactor; }
  get firstsize() { return this.store.getState().config.firstsize; }
  get mobile() { return this.store.getState().config.mobile; }
  get mac() { return this.store.getState().config.mac; }
  get exponent() { return this.store.getState().config.exponent; }
  get enableGPU() { return this.store.getState().config.enableGPU; }
  get enableInheritance() { return this.store.getState().config.enableInheritance; }
  get forceBoard() { return this.store.getState().config.forceBoard; }
  get debug() { return this.store.getState().config.debug; }

  // Check if a debug flag is set (supports both simple flags and key=value flags)
  // Examples: debug=m,x=foo,t  →  hasDebugFlag('m')=true, hasDebugFlag('x')=true
  hasDebugFlag(flag) {
    const debug = this.debug;
    if (!debug) return false;
    const parts = debug.split(',').map(f => f.trim());
    return parts.some(p => p === flag || p.startsWith(flag + '='));
  }

  // Get the value of a debug flag (returns null if not set or no value)
  // Examples: debug=m,x=foo,t  →  getDebugFlag('x')='foo', getDebugFlag('m')=null
  getDebugFlag(flag) {
    const debug = this.debug;
    if (!debug) return null;
    const parts = debug.split(',').map(f => f.trim());
    for (const part of parts) {
      if (part === flag) return null; // Flag exists but has no value
      if (part.startsWith(flag + '=')) {
        return part.substring(flag.length + 1);
      }
    }
    return null;
  }

  get firstrQD() { return this.store.getState().config.firstrQD; }
  get firstjQD() { return this.store.getState().config.firstjQD; }

  // Backward compatibility computed property
  get dimsArea() { return this.dimsWidth * this.dimsHeight; }

  // Writable properties - only these have runtime setter methods
  get gridcols() { return this.store.getState().config.gridcols; }
  setGridcols(value) {
    this.store.dispatch(this.store.actions.updateConfig({ gridcols: value }));
  }

  get pixelRatio() { return this.store.getState().config.pixelRatio; }
  setPixelRatio(value) {
    this.store.dispatch(this.store.actions.setPixelRatio(value));
  }

  get aspectRatio() { return this.store.getState().config.aspectRatio; }
  setAspectRatio(value) {
    this.store.dispatch(this.store.actions.setAspectRatio(value));
  }

  get theme() { return this.store.getState().config.theme; }
  setTheme(value) {
    this.store.dispatch(this.store.actions.setTheme(value));
  }

  get unknowncolor() { return this.store.getState().config.unknowncolor; }
  setUnknowncolor(value) {
    this.store.dispatch(this.store.actions.setUnknownColor(value));
  }

  defineColorThemes() {
    this.colorThemes = {
      warm: (i, frac, fracD, fracL, s) => {
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        let hue = (Math.log(i + 20) * 200) % 360;
        let chroma = 100;
        let light = 15 * frac + 85 * frac ** 5;
        return hclColor(hue, chroma, light);
      },
      neon: (i, frac, fracD, fracL, s) => {
        // Keep colors saturated - no desaturation to white at high iterations
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        // Use logarithmic scaling for iteration count to keep bands visible at high iterations
        let angle = (Math.log(i + 10) * 0.8) * Math.PI;

        // Generate three offset sine waves for RGB, keeping them always saturated
        // Add phase offsets to create color variety
        let r = Math.abs(Math.sin(angle));
        let g = Math.abs(Math.sin(angle + Math.PI * 2/3));
        let b = Math.abs(Math.sin(angle + Math.PI * 4/3));

        // Boost saturation by pushing down the minimum channel
        let minChannel = Math.min(r, g, b);
        r = Math.max(0, r - minChannel * 2/3);
        g = Math.max(0, g - minChannel * 2/3);
        b = Math.max(0, b - minChannel * 2/3);

        // Normalize so at least one channel is always at full brightness
        let maxChannel = Math.max(r, g, b);
        if (maxChannel > 0) {
          r /= maxChannel;
          g /= maxChannel;
          b /= maxChannel;
        }

        // Scale for neon glow - higher brightness for more saturation
        let brightness = 0.5 + 0.4 * frac;
        r = intcolor(r * brightness);
        g = intcolor(g * brightness);
        b = intcolor(b * brightness);

        return `rgb(${r},${g},${b})`;
      },
      iceblue: (i, frac, fracD, fracL, s) => {
        // Current implementation
        let ff = Math.pow(frac, 2);
        let fr = Math.pow(frac, 0.333);
        let fg = Math.pow(frac, 3);
        let g = intcolor(Math.max(fg, Math.min(fr, i * Math.pow(s, 0.33) / 64)));
        let r = intcolor(Math.min(fr, i * Math.pow(s, 0.22) / 64));
        let b = intcolor(ff / 3 + 0.667);
        return `rgb(${r},${g},${b})`;
      },
      tiedye: (i, frac, fracD, fracL, s) => {
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        let hue = (Math.log(i + 20) * 1000) % 360;
        let chroma = 100;
        let light = 25 * frac + 75 * frac ** 5;
        return hclColor(hue, chroma, light);
      },
      gray: (i, frac, fracD, fracL, s) => {
        frac = Math.max(frac, Math.min(0.99, fracD / (Math.max(1e-3, fracL))));
        let value = intcolor(0.15 + 0.85 * frac ** 5);
        return `rgb(${value},${value},${value})`;
      },
      // Add more color themes here
    };
    this.colorThemes.all = Object.keys(this.colorThemes);
  }

  initSizes() {
    let cssDims, cssDimsWidth, cssDimsHeight;

    // In fullscreen, use full window dimensions with no margins
    if (document.fullscreenElement) {
      const availWidth = window.innerWidth;
      const availHeight = window.innerHeight;

      // Directly set width and height to fill the viewport
      cssDimsWidth = availWidth;
      cssDimsHeight = availHeight;
      cssDims = cssDimsWidth;  // For compatibility
    } else {
      cssDims = Math.max(32, Math.floor((this.vw - 28) / this.gridcols) - 20);

      // Calculate width and height based on aspect ratio
      if (this.aspectRatio >= 1.0) {
        // Wider than tall
        cssDimsWidth = cssDims;
        cssDimsHeight = Math.floor(cssDims / this.aspectRatio);
      } else {
        // Taller than wide
        cssDimsHeight = cssDims;
        cssDimsWidth = Math.floor(cssDims * this.aspectRatio);
      }
    }

    const dimsWidth = Math.floor(cssDimsWidth * this.pixelRatio);
    const dimsHeight = Math.floor(cssDimsHeight * this.pixelRatio);

    // Calculate firstsize to ensure we fit width extent of 3 and height extent of 2.5
    // Width constraint: size must be at least 3.0
    // Height constraint: size / aspectRatio must be at least 2.5, so size >= 2.5 * aspectRatio
    const firstsize = Math.max(3.0, 2.5 * this.aspectRatio);

    // Dispatch all updates at once
    this.store.dispatch(this.store.actions.initSizes({
      vw: this.vw,
      gridcols: this.gridcols,
      cssDims,
      cssDimsWidth,
      cssDimsHeight,
      dimsWidth,
      dimsHeight,
      pixelRatio: this.pixelRatio,
      firstsize
    }));

    // Update DOM elements
    for (const el of document.querySelectorAll('.pixelratio')) {
      el.innerText = this.pixelRatio;
    }
    for (const el of document.querySelectorAll('#text')) {
      const minHelpWidth = 390;
      const helpColumns = Math.ceil((minHelpWidth + 36) / (cssDims + 20));
      // Columns plus margin minus padding
      el.style.maxWidth = `${(cssDims + 20) * helpColumns - 20 - 16}px`;
    }
  }

  updateExponent(newExponent) {
    if (newExponent < 2) { return; }
    // Bulk update exponent and initial center (origin for z^n, n>2)
    this.store.dispatch(this.store.actions.updateConfig({
      exponent: newExponent,
      firstrQD: [newExponent > 2 ? 0.0 : -0.5, 0, 0, 0],
      firstjQD: [0.0, 0, 0, 0]
    }));
    for (const el of document.querySelectorAll('.exponent')) {
      el.innerText = newExponent;
    }
  }

  firststate() {
    return {sizes:[[this.firstsize, this.firstrQD, this.firstjQD]], hidden:[]};
  }
}

// Rendering layer that draws computed pixel data to canvas.
class View {
  constructor(k, size, re, im, config, id, grid = null) {
    this.k = k;
    this.id = id;
    this.config = config;
    this.grid = grid;
    this.convergedData = new Map();

    // Multi-resolution compositing
    this.parentView = null;
    this.childView = null;

    this.initview(size, re, im);
    this.workerInfo = 'no worker';
    this.boardType = null;

    // Store exponent at creation time - views computed with different exponent are incompatible
    this.exponent = config.exponent;
  }

  // Getter properties that derive from sizesQD (the authoritative source)
  // sizesQD format: [sizeDouble, reQD, imQD]
  get size() { return this.sizesQD[0]; }
  get re() { return this.sizesQD[1]; }
  get im() { return this.sizesQD[2]; }

  // Derived scalar properties
  get pixelSize() { return this.size / this.config.dimsWidth; }
  get zoomFactor() { return this.config.firstsize / this.size; }

  // Static helper: lookup histogram fractions for a given iteration count
  static lookupHistogram(i, histogram) {
    let j = 0;
    for (; j < histogram.length - 1 && i < histogram[j][0]; j += 1) {}
    // Clamp to last valid index if iteration exceeds histogram range
    j = Math.min(j, histogram.length - 1);
    const [, uFrac, dFrac, lFrac] = histogram[j];
    return {
      fracK: 1 - uFrac,  // Fraction known
      fracD: 1 - dFrac,  // Fraction diverged
      fracL: 1 - lFrac   // Estimated limit on fracD
    };
  }

  initview(size, re, im) {
    // Store size as double (sufficient for scaling), coordinates as QD
    this.sizesQD = [typeof size === 'number' ? size : qdToNumber(size), toQD(re), toQD(im)];
    this.nn = new Array(this.config.dimsArea).fill(0);
    this.un = this.config.dimsArea;
    this.di = 0;
    this.ch = 0;
    this.it = 0;
    this.hi = [[0, 1, 1, 0]];
    this.convergedData.clear();
    this.boardStartTime = Date.now();
    this.boardEndTime = null;
  }

  setParentView(parentView) {
    // Clear old parent's reference to us
    if (this.parentView && this.parentView.childView === this) {
      this.parentView.childView = null;
    }
    this.parentView = parentView;
    if (parentView) {
      // Clear old child reference before setting new one
      if (parentView.childView && parentView.childView !== this) {
        parentView.childView.parentView = null;
      }
      parentView.childView = this;
    }
  }

  updateFromWorkerResult(data) {
    const { changeList, un, di, ch, it, workerInfo, boardType, compactionCount, activeCount } = data;
    const changedIndices = [];

    for (const { nn, vv, iter } of changeList) {
      // nn and vv contain both GPU-computed and precomputed pixels (merged in GpuBoard)
      for (const index of nn) {
        this.nn[index] = iter;
        changedIndices.push(index);
      }
      for (const entry of vv) {
        const { index, z, p } = entry;
        this.nn[index] = -iter;
        this.convergedData.set(index, { z: toQDc(z), p });  // Normalize to QDc format
        changedIndices.push(index);
      }
      this.di += nn.length;
      this.un -= nn.length + vv.length;
      this.updateHistogram(this.un, this.di, iter);
    }
    this.un = un;
    this.di = di;
    this.ch = ch;
    this.it = it;
    this.workerInfo = workerInfo;
    if (boardType) {
      this.boardType = boardType;
    }
    if (compactionCount !== undefined) {
      this.compactionCount = compactionCount;
    }
    if (activeCount !== undefined) {
      this.activeCount = activeCount;
    }
    // Freeze stats timing when board completes (unfinished() === 0 means done)
    if (this.unfinished() === 0 && !this.boardEndTime) {
      this.boardEndTime = Date.now();
    }

    // Propagate updates to child view
    if (this.childView && changedIndices.length > 0) {
      this.updateChildPixels(changedIndices);
    }
  }

  updateChildPixels(parentIndices) {
    // No-op: child computes its own pixels, no need for parent updates
  }

  currentc(j) {
    const { dimsWidth, dimsHeight, aspectRatio } = this.config;
    const x = j % dimsWidth;
    const y = Math.floor(j / dimsWidth);
    const rFrac = (x / dimsWidth) - Config.CENTER_COORDINATE;
    const jFrac = Config.CENTER_COORDINATE - (y / dimsHeight);
    // Use QD precision for scaling to preserve accuracy at deep zoom
    const rQD = toQDAdd(this.re, toQDScale(this.size, rFrac));
    const iQD = toQDAdd(this.im, toQDScale(this.size, jFrac / aspectRatio));
    // Return QD complex format (8 elements: 4 real + 4 imaginary) for full precision
    return [rQD[0], rQD[1], rQD[2], rQD[3], iQD[0], iQD[1], iQD[2], iQD[3]];
  }

  currentz(j) {
    const data = this.convergedData.get(j);
    return data ? data.z : null;
  }

  currentp(j) {
    const data = this.convergedData.get(j);
    return data ? data.p : null;
  }

  updateHistogram(un, di, i) {
    if (this.hi[0][1] - un / this.config.dimsArea >= 1 / 256) {  // Histogram resolution
      const uFrac = un / this.config.dimsArea;
      const dFrac = 1 - di / this.config.dimsArea;
      this.hi.unshift([i, uFrac, dFrac, 0]);
      if (this.hi.length > 10) {
        // Estimate the limit of di as i goes to infinity.
        const sample = this.hi.slice(0, this.hi.length - 2).map(
           (e, i) => ({ x: e[0], y: e[2], weight: (e[0] - this.hi[i+1][0]) ** 4 })
        ).reverse();
        const estimate = Math.min(1, Math.max(0, estimateLimit(sample)));
        // Smooth the estimate.
        const avg = (estimate + this.hi[1][3] * 4) / 5;
        this.hi[0][3] = avg;
      }
    }
  }

  draw(ctx, colorview = null, unknownColor = 'transparent') {
    if (colorview === null) {
      colorview = this;
    }

    // Draw composite: parent pixels + local pixels
    if (this.parentView) {
      this.drawComposite(ctx, colorview, unknownColor);
    } else {
      // No parent, just draw normally
      this.drawLocal(ctx, colorview, unknownColor);
    }
  }

  drawLocal(ctx, colorview = null, unknownColor = 'transparent') {
    // Draw only locally computed pixels
    if (colorview === null) {
      colorview = this;
    }
    const n = this.nn;
    const msort = n.map((v, i) => i).sort((a, b) => n[a] - n[b]);
    let prev = null;
    for (let m of msort) {
      const x = m % this.config.dimsWidth;
      const y = (m - x) / this.config.dimsWidth;
      const cur = n[m];
      if (prev !== cur) {
        ctx.fillStyle = colorview.makecolor(cur, null, null, unknownColor);
        prev = cur;
      }
      ctx.fillRect(x, y, 1, 1);
    }
  }

  // Calculate coordinate mapping from parent to child canvas using QD precision
  calculateParentMapping() {
    const parent = this.parentView;
    const { dimsWidth, dimsHeight, aspectRatio } = this.config;

    const [childSizeQD, childCenterRQD, childCenterIQD] = this.sizesQD;
    const [parentSizeQD, parentCenterRQD, parentCenterIQD] = parent.sizesQD;

    const childSize = qdToNumber(childSizeQD);
    const parentSize = qdToNumber(parentSizeQD);
    const parentHeight = parentSize / aspectRatio;

    // sx = ((childCenterR - parentCenterR) + (parentSize - childSize)/2) / parentSize * dimsWidth
    const deltaR = toQDSub(childCenterRQD, parentCenterRQD);
    const deltaRNum = qdToNumber(deltaR);
    const sx = ((deltaRNum + (parentSize - childSize) / 2) / parentSize) * dimsWidth;

    // sy = (deltaI + (parentHeight - childHeight)/2) / parentHeight * dimsHeight
    const childHeight = childSize / aspectRatio;
    const deltaI = toQDSub(parentCenterIQD, childCenterIQD);
    const deltaINum = qdToNumber(deltaI);
    const sy = ((deltaINum + (parentHeight - childHeight) / 2) / parentHeight) * dimsHeight;

    const sw = (childSize / parentSize) * dimsWidth;
    const sh = (childSize / parentSize) * dimsHeight;

    return { sx, sy, sw, sh };
  }

  // Check if a parent pixel should be cleared (unknown or on boundary)
  shouldClearParentPixel(px, py, parentData, sx, sy, sw, sh) {
    const { dimsWidth, dimsHeight } = this.config;

    if (px < 0 || px >= dimsWidth || py < 0 || py >= dimsHeight) {
      return false;
    }

    const parentIdx = py * dimsWidth + px;
    const val = parentData[parentIdx];

    // Clear if unknown
    if (val === 0) return true;

    // Check for diverged/converged boundary
    const isDiverged = val > 0;
    const isConverged = val < 0;

    // Check 4-connected neighbors for opposite type
    const neighbors = [
      py > 0 ? parentData[(py - 1) * dimsWidth + px] : null,
      py < dimsHeight - 1 ? parentData[(py + 1) * dimsWidth + px] : null,
      px > 0 ? parentData[py * dimsWidth + (px - 1)] : null,
      px < dimsWidth - 1 ? parentData[py * dimsWidth + (px + 1)] : null,
    ];

    for (const n of neighbors) {
      if (n !== null && n !== 0) {
        if ((isDiverged && n < 0) || (isConverged && n > 0)) {
          return true;
        }
      }
    }
    return false;
  }

  drawComposite(ctx, colorview = null, unknownColor = 'transparent') {
    // Draw parent canvas scaled as background, then local pixels on top
    if (colorview === null) {
      colorview = this;
    }

    // Clear canvas
    ctx.clearRect(0, 0, this.config.dimsWidth, this.config.dimsHeight);

    // Draw scaled parent canvas as background, but inflate unknown parent pixels
    // to avoid showing fuzzy boundary pixels
    if (this.parentView && this.grid) {
      const parent = this.parentView;
      const parentCanvas = this.grid.canvas(parent.k);

      if (parentCanvas) {
        const { sx, sy, sw, sh } = this.calculateParentMapping();

        // Create a temporary canvas at 3x parent resolution for finer inflation control
        const upsample = 3;

        // Calculate source dimensions in parent pixels (integer + 2px padding)
        const srcW = Math.ceil(sw) + 2;
        const srcH = Math.ceil(sh) + 2;

        // Dest must be exactly 3x source for proper pixel alignment
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = srcW * upsample;
        tempCanvas.height = srcH * upsample;
        const tempCtx = tempCanvas.getContext('2d');

        // Draw parent region upsampled 3x (with 1px padding at parent resolution)
        tempCtx.drawImage(parentCanvas,
          Math.floor(sx) - 1, Math.floor(sy) - 1,
          srcW, srcH,
          0, 0, srcW * upsample, srcH * upsample);

        // Inflate unknown parent pixels and diverged/converged boundaries
        const parentData = parent.nn;
        for (let py = Math.floor(sy) - 1; py < Math.ceil(sy + sh) + 1; py++) {
          for (let px = Math.floor(sx) - 1; px < Math.ceil(sx + sw) + 1; px++) {
            if (this.shouldClearParentPixel(px, py, parentData, sx, sy, sw, sh)) {
              // Clear pixel and 1-pixel margin at upsampled resolution
              // Each parent pixel maps to a 3x3 block, plus 1px inflation = 5x5 area
              const tx = (px - Math.floor(sx) + 1) * upsample;
              const ty = (py - Math.floor(sy) + 1) * upsample;
              for (let dy = -1; dy < upsample + 1; dy++) {
                for (let dx = -1; dx < upsample + 1; dx++) {
                  tempCtx.clearRect(tx + dx, ty + dy, 1, 1);
                }
              }
            }
          }
        }

        // Draw the masked parent pixels scaled to child canvas (faded)
        // Account for fractional pixel offset within the temp canvas
        // sx, sy may be fractional (e.g., 10.3), so child's edge isn't at an integer parent pixel
        const fracX = sx - Math.floor(sx);  // Fractional part (e.g., 0.3)
        const fracY = sy - Math.floor(sy);
        const tempSrcX = upsample + fracX * upsample;  // e.g., 3 + 0.3*3 = 3.9
        const tempSrcY = upsample + fracY * upsample;

        ctx.globalAlpha = 0.5;  // 50% opacity for parent pixels
        ctx.drawImage(tempCanvas,
          tempSrcX, tempSrcY,
          (srcW - 2) * upsample, (srcH - 2) * upsample,
          0, 0, this.config.dimsWidth, this.config.dimsHeight);
        ctx.globalAlpha = 1.0;  // Restore full opacity
      }
    }

    // Draw local computed pixels on top (using child's palette)
    this.drawLocal(ctx, colorview, unknownColor);
  }

  clearcanvas(ctx) {
    // For views with parents, use composite drawing
    // For root views, just clear (div background shows through)
    if (this.parentView) {
      this.drawComposite(ctx);
    } else {
      ctx.clearRect(0, 0, this.config.dimsWidth, this.config.dimsHeight);
    }
  }

  drawchange(ctx, change) {
    if (change.nn.length) {
      // Draw diverged pixels - nn contains plain indices
      ctx.fillStyle = this.makecolor(change.iter);
      for (let m of change.nn) {
        const x = m % this.config.dimsWidth;
        const y = (m - x) / this.config.dimsWidth;
        ctx.fillRect(x, y, 1, 1);
      }
    }
    if (change.vv.length) {
      // Draw converged pixels - vv contains {index, r, i} objects
      ctx.fillStyle = this.makecolor(-change.iter);
      for (let v of change.vv) {
        const x = v.index % this.config.dimsWidth;
        const y = (v.index - x) / this.config.dimsWidth;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  }

  makecolor(i, histogram = null, scale = null, unknownColor = 'transparent') {
    if (i === 0) return unknownColor;  // Color for uncomputed pixels
    if (i < 0) return 'black';
    const hi = histogram || this.hi;
    const size = scale || this.size;
    const fracs = View.lookupHistogram(i, hi);
    return this.config.colorThemes[this.config.theme](
       i, fracs.fracK, fracs.fracD, fracs.fracL, size);
  }

  uninteresting() {
    // Boring: nothing computed, or done with less than 5 colors
    return this.di <= 0 || (this.unfinished() === 0 && this.hi.length <= 5);
  }

  unfinished() {
    // Chaotic points in the spike counted as finished after max iterations.
    const result = Math.max(0, this.un +
      (this.it < Config.MAX_CHAOTIC_ITERATIONS ? 0 : -this.ch));
    return result;
  }


  debugStatus() {
    const debugGraph = this.renderHiGraph(600, 300);
    const maxPeriod = this.convergedData.values().map(
        d => fibonacciPeriod(d.p)).reduce((a, b) => Math.max(a, b), 0);
    const maxEscape = this.nn.reduce((a, b) => Math.max(a, b), 0)
    this.nn.reduce((iMin, x, i, arr) => x < arr[iMin] ? i : iMin, 0);
    const boardName = this.boardType || 'Board';

    // Calculate performance metrics (freeze timing when board completes)
    const endTime = this.boardEndTime || Date.now();
    const elapsedSecs = (endTime - this.boardStartTime) / 1000;
    const finishedPixels = this.di + this.ch;
    const itersPerSec = elapsedSecs > 0 ? this.it / elapsedSecs : 0;
    const pixelsPerSec = elapsedSecs > 0 ? finishedPixels / elapsedSecs : 0;

    // Format rate: always show 3 significant digits, readable format
    const formatRate = (r) => {
      if (r === 0) return '0';
      if (r >= 1000) return formatLargeInt(Math.round(r));  // comma-formatted integers
      return r.toPrecision(3);  // handles 0.001 to 999, and scientific for very small/large
    };

    return `${formatRate(itersPerSec)} iter/s, ${formatRate(pixelsPerSec)} px/s (${elapsedSecs.toFixed(1)}s)\n` +
           `${boardName} ${this.id}:\n` +
           `${this.di} diverged, ${this.un} unfinished, ${this.ch} chaotic\n` +
           `max period ${maxPeriod}, max escape ${maxEscape}\n` +
           `${this.workerInfo}\n` +
           `<img src="${debugGraph}" style="width:300px;height:150px">`;
  }

  renderHiGraph(width, height) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    const hi = this.hi;
    const scale = [
      (y) => y / hi[Math.floor(hi.length / 8)][0] / 2,
      (y) => y,
      (y) => y,
      (y) => y,
    ];
    const barWidth = width / (hi.length * scale.length);

    // Background
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);

    // Draw bars
    const colors = ['blue', 'red', 'green', 'purple'];
    hi.forEach((row, i) => {
      row.forEach((value, j) => {
        const x = i * scale.length * barWidth + j * barWidth;
        const barHeight = scale[j](value) * (height - 20);
        ctx.fillStyle = colors[j];
        ctx.fillRect(x, height - barHeight - 10, barWidth, barHeight);
      });
    });

    // Draw x-axis
    ctx.strokeStyle = 'black';
    ctx.beginPath();
    ctx.moveTo(0, height - 10);
    ctx.lineTo(width, height - 10);
    ctx.stroke();

    // Add labels
    ctx.font = '20px Arial';
    ctx.shadowColor = 'white';
    ctx.shadowBlur = 8;
    ctx.fillStyle = 'red';
    ctx.fillText(`Undone: ${this.hi[0][1]}`, 5, 30);
    ctx.fillStyle = 'green';
    ctx.fillText(`Dark: ${this.hi[0][2]}`, 5, 60);
    ctx.fillStyle = 'purple';
    ctx.fillText(`Est: ${this.hi[0][3]}`, 5, 90);

    return canvas.toDataURL();
  }
}

// Map a pixel index to complex coordinates using the same convention as GPU/CPU compute.
function pixelToComplexCoords(centerRe, centerIm, size, dimsWidth, dimsHeight, x, y) {
  const pixelSize = size / dimsWidth;
  const xOffset = (x - dimsWidth / 2) * pixelSize;
  const yOffset = (dimsHeight / 2 - y) * pixelSize;
  return { re: centerRe + xOffset, im: centerIm + yOffset };
}

// Map complex coordinates to pixel-space coordinates for a view.
function complexToPixelCoords(centerRe, centerIm, size, dimsWidth, dimsHeight, re, im) {
  const pixelSize = size / dimsWidth;
  const px = (re - centerRe) / pixelSize + dimsWidth / 2;
  const py = dimsHeight / 2 - (im - centerIm) / pixelSize;
  return { px, py };
}

// Manages the array of views and their layout in the grid.
class Grid {
  constructor(config, store = null) {
    this.config = config;
    this.store = store;
    this.views = [];
    this.canvascount = 0;
    this.focusk = null;
    this.urlListeners = [];
    this.zoomListeners = [];
    this.scheduler = new Scheduler(this);
    // Stable views - only populated during an update process.
    // Holds union of views that can be reused if popstate fires mid-update.
    // Cleared to null when update completes (this.views is then the stable state).
    this.stableViews = null;
    this._mouseOverBoard = false;  // Track if mouse is over board views
  }

  makeView(k, size, re, im, deferComputation = false) {
    const id = k + Math.random();
    const view = new View(k, size, re, im, this.config, id, this);
    this.views[k] = view;

    // Set up parent-child relationship for multi-resolution compositing
    if (k > 0 && this.views[k - 1]) {
      view.setParentView(this.views[k - 1]);
    }

    if (!deferComputation) {
      this.scheduler.assignBoardToWorker(k, size, re, im, this.config, id);
    }
    return view;
  }

  startViewComputation(k) {
    // Start computation for a view (stage 3)
    const view = this.views[k];
    if (!view) return;

    // Compute inheritance from parent if enabled
    let inheritedData = null;
    if (this.config.enableInheritance && view.parentView) {
      inheritedData = this.computeInheritance(view.parentView, view);

      // Draw inherited pixels in pink for debugging
      if (this.config.debug && this.config.debug.includes('inherit')) {
        this.drawInheritedPixels(k, inheritedData);
      }
    }

    this.scheduler.assignBoardToWorker(
      k, view.size, view.re, view.im, this.config, view.id, inheritedData);
  }

  // Compute which pixels can be inherited from parent view.
  // Uses 3x3 neighbor uniformity check to ensure safe inheritance.
  computeInheritance(parentView, childView) {
    const parentWidth = this.config.dimsWidth;
    const parentHeight = this.config.dimsHeight;
    const childWidth = this.config.dimsWidth;
    const childHeight = this.config.dimsHeight;
    const emptyPacked = () => ({
      packed: true,
      dIndices: new Uint32Array(0),
      cIndices: new Uint32Array(0),
      cP: new Uint32Array(0),
      cZ: new Float64Array(0),
      zStride: 2,
      ranges: new Uint32Array(0),
      knownMask: new Uint8Array(0)
    });

    // Compute effective zoom factor between parent and child
    const zoomFactor = parentView.size / childView.size;

    // Disable inheritance if zoom factor is too large for 3x3 window safety
    // At >8x, a single parent pixel covers >64 child pixels, making the 9-neighbor
    // check statistically insufficient to guarantee safety.
    if (zoomFactor > 8) {
      console.warn(`Inheritance disabled: zoom factor ${zoomFactor.toFixed(1)}x exceeds safety limit of 8x`);
      return emptyPacked();
    }

    // Warn if zoom factor is large but allowed
    if (zoomFactor > 5) {
      console.warn(`Inheritance warning: zoom factor ${zoomFactor.toFixed(1)}x exceeds 5x, 3x3 window may be insufficient`);
    }

    // Get centers and sizes as doubles (first element of QD arrays)
    const childCenterRe = qdToNumber(childView.re);
    const childCenterIm = qdToNumber(childView.im);
    const childPixelSize = childView.size / childWidth;

    const parentCenterRe = qdToNumber(parentView.re);
    const parentCenterIm = qdToNumber(parentView.im);
    const parentPixelSize = parentView.size / parentWidth;

    const uniformCache = new Int8Array(parentWidth * parentHeight);
    const childXStart = new Int32Array(parentWidth).fill(-1);
    const childXEnd = new Int32Array(parentWidth).fill(-1);
    const childYStart = new Int32Array(parentHeight).fill(-1);
    const childYEnd = new Int32Array(parentHeight).fill(-1);

    const scale = childPixelSize / parentPixelSize;
    const xBase = (childCenterRe - parentCenterRe) / parentPixelSize +
      parentWidth / 2 - (childWidth / 2) * scale;
    const yBase = parentHeight / 2 - (childCenterIm - parentCenterIm) / parentPixelSize -
      (childHeight / 2) * scale;
    for (let cx = 0; cx < childWidth; cx++) {
      const px = Math.floor(xBase + cx * scale);
      if (px >= 0 && px < parentWidth) {
        if (childXStart[px] === -1) childXStart[px] = cx;
        childXEnd[px] = cx;
      }
    }
    for (let cy = 0; cy < childHeight; cy++) {
      const py = Math.floor(yBase + cy * scale);
      if (py >= 0 && py < parentHeight) {
        if (childYStart[py] === -1) childYStart[py] = cy;
        childYEnd[py] = cy;
      }
    }

    const corners = [
      pixelToComplexCoords(childCenterRe, childCenterIm, childView.size, childWidth, childHeight, 0, 0),
      pixelToComplexCoords(childCenterRe, childCenterIm, childView.size, childWidth, childHeight, childWidth - 1, 0),
      pixelToComplexCoords(childCenterRe, childCenterIm, childView.size, childWidth, childHeight, 0, childHeight - 1),
      pixelToComplexCoords(childCenterRe, childCenterIm, childView.size, childWidth, childHeight, childWidth - 1, childHeight - 1)
    ];
    let minPxFloat = Infinity;
    let maxPxFloat = -Infinity;
    let minPyFloat = Infinity;
    let maxPyFloat = -Infinity;
    for (const corner of corners) {
      const parentCoord = complexToPixelCoords(
        parentCenterRe, parentCenterIm, parentView.size, parentWidth, parentHeight,
        corner.re, corner.im);
      minPxFloat = Math.min(minPxFloat, parentCoord.px);
      maxPxFloat = Math.max(maxPxFloat, parentCoord.px);
      minPyFloat = Math.min(minPyFloat, parentCoord.py);
      maxPyFloat = Math.max(maxPyFloat, parentCoord.py);
    }
    const minPx = Math.max(1, Math.floor(minPxFloat));
    const maxPx = Math.min(parentWidth - 2, Math.floor(maxPxFloat));
    const minPy = Math.max(1, Math.floor(minPyFloat));
    const maxPy = Math.min(parentHeight - 2, Math.floor(maxPyFloat));

    const rangeMinPx = Math.max(0, minPx - 1);
    const rangeMaxPx = Math.min(parentWidth - 1, maxPx + 1);
    const rangeMinPy = Math.max(0, minPy - 1);
    const rangeMaxPy = Math.min(parentHeight - 1, maxPy + 1);
    const keyMap = new Int32Array(parentWidth * parentHeight);
    const runMap = new Uint8Array(parentWidth * parentHeight);

    for (let py = rangeMinPy; py <= rangeMaxPy; py++) {
      for (let px = rangeMinPx; px <= rangeMaxPx; px++) {
        const parentIdx = py * parentWidth + px;
        const parentIter = parentView.nn[parentIdx];
        if (parentIter === 0) continue;
        if (parentIter > 0) {
          keyMap[parentIdx] = parentIter;
          continue;
        }
        const centerConverged = parentView.convergedData.get(parentIdx);
        if (!centerConverged) continue;
        keyMap[parentIdx] = -fibonacciPeriod(centerConverged.p);
      }
    }

    for (let py = rangeMinPy; py <= rangeMaxPy; py++) {
      for (let px = rangeMaxPx; px >= rangeMinPx; px--) {
        const idx = py * parentWidth + px;
        const key = keyMap[idx];
        if (key === 0) {
          runMap[idx] = 0;
          continue;
        }
        if (px === rangeMaxPx) {
          runMap[idx] = 1;
          continue;
        }
        const rightIdx = idx + 1;
        if (keyMap[rightIdx] === key) {
          runMap[idx] = Math.min(3, runMap[rightIdx] + 1);
        } else {
          runMap[idx] = 1;
        }
      }
    }

    for (let py = minPy; py <= maxPy; py++) {
      for (let px = minPx; px <= maxPx; px++) {
        const parentIdx = py * parentWidth + px;
        const key = keyMap[parentIdx];
        if (key === 0) {
          uniformCache[parentIdx] = -1;
          continue;
        }
        let uniform = true;
        for (let dy = -1; dy <= 1 && uniform; dy++) {
          const rowIdx = (py + dy) * parentWidth + (px - 1);
          if (keyMap[rowIdx] !== key || runMap[rowIdx] < 3) {
            uniform = false;
          }
        }
        uniformCache[parentIdx] = uniform ? 1 : -1;
      }
    }

    const iterCounts = new Map();
    let totalDiverged = 0;
    let totalConverged = 0;
    let zStride = 2;
    let zStrideSet = false;

    for (let py = minPy; py <= maxPy; py++) {
      const cyStart = childYStart[py];
      if (cyStart === -1) continue;
      const cyEnd = childYEnd[py];
      const yCount = cyEnd - cyStart + 1;
      for (let px = minPx; px <= maxPx; px++) {
        const cxStart = childXStart[px];
        if (cxStart === -1) continue;
        if (uniformCache[py * parentWidth + px] !== 1) continue;

        const parentIdx = py * parentWidth + px;
        const parentIter = parentView.nn[parentIdx];
        if (parentIter === 0) continue;
        const cxEnd = childXEnd[px];
        const count = (cxEnd - cxStart + 1) * yCount;
        if (parentIter > 0) {
          const entry = iterCounts.get(parentIter) || { dCount: 0, cCount: 0 };
          entry.dCount += count;
          iterCounts.set(parentIter, entry);
          totalDiverged += count;
        } else {
          const centerConverged = parentView.convergedData.get(parentIdx);
          if (!centerConverged) continue;
          if (!zStrideSet && centerConverged.z && centerConverged.z.length > 2) {
            zStride = centerConverged.z.length;
            zStrideSet = true;
          }
          const iterKey = -parentIter;
          const entry = iterCounts.get(iterKey) || { dCount: 0, cCount: 0 };
          entry.cCount += count;
          iterCounts.set(iterKey, entry);
          totalConverged += count;
        }
      }
    }

    const totalInherited = totalDiverged + totalConverged;
    if (totalInherited === 0) {
      return emptyPacked();
    }
    const dIndices = new Uint32Array(totalDiverged);
    const cIndices = new Uint32Array(totalConverged);
    const cP = new Uint32Array(totalConverged);
    const cZ = new Float64Array(totalConverged * zStride);
    const knownMask = new Uint8Array(childWidth * childHeight);
    const iterEntries = Array.from(iterCounts.entries()).sort((a, b) => a[0] - b[0]);
    const ranges = new Uint32Array(iterEntries.length * 5);
    const iterWrite = new Map();
    let dOffset = 0;
    let cOffset = 0;
    for (let i = 0; i < iterEntries.length; i++) {
      const [iter, counts] = iterEntries[i];
      const dStart = dOffset;
      const cStart = cOffset;
      ranges[i * 5] = iter;
      ranges[i * 5 + 1] = dStart;
      ranges[i * 5 + 2] = counts.dCount;
      ranges[i * 5 + 3] = cStart;
      ranges[i * 5 + 4] = counts.cCount;
      iterWrite.set(iter, { dWrite: dStart, cWrite: cStart });
      dOffset += counts.dCount;
      cOffset += counts.cCount;
    }

    for (let py = minPy; py <= maxPy; py++) {
      const cyStart = childYStart[py];
      if (cyStart === -1) continue;
      const cyEnd = childYEnd[py];
      for (let px = minPx; px <= maxPx; px++) {
        const cxStart = childXStart[px];
        if (cxStart === -1) continue;
        if (uniformCache[py * parentWidth + px] !== 1) continue;

        const parentIdx = py * parentWidth + px;
        const parentIter = parentView.nn[parentIdx];
        if (parentIter === 0) continue;
        const isConverged = parentIter < 0;
        const centerConverged = isConverged ?
          parentView.convergedData.get(parentIdx) : null;
        if (isConverged && !centerConverged) continue;
        const cxEnd = childXEnd[px];

        if (parentIter > 0) {
          const writer = iterWrite.get(parentIter);
          let dWrite = writer.dWrite;
          for (let cy = cyStart; cy <= cyEnd; cy++) {
            const rowBase = cy * childWidth;
            for (let cx = cxStart; cx <= cxEnd; cx++) {
              const childIdx = rowBase + cx;
              dIndices[dWrite++] = childIdx;
              knownMask[childIdx] = 1;
            }
          }
          writer.dWrite = dWrite;
        } else {
          const iterKey = -parentIter;
          const writer = iterWrite.get(iterKey);
          let cWrite = writer.cWrite;
          const z = centerConverged.z || [];
          const zLen = Math.min(zStride, z.length);
          for (let cy = cyStart; cy <= cyEnd; cy++) {
            const rowBase = cy * childWidth;
            for (let cx = cxStart; cx <= cxEnd; cx++) {
              const childIdx = rowBase + cx;
              cIndices[cWrite] = childIdx;
              cP[cWrite] = centerConverged.p;
              const zOffset = cWrite * zStride;
              for (let k = 0; k < zLen; k++) {
                cZ[zOffset + k] = z[k];
              }
              knownMask[childIdx] = 1;
              cWrite++;
            }
          }
          writer.cWrite = cWrite;
        }
      }
    }

    // Log inheritance stats if debug flag set
    if (this.config.debug && this.config.debug.includes('inherit')) {
      const total = childWidth * childHeight;
      console.log(`Inheritance: ${totalInherited}/${total} pixels (${(100 * totalInherited / total).toFixed(1)}%) from parent view ${parentView.k} to child view ${childView.k}`);
    }

    return {
      packed: true,
      dIndices,
      cIndices,
      cP,
      cZ,
      zStride,
      ranges,
      knownMask
    };
  }

  removeView(k) {
    this.views[k] = null;
    let i = this.views.length - 1;
    for (i = this.views.length - 1; i >= 0; i -= 1) {
      if (this.views[i] !== null) { break; }
    }
    this.views.length = i + 1;
    this.scheduler.removeBoardFromWorker(k);
  }

  setFocusedView(k) {
    if (k !== this.focusk) {
      this.focusk = k;
      this.scheduler.setFocusedBoard(k);
    }
  }

  getHiddenViews() {
    return this.views.map((v, i) =>
            this.hiddencanvas(i) ? i : -1).filter(i => i !== -1);
  }

  updateHiddenViews() {
    this.scheduler.setHiddenBoards(this.getHiddenViews());
  }

  updateViewFromWorkerResult(k, data, workerIndex) {
    // First check current views
    if (this.views[k]) {
      if (this.views[k].id !== data.id) {
        return;
      }
      this.views[k].updateFromWorkerResult(data);
      this.updateCanvas(k, data);

      // Update state with computation status
      if (this.store) {
        this.store.dispatch(
          this.store.actions.updateComputationView(k, {
            un: data.un,
            di: data.di,
            ch: data.ch,
            it: data.it,
            workerInfo: data.workerInfo,
            boardType: data.boardType
          })
        );
      }
      return;
    }

    // If not in current views, check stableViews (may be mid-update)
    // This ensures we don't lose messages during updateLayout transitions
    if (this.stableViews) {
      for (const view of this.stableViews) {
        if (view && view.id === data.id) {
          view.updateFromWorkerResult(data);
          return;
        }
      }
    }
  }

  updateCanvas(k, data) {
    const canvas = this.canvas(k);
    if (canvas && data.changeList.length) {
      const ctx = canvas.getContext('2d');
      for (let change of data.changeList) {
        this.views[k].drawchange(ctx, change);
      }
    }
  }

  // Draw inherited pixels in pink/magenta for debugging (when debug=inherit)
  drawInheritedPixels(k, inheritedData) {
    if (!inheritedData) return;
    const canvas = this.canvas(k);
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const width = this.config.dimsWidth;
    const pixelRatio = this.config.pixelRatio || 1;

    if (inheritedData.packed) {
      // Draw diverged pixels in hot pink
      ctx.fillStyle = '#ff69b4';
      for (let i = 0; i < inheritedData.dIndices.length; i++) {
        const idx = inheritedData.dIndices[i];
        const x = idx % width;
        const y = Math.floor(idx / width);
        ctx.fillRect(x * pixelRatio, y * pixelRatio, pixelRatio, pixelRatio);
      }

      // Draw converged pixels in magenta (slightly different shade)
      ctx.fillStyle = '#ff00ff';
      for (let i = 0; i < inheritedData.cIndices.length; i++) {
        const idx = inheritedData.cIndices[i];
        const x = idx % width;
        const y = Math.floor(idx / width);
        ctx.fillRect(x * pixelRatio, y * pixelRatio, pixelRatio, pixelRatio);
      }
      return;
    }

    // Draw diverged pixels in hot pink
    ctx.fillStyle = '#ff69b4';
    for (const item of inheritedData.diverged) {
      const x = item.index % width;
      const y = Math.floor(item.index / width);
      ctx.fillRect(x * pixelRatio, y * pixelRatio, pixelRatio, pixelRatio);
    }

    // Draw converged pixels in magenta (slightly different shade)
    ctx.fillStyle = '#ff00ff';
    for (const item of inheritedData.converged) {
      const x = item.index % width;
      const y = Math.floor(item.index / width);
      ctx.fillRect(x * pixelRatio, y * pixelRatio, pixelRatio, pixelRatio);
    }
  }

  currentGridState() {
    let state = { hidden: [], sizes: [] };
    for (let k = 0; k < this.views.length; k++) {
      if (this.hiddencanvas(k)) {
        state.hidden.push(k);
      }
      // State format: [sizeScalar, reQD, imQD] for backward compatibility
      state.sizes.push([this.views[k].size, this.views[k].re, this.views[k].im]);
    }
    return state;
  }

  updateLayout(state = null, skipInitSizes = false) {
    // Abort any current update process and preserve its target state
    if (this.currentUpdateProcess) {
      if (!state) {
        state = this.currentUpdateProcess.targetState;
      }
      this.currentUpdateProcess.abort();
    }

    // Use current state only if no state provided and no process to abort
    if (!state) {
      state = this.currentGridState();
    }

    // Recalculate dimensions unless explicitly skipped
    if (!skipInitSizes) {
      this.config.initSizes();
    }

    // Save current views to stableViews for potential reuse.
    // This does NOT remove boards from workers - they continue computing.
    // Boards will be cleaned up at end of update for any views not reused.
    this.saveViewsToStable();

    // Find views to preserve by coordinate matching
    const preservedViews = this.findPreservableViews(state.sizes);

    // Clear and recreate the grid DOM (views array already cleared by saveViewsToStable)
    const gridElement = document.getElementById('grid');
    gridElement.innerHTML = '';
    this.canvascount = 0;

    // Create canvases for all views in the state
    const {sizes, hidden} = state;
    for (let k = 0; k < sizes.length; k++) {
      this.makecanvas(k, sizes[k]);
      if (hidden.includes(k)) {
        this.hidecanvas(k);
      }
    }

    // Update workers with hidden boards BEFORE creating boards
    // to prevent hidden boards from computing
    this.updateHiddenViews();
    this.currentUpdateProcess = this.createUpdateProcess(state, preservedViews);
    this.currentUpdateProcess.start();
  }

  // Find views in stableViews that match target coordinates, dimensions, and exponent
  // Returns Map of targetIdx -> view
  findPreservableViews(targetSizes) {
    const preservedViews = new Map();
    const targetArea = this.config.dimsWidth * this.config.dimsHeight;
    const targetExponent = this.config.exponent;

    // Helper to check if a view matches target coordinates, dimensions, AND exponent
    const viewMatchesTarget = (view, targetSizes) => {
      if (!view || !view.sizesQD || !targetSizes) return false;

      // Check exponent matches (views computed with different exponent are incompatible)
      if (view.exponent !== targetExponent) return false;

      // Check dimensions match
      const viewArea = view.nn?.length || 0;
      if (viewArea !== targetArea) return false;

      const [viewSizeQD, viewReQD, viewImQD] = view.sizesQD;
      const viewSize = qdToNumber(viewSizeQD);
      const [targetSize, targetRe, targetIm] = targetSizes;

      // Check zoom level - must be within 0.1%
      const sizeRatio = targetSize / viewSize;
      if (sizeRatio < 0.999 || sizeRatio > 1.001) return false;

      // Check coordinates - tolerance is 0.01% of view extent
      // Use QD subtraction to avoid precision loss at deep zoom
      const tolerance = viewSize * 0.0001;
      const reDiff = Math.abs(qdToNumber(toQDSub(viewReQD, targetRe)));
      const imDiff = Math.abs(qdToNumber(toQDSub(viewImQD, targetIm)));
      return reDiff < tolerance && imDiff < tolerance;
    };

    for (let targetIdx = 0; targetIdx < targetSizes.length; targetIdx++) {
      const targetSize = targetSizes[targetIdx];

      // Search stableViews for best match (most computed data)
      let bestView = null;
      let bestDi = -1;

      for (const view of (this.stableViews || [])) {
        if (!viewMatchesTarget(view, targetSize)) continue;
        if (view.di > bestDi) {
          bestDi = view.di;
          bestView = view;
        }
      }

      if (bestView) {
        preservedViews.set(targetIdx, bestView);
      }
    }

    return preservedViews;
  }

  createUpdateProcess(state, preservedViews) {
    let aborted = false;
    const usedViewIds = new Set();  // Track which stableView IDs were reused

    // Build list of indices that need new views (not preserved)
    const newViewIndices = [];
    for (let k = 0; k < state.sizes.length; k++) {
      if (!preservedViews.has(k)) {
        newViewIndices.push(k);
      }
    }

    // Function to place all preserved views immediately (called by start)
    const placePreservedViews = () => {
      for (let k = 0; k < state.sizes.length; k++) {
        const preserved = preservedViews.get(k);
        if (preserved) {
          usedViewIds.add(preserved.id);
          const oldK = preserved.k;
          preserved.k = k;
          this.views[k] = preserved;

          // Only need to update scheduler if the index changed
          if (oldK !== k) {
            this.scheduler.removeBoardFromWorker(oldK);
            this.scheduler.assignBoardToWorker(
              k, preserved.size, preserved.re, preserved.im,
              this.config, preserved.id);
          }

          // Set up parent-child relationship (view 0 has no parent)
          if (k > 0 && this.views[k - 1]) {
            preserved.setParentView(this.views[k - 1]);
          } else if (k === 0) {
            preserved.setParentView(null);
          }

          // Draw the preserved view to the canvas immediately
          this.views[k].draw(this.canvas(k).getContext('2d'));

          if (state.hidden.indexOf(k) >= 0) {
            this.hidecanvas(k);
          }
        }
      }
    };

    // Now process new views with 50ms delays
    let newViewIndex = 0;

    const processNextNew = () => {
      if (aborted) {
        return;
      }
      if (newViewIndex >= newViewIndices.length) {
        // All done
        this.notifyurl();
        this.notifyzoom();
        this.updateHiddenViews();
        this.cleanupUnusedStableViews(usedViewIds);
        this.currentUpdateProcess = null;
        return;
      }

      const k = newViewIndices[newViewIndex];
      this.views[k] = this.makeView(k, state.sizes[k][0], state.sizes[k][1], state.sizes[k][2], true);
      this.views[k].draw(this.canvas(k).getContext('2d'));

      // Set up parent-child relationship for new view
      if (k > 0 && this.views[k - 1]) {
        this.views[k].setParentView(this.views[k - 1]);
      }

      // Start computation with inheritance from parent
      this.startViewComputation(k);

      if (state.hidden.indexOf(k) >= 0) {
        this.hidecanvas(k);
      }
      this.updateFullscreenButton();
      newViewIndex++;
      // Use shorter delay with debug=fastload for tests
      const delay = this.config.debug?.includes('fastload') ? 0 : 200;
      setTimeout(processNextNew, delay);
    };

    return {
      targetState: state,
      start: () => {
        // Place preserved views immediately (synchronously) on start
        placePreservedViews();
        this.updateFullscreenButton();
        if (newViewIndices.length === 0) {
          // No new views, finish immediately
          this.notifyurl();
          this.notifyzoom();
          this.updateHiddenViews();
          this.cleanupUnusedStableViews(usedViewIds);
          this.currentUpdateProcess = null;
        } else {
          processNextNew();
        }
      },
      abort: () => { aborted = true; }
    };
  }

  makecanvas(k, sizeInfo = null) {
    let gd = document.getElementById('grid');
    while (this.canvascount <= k) {
      let dd = document.createElement('div');
      dd.id = `b_${this.canvascount}`;
      dd.innerHTML = this.canvasstring(this.canvascount, sizeInfo);
      dd.className = 'hidemarks';
      dd.style.backgroundColor = this.config.unknowncolor;
      gd.appendChild(dd);
      this.canvascount += 1;
    }
  }

  canvasstring(k, sizeInfo = null) {
    // Use firstsize (which varies with aspect ratio) for display consistency
    let viewSize;
    if (k < this.views.length) {
      viewSize = this.views[k].size;
    } else if (sizeInfo && sizeInfo[0] !== null) {
      viewSize = sizeInfo[0];
    } else {
      viewSize = this.config.firstsize / Math.pow(this.config.zoomfactor, k);
    }
    let factor = this.config.firstsize / viewSize;
    factor = formatScale(factor);
    const w = this.config.dimsWidth;
    const h = this.config.dimsHeight;
    const cssW = this.config.cssDimsWidth;
    const cssH = this.config.cssDimsHeight;
    return `<canvas width="${w}" height="${h}" ` +
           `style="height:${cssH}px;width:${cssW}px;">` +
           `</canvas><div class="closebox"></div><div class="rect"></div>` +
           `<canvas class=overlay width=${w} height="${h}" ` +
           `style="height:${cssH}px;width:${cssW}px;">` +
           `</canvas><a class="zoomnum" target="_blank" href="?">${factor}` +
           `<div class="status"></div></a>`;
  }

  // Get the container element for a view
  container(k) {
    return document.getElementById(`b_${k}`);
  }

  canvas(k) {
    return this.container(k)?.firstElementChild;
  }

  rect(k) {
    return this.container(k)?.firstElementChild?.nextElementSibling?.nextElementSibling;
  }

  overlay(k) {
    const container = this.container(k);
    return container?.firstElementChild?.nextElementSibling
      ?.nextElementSibling?.nextElementSibling;
  }

  hidecanvas(k) {
    const container = this.container(k);
    if (container) {
      container.style.display = 'none';
    }
  }

  showcanvas(k) {
    const container = this.container(k);
    if (container) {
      container.style.display = '';
    }
  }

  hiddencanvas(k) {
    const container = this.container(k);
    return container?.style.display === 'none';
  }

  grid() {
    return document.getElementById('grid');
  }

  truncateviews(k) {
    while (this.views.length > k) {
      let removeIndex = this.views.length - 1;
      this.removeView(removeIndex);
    }
    while (this.canvascount > k) {
      let removeIndex = this.canvascount - 1;
      this.canvas(removeIndex)?.parentElement?.remove();
      this.canvascount -= 1;
    }
  }

  // Save current views to stableViews for potential reuse during navigation.
  // Unlike truncateviews, this does NOT remove boards from workers - they continue
  // computing (or stay paused if hidden). The boards will be cleaned up later
  // when stableViews is discarded.
  saveViewsToStable() {
    const viewsToSave = new Map();
    // Add existing stableViews first
    for (const view of (this.stableViews || [])) {
      if (view) viewsToSave.set(view.id, view);
    }
    // Add current views (may overlap with stableViews)
    for (const view of this.views) {
      if (view) viewsToSave.set(view.id, view);
    }
    this.stableViews = Array.from(viewsToSave.values());
    // Clear views array without removing boards
    this.views = [];
  }

  // Clean up boards for stableViews that weren't reused.
  // Called at the end of a successful update.
  cleanupUnusedStableViews(usedViewIds) {
    if (!this.stableViews) return;
    for (const view of this.stableViews) {
      if (view && !usedViewIds.has(view.id)) {
        // This view wasn't reused - remove its board from the worker.
        // Pass the view's ID so we only remove if the board at that index
        // still belongs to this view (not a new board created in its place).
        this.scheduler.removeBoardFromWorker(view.k, view.id);
      }
    }
    this.stableViews = null;

    // Debug check: verify no orphan boards remain after cleanup
    this.scheduler.checkForOrphanBoards(this.views);
  }

  showAllViews() {
    for (let j = 0; j < this.canvascount; ++j) {
      this.showcanvas(j);
    }
    this.notifyzoom();
  }

  truncatehiddenviews() {
    let j = this.canvascount - 1;
    for (; j > 0; j--) {
      if (!this.hiddencanvas(j)) {
        break;
      }
    }
    this.truncateviews(j + 1);
    if (j === 0) {
      this.showcanvas(j);
    }
  }

  updateProgress(overtarget, k) {
    if (overtarget.tagName === 'A' && overtarget.classList.contains('zoomnum')) {
      if (this.config.mobile) {
        overtarget.removeAttribute('href');
      } else {
        overtarget.href = this.bigurl(k, overtarget.showDebug);
      }

      let statusDiv = overtarget.querySelector('.status');
      if (!statusDiv) return;

      if (!overtarget.matches(':hover')) {
        // Clear text and reset alignment after animation transition
        setTimeout(() => {
          statusDiv.textContent = '';
          statusDiv.classList.remove('align-left');
          statusDiv.style.left = '';
        }, 300);
        return;
      }

      // Regular status
      // Use unfinished() for percentage (accounts for chaotic pixels after max iterations)
      const unfinishedCount = this.views[k].unfinished();
      let percentDone = Math.floor(1000 * (1.0 - unfinishedCount / this.config.dimsArea))/10.0;
      // Cap at 99.9% until truly complete to avoid showing 100% while still computing
      if (unfinishedCount > 0 && percentDone >= 99.9) {
        percentDone = 99.9;
      }
      // Use QD precision coordinates when available to preserve full precision in status
      const coords = formatcomplex(k, this.views[k].re, this.views[k].im)
        .replaceAll('-', '\u2212');
      const iters = formatLargeInt(this.views[k].it);
      const regularStatus = `${MSG.center_at_}${coords}\n${percentDone}` +
                             `${MSG.percent_done_after_}${iters}${MSG.iters}`;
      statusDiv.textContent = regularStatus;

      // Debug status
      if (overtarget.showDebug) {
        statusDiv.innerHTML += `\n${this.views[k].debugStatus()}`;
      }

      // Reposition popup if it would go off the left edge of the screen
      // Only check once (when not already aligned) to avoid flickering
      if (!statusDiv.classList.contains('align-left')) {
        const rect = statusDiv.getBoundingClientRect();
        if (rect.left < 0) {
          // Align with viewport left edge: calculate offset from zoomnum to viewport
          const zomnumRect = overtarget.getBoundingClientRect();
          statusDiv.classList.add('align-left');
          statusDiv.style.left = `${-zomnumRect.left}px`;
        }
      }

      setTimeout(() => this.updateProgress(overtarget, k), 100);
    }
  }

  bigurl(k, debug) {
    if (k >= this.views.length) return;
    const osize = this.views[k].size;
    const zoomFactor = this.config.firstsize / osize;  // Zoom factor (1.0 = default)
    const exponentParam = this.config.exponent !== 2 ?
      `&exponent=${this.config.exponent}` : '';
    const themeParam = this.config.theme !== 'warm' ? `&theme=${this.config.theme}` : '';
    const coords = formatcomplex(k, this.views[k].re, this.views[k].im);
    return `?z=${formatZoom(zoomFactor)}${exponentParam}&c=${coords}${themeParam}`;
  }

  clearseq(k) {
    const overlayElement = this.overlay(k);
    if (overlayElement) {
      let ctx = overlayElement.getContext('2d');
      ctx.clearRect(0, 0, this.config.dimsWidth, this.config.dimsHeight);
    }
  }

  onurlchange(callback) {
    this.urlListeners.push(callback);
  }

  notifyurl() {
    for (let cb of this.urlListeners) {
      cb();
    }
  }

  onzoomchange(callback) {
    this.zoomListeners.push(callback);
  }

  notifyzoom() {
    for (let cb of this.zoomListeners) {
      cb();
    }
  }

  updateFullscreenButton() {
    const button = document.getElementById('fullscreen-button');
    if (button && !document.fullscreenElement) {
      // Show button unless mouse is over a board view
      button.style.display = 'block';
      if (!this._mouseOverBoard) {
        button.style.opacity = '0.7';
      }
    }
  }

  setupFullscreenButtonHover() {
    const button = document.getElementById('fullscreen-button');
    const gridElement = document.getElementById('grid');
    if (!button || !gridElement) return;

    this._mouseOverBoard = false;

    // Check if button overlaps with any visible view
    const buttonOverlapsViews = () => {
      const btnRect = button.getBoundingClientRect();
      for (const child of gridElement.children) {
        if (child.style.display === 'none') continue;
        const viewRect = child.getBoundingClientRect();
        // Check for rectangle overlap
        if (btnRect.left < viewRect.right && btnRect.right > viewRect.left &&
            btnRect.top < viewRect.bottom && btnRect.bottom > viewRect.top) {
          return true;
        }
      }
      return false;
    };

    // Update button visibility based on mouse position and view overlap
    const updateButtonVisibility = () => {
      if (document.fullscreenElement) return;
      if (this._mouseOverBoard && buttonOverlapsViews()) {
        button.style.opacity = '0';
        button.style.pointerEvents = 'none';
      } else {
        button.style.opacity = '0.7';
        button.style.pointerEvents = '';
      }
    };

    // Fade out button when mouse enters grid AND button overlaps views
    gridElement.addEventListener('mouseenter', (e) => {
      this._mouseOverBoard = true;
      updateButtonVisibility();
    }, true);

    // Fade in button when mouse leaves the grid entirely
    gridElement.addEventListener('mouseleave', (e) => {
      this._mouseOverBoard = false;
      updateButtonVisibility();
    }, true);

    // Re-check on scroll in case views now overlap button
    window.addEventListener('scroll', updateButtonVisibility, { passive: true });
  }
}

// Draws zoom preview rectangles and handles zoom factor UI.
class ZoomManager {
  constructor(config, grid) {
    this.config = config;
    this.grid = grid;
    this.grid.onzoomchange(() => this.updateZoomRectangles());
  }

  showZoomRect(k, x, y, zf) {
    const s = this.grid.rect(k).style;
    const border = 1;
    let cssClass = '';
    if (zf > 50) {
      // Switch from rectangle to circle if the zoom area is tiny.
      zf = 25;
      cssClass = 'circle';
    }
    this.grid.rect(k).parentElement.className = cssClass;

    if (cssClass === 'circle') {
      // To make a circle, width and height must be equal.
      // We use the average of the would-be width and height for the diameter.
      const diameter = (this.config.cssDimsWidth + this.config.cssDimsHeight) / 2 / zf;
      s.width = `${diameter + 2 * border}px`;
      s.height = `${diameter + 2 * border}px`;
      s.left = `${x * this.config.cssDimsWidth - diameter / 2 - border}px`;
      s.top = `${y * this.config.cssDimsHeight - diameter / 2 - border}px`;
    } else {
      const rectWidth = this.config.cssDimsWidth / zf;
      const rectHeight = this.config.cssDimsHeight / zf;
      s.width = `${rectWidth + 2 * border}px`;
      s.height = `${rectHeight + 2 * border}px`;
      s.left = `${x * this.config.cssDimsWidth - rectWidth / 2 - border}px`;
      s.top = `${y * this.config.cssDimsHeight - rectHeight / 2 - border}px`;
    }
  }

  removeZoomRect(k) {
    let s = this.grid.rect(k).style;
    s.top = s.left = s.width = s.height = '';
    this.grid.rect(k).parentElement.className = 'hidemarks';
  }

  updateZoomRectangles() {
    let prevSizeQD = null, prevReQD = null, prevImQD = null;
    let prevK = 0;
    for (let k = 0; k < this.grid.views.length; k++) {
      if (this.grid.hiddencanvas(k)) { continue; }
      const view = this.grid.views[k];
      if (!view || !view.sizesQD) { continue; }
      const [currSizeQD, currReQD, currImQD] = view.sizesQD;
      if (prevSizeQD !== null) {
        const prevSize = qdToNumber(prevSizeQD);
        let x = qdToNumber(toQDSub(currReQD, prevReQD)) / prevSize + 0.5;
        let y = 0.5 - qdToNumber(toQDSub(currImQD, prevImQD)) /
          (prevSize / this.config.aspectRatio);

        let zf = prevSize / qdToNumber(currSizeQD);
        this.showZoomRect(prevK, x, y, zf);
      }
      prevSizeQD = currSizeQD;
      prevReQD = currReQD;
      prevImQD = currImQD;
      prevK = k;
    }
    if (prevSizeQD !== null) {
      this.removeZoomRect(prevK);
    }
  }

  zoomInAtCurrentPosition(hideCurrent) {
    let k = this.grid.views.length - 1;
    if (this.grid.views[k].uninteresting()) { return; }
    let osize = this.grid.views[k].size;
    let oreQD = this.grid.views[k].re;
    let oimQD = this.grid.views[k].im;
    let rre = Config.CENTER_COORDINATE;
    // Check if center is at (-0.5, 0) - use QD comparison
    if (k === 0 && qdEq(oreQD, -0.5) && qdEq(oimQD, 0)) {
      // Myreberg / Feigenbaum point
      const baseRe = this.grid.views[0].re;
      oreQD = Config.FEIGENBAUM_POINT_QD;
      rre = qdToNumber(toQDAdd(
        toQDScale(toQDSub(oreQD, baseRe), 1 / this.grid.views[0].size),
        Config.CENTER_COORDINATE
      ));
    }
    this.showZoomRect(k, rre, 0.5, this.config.zoomfactor);
    let nsize = osize / this.config.zoomfactor;

    // Stage 1: Create DOM and scroll immediately
    // Pass nsize to makecanvas so the zoom label shows correct scientific notation
    this.grid.makecanvas(k + 1, [nsize, null, null]);
    if (hideCurrent) {
      this.grid.canvas(k).parentElement.style.display = 'none';
      this.updateZoomRectangles();
      this.grid.updateHiddenViews();
    }
    this.grid.canvas(k + 1).parentElement.className = 'hidemarks';
    const canvas = this.grid.canvas(k + 1);
    canvas.parentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Force browser to render stage 1 before continuing
    canvas.offsetHeight; // Trigger reflow

    // Stage 2: Create view structure
    setTimeout(() => {
      // Pass QD coordinates directly to preserve full precision at deep zoom
      let newView = this.grid.makeView(
        k + 1, nsize, oreQD, oimQD, true
      );
      this.grid.notifyurl();

      // Stage 3: Draw and start computation
      setTimeout(() => {
        newView.draw(canvas.getContext('2d'));
        this.grid.startViewComputation(k + 1);
      }, 0);
    }, 0);
  }

  cellclick(k, m, hideCurrent) {
    // Only accept clicks on cells with something computed in them.
    if (k >= this.grid.views.length || this.grid.views[k].uninteresting() ||
         this.grid.currentUpdateProcess) return;
    setTimeout(() => { this.cellclickdelay(k, m, hideCurrent); }, 1);
  }

  cellclickdelay(k, m, hideCurrent) {
    if (k >= this.grid.views.length || this.grid.currentUpdateProcess) return;
    let osize = this.grid.views[k].size;
    let ore = this.grid.views[k].re;
    let oim = this.grid.views[k].im;
    let cx = m % this.config.dimsWidth;
    let cy = (m - cx) / this.config.dimsWidth;
    const rectX = cx / this.config.dimsWidth;
    const rectY = cy / this.config.dimsHeight;
    this.showZoomRect(k, rectX, rectY, this.config.zoomfactor);
    this.grid.truncateviews(k + 1);
    // Update hidden views after truncating - this clears any stale hidden board indices
    // that no longer exist, preventing them from blocking new boards at those indices
    this.grid.updateHiddenViews();
    let nsize = osize / this.config.zoomfactor;
    // Compute fractional offsets from center (both as simple fractions)
    const offsetX = (cx / this.config.dimsWidth) - 0.5;
    const offsetY = 0.5 - rectY;
    // Scale offsets by size to preserve accuracy at deep zoom (toQDScale handles conversion)
    const nreQD = toQDAdd(ore, toQDScale(osize, offsetX));
    const nimQD = toQDAdd(oim, toQDScale(osize, offsetY / this.config.aspectRatio));

    // Stage 1: Create DOM and scroll immediately (instant visual feedback)
    // Pass nsize to makecanvas so the zoom label shows correct scientific notation
    this.grid.makecanvas(k + 1, [nsize, null, null]);
    this.grid.updateFullscreenButton();
    if (hideCurrent) {
      this.grid.canvas(k).parentElement.style.display = 'none';
      this.updateZoomRectangles();
      this.grid.updateHiddenViews();
    }
    this.grid.canvas(k + 1).parentElement.className = 'hidemarks';
    const canvas = this.grid.canvas(k + 1);
    canvas.parentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Force browser to render stage 1 before continuing
    canvas.offsetHeight; // Trigger reflow

    // Stage 2: Create view structure
    // Pass QD precision coordinates to preserve full precision at deep zoom
    setTimeout(() => {
      let newView = this.grid.makeView(k + 1, nsize, nreQD, nimQD, true);
      this.grid.showcanvas(k + 1);
      this.grid.notifyurl();
      document.body.className = '';

      // Stage 3: Draw and start computation
      setTimeout(() => {
        newView.draw(canvas.getContext('2d'));
        this.grid.startViewComputation(k + 1);
      }, 0);
    }, 0);
  }

  centerViews(includeFirst) {
    const lastK = this.grid.views.length - 1;
    const oreQD = this.grid.views[lastK].re;
    const oimQD = this.grid.views[lastK].im;

    // Helper to check if view center is within 0.01% tolerance of target
    // Uses QD arithmetic to avoid precision loss at deep zoom
    const isWithinTolerance = (view, targetReQD, targetImQD) => {
      const viewSize = view.size;
      const tolerance = viewSize * 0.0001; // 0.01% of view extent
      // Compute difference in QD space, then convert to number
      const reDiff = Math.abs(qdToNumber(toQDSub(view.re, targetReQD)));
      const imDiff = Math.abs(qdToNumber(toQDSub(view.im, targetImQD)));
      return reDiff < tolerance && imDiff < tolerance;
    };

    // PHASE 1: Identify which views need board recreation (using ORIGINAL coords)
    // Must do this BEFORE updating any coordinates
    const needsRecreation = [];
    for (let k = includeFirst ? 0 : 1; k < this.grid.views.length - 1; k += 1) {
      if (qdCompare(this.grid.views[k].re, oreQD) ||
          qdCompare(this.grid.views[k].im, oimQD)) {
        if (!isWithinTolerance(this.grid.views[k], oreQD, oimQD)) {
          needsRecreation.push(k);
        }
      }
    }

    // PHASE 2: Update all view coordinates to target
    // This ensures URL will be correct immediately
    for (let k = includeFirst ? 0 : 1; k < this.grid.views.length - 1; k += 1) {
      this.grid.views[k].sizesQD[1] = oreQD;
      this.grid.views[k].sizesQD[2] = oimQD;
    }

    // PHASE 3: Update URL immediately (before expensive board recreation)
    // This prevents race condition if user refreshes during processing
    this.grid.notifyurl();

    // PHASE 4: Show zoom rectangles (coordinates are now all centered)
    if (!includeFirst) {
      const invPrevSize = 1 / this.grid.views[0].size;
      this.showZoomRect(
        0,
        qdToNumber(toQDAdd(
          toQD(0.5),
          toQDScale(
            toQDSub(oreQD, this.grid.views[0].re),
            invPrevSize
          ))),
        qdToNumber(toQDAdd(
          toQD(0.5),
          toQDScale(
            toQDSub(this.grid.views[0].im, oimQD),
            invPrevSize * this.config.aspectRatio
          ))),
           this.grid.views[0].size / this.grid.views[1].size);
    }
    for (let k = includeFirst ? 0 : 1; k < this.grid.views.length - 1; k += 1) {
      this.showZoomRect(
          k, 0.5, 0.5, this.grid.views[k].size / this.grid.views[k+1].size);
    }

    // PHASE 5: Recreate boards that were beyond tolerance
    for (const k of needsRecreation) {
      this.grid.scheduler.removeBoardFromWorker(k);
      const nsize = this.grid.views[k].size;
      this.grid.makeView(k, nsize, oreQD, oimQD);
      this.grid.views[k].clearcanvas(this.grid.canvas(k).getContext('2d'));
      this.grid.clearseq(k);
    }
  }
}

// Synchronizes view state with URL parameters for bookmarking and sharing.
class URLHandler {
  constructor(config, grid, store = null) {
    this.config = config;
    this.grid = grid;
    this.store = store;
    // Initialize from current URL so changes can be detected
    this.lastCenters = this.extractCenters(document.location.search);
    this.lastHidden = this.extractHidden(document.location.search);
    // Track whether we're processing a popstate event
    // During popstate, we should NEVER push new history entries
    this.processingPopState = false;
    this.grid.onurlchange(x => this.updateurl());
    // Handle browser back/forward navigation
    window.addEventListener('popstate', () => this.handlePopState());
  }

  handlePopState() {
    // Mark that we're processing a popstate event
    // This prevents updateurl() from pushing new history entries
    this.processingPopState = true;

    // If config parameters that require recomputation changed, reload
    if (this.configChangedRequiresRecompute()) {
      window.location.reload();
      return;
    }

    // Apply display-only config changes (theme, unknowncolor)
    this.applyDisplayConfigFromUrl();

    // Parse the URL from history to get target state
    const targetState = this.parseUrl();

    // Fill in default base view if no centers specified in URL
    if (targetState.sizes.length === 0) {
      targetState.sizes = [[null, this.config.firstrQD, this.config.firstjQD]];
    }

    // Build pool of all reusable views (union of stableViews and current views)
    // Use a Map to dedupe by id, then convert to array for consistent indexing
    // Add stableViews first (they have computed data we want to preserve)
    // then current views (may have newer data for same coordinates)
    const viewsById = new Map();  // id -> view
    for (const view of (this.grid.stableViews || [])) {
      if (view) viewsById.set(view.id, view);
    }
    for (const view of this.grid.views) {
      if (view) viewsById.set(view.id, view);
    }
    const reusableViews = Array.from(viewsById.values());

    // Build currentState from reusable views array
    // The indices here must match reusableViews array indices
    // State format: [sizeDouble, reQD, imQD] - matches sizesQD storage format
    const currentState = { hidden: [], sizes: [] };
    for (const view of reusableViews) {
      currentState.sizes.push(view.sizesQD);
    }

    // Find views to keep vs recreate by comparing coordinates
    const { viewsToKeep, newState } = this.computeViewTransition(currentState, targetState);

    if (viewsToKeep.length === 0) {
      // No views can be reused, just reload
      window.location.reload();
      return;
    }

    // Apply the optimized transition, passing the pool of reusable views
    // Note: applyViewTransition triggers updateLayout which is async.
    // processingPopState stays > 0 until the update completes and calls notifyurl().
    // We decrement it in updateurl() after the update completes.
    this.applyViewTransition(viewsToKeep, newState, reusableViews);
  }

  // Check if config parameters require full recomputation (not just redraw)
  configChangedRequiresRecompute() {
    const params = new URLSearchParams(document.location.search);

    // Parameters that require full recomputation
    const exponent = params.get('exponent');
    if (exponent && parseInt(exponent) !== this.config.exponent) return true;

    const gpu = params.get('gpu');
    if (gpu !== null && (parseInt(gpu) !== 0) !== this.config.enableGPU) return true;

    const aspectRatio = params.get('a');
    if (aspectRatio) {
      const m = aspectRatio.match(/(\d+):(\d+)/);
      if (m) {
        const ratio = parseInt(m[1]) / parseInt(m[2]);
        if (Math.abs(ratio - this.config.aspectRatio) > 0.01) return true;
      }
    }

    const pixelRatio = params.get('pixelratio');
    if (pixelRatio && parseInt(pixelRatio) !== this.config.pixelRatio) return true;

    const grid = params.get('grid');
    if (grid && parseInt(grid) !== this.config.gridcols) return true;

    return false;
  }

  // Apply display-only config changes (theme, unknowncolor) without recomputing
  // Also restores defaults when parameters are missing from URL
  applyDisplayConfigFromUrl() {
    const params = new URLSearchParams(document.location.search);
    let needsRedraw = false;

    // Theme: use URL value or default to 'warm'
    const theme = params.get('theme');
    const targetTheme = (theme && this.config.colorThemes.all.includes(theme)) ?
      theme : 'warm';
    if (targetTheme !== this.config.theme) {
      this.store.dispatch(this.store.actions.updateConfig({ theme: targetTheme }));
      needsRedraw = true;
    }

    // Unknown color: use URL value or default to '#000'
    const unk = params.get('unk');
    let targetColor = '#000';  // default
    if (unk) {
      targetColor = decodeURIComponent(unk);
      if (/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$/.test(targetColor)) {
        targetColor = `#${targetColor}`;
      }
    }
    if (targetColor !== this.config.unknowncolor) {
      this.store.dispatch(this.store.actions.updateConfig({ unknowncolor: targetColor }));
      needsRedraw = true;
    }

    // Redraw all views if display config changed
    if (needsRedraw) {
      for (let k = 0; k < this.grid.views.length; k++) {
        if (this.grid.views[k]) {
          this.grid.views[k].draw(this.grid.canvas(k).getContext('2d'));
        }
      }
    }
  }

  // Compare current and target states, find which views can be reused
  computeViewTransition(currentState, targetState) {
    const viewsToKeep = [];  // Indices of current views to preserve
    const newState = { sizes: [], hidden: targetState.hidden };

    // Fill in sizes for target state (parseUrl leaves size as null)
    const zoomFactor = this.getZoomFactorFromUrl();
    let size = this.config.firstsize / zoomFactor;
    for (let i = 0; i < targetState.sizes.length; i++) {
      if (i > 0) {
        size = size / this.config.zoomfactor;
      }
      targetState.sizes[i][0] = size;
    }

    // Match target views against current views by coordinates AND zoom level
    // A view is defined by both its center and its size (zoom level)
    // Uses QD precision coordinates with 0.01% tolerance thresholds
    const viewsMatch = (targetSize, targetRe, targetIm,
                        currentSize, currentRe, currentIm) => {
      // Check zoom level first - must be within 0.1% of each other
      const sizeRatio = targetSize / currentSize;
      if (sizeRatio < 0.999 || sizeRatio > 1.001) return false;

      // Check coordinates - tolerance is 0.01% of the view's visible extent
      // Compute difference in QD precision first, then convert magnitude to double
      // (converting coords to double first would lose precision at deep zooms)
      const tolerance = currentSize * 0.0001;
      const reDiff = Math.abs(qdToNumber(toQDSub(targetRe, currentRe)));
      const imDiff = Math.abs(qdToNumber(toQDSub(targetIm, currentIm)));
      return reDiff < tolerance && imDiff < tolerance;
    };

    // Track which current views have been matched (can't reuse same view twice)
    const usedCurrentIndices = new Set();

    for (let targetIdx = 0; targetIdx < targetState.sizes.length; targetIdx++) {
      const [targetSize, targetRe, targetIm] = targetState.sizes[targetIdx];
      let foundMatch = false;

      for (let currentIdx = 0; currentIdx < currentState.sizes.length; currentIdx++) {
        // Skip if this current view was already matched to a previous target
        if (usedCurrentIndices.has(currentIdx)) continue;

        const [currentSize, currentRe, currentIm] = currentState.sizes[currentIdx];

        // Compare both coordinates and zoom level
        if (viewsMatch(targetSize, targetRe, targetIm, currentSize, currentRe, currentIm)) {
          // View matches - reuse it
          viewsToKeep.push({ targetIdx, currentIdx });
          usedCurrentIndices.add(currentIdx);
          // Use current view's size (preserves computation state)
          newState.sizes.push(currentState.sizes[currentIdx]);
          foundMatch = true;
          break;
        }
      }

      if (!foundMatch) {
        // No match - need to create new view
        newState.sizes.push(targetState.sizes[targetIdx]);
      }
    }

    return { viewsToKeep, newState };
  }

  /**
   * Parse a scientific notation string like "1e400" without JavaScript's parseFloat overflow.
   * Returns {mantissa, exponent} where the value = mantissa * 10^exponent.
   */
  parseScientificNotation(str) {
    str = str.trim().toLowerCase();
    // Match patterns like: 1e400, 1.5e+300, 2e-10, 1.23
    const match = str.match(/^([+-]?\d*\.?\d+)(?:e([+-]?\d+))?$/);
    if (!match) {
      return { mantissa: parseFloat(str), exponent: 0 };
    }
    const mantissa = parseFloat(match[1]);
    const exponent = match[2] ? parseInt(match[2], 10) : 0;
    return { mantissa, exponent };
  }

  getZoomFactorFromUrl() {
    const params = new URLSearchParams(document.location.search);
    let zVal = params.get('z');
    if (zVal) {
      zVal = zVal.replace(/ /g, '+');
      const { mantissa, exponent } = this.parseScientificNotation(zVal);
      return mantissa * Math.pow(10, exponent);
    }
    return 1.0;
  }

  // Apply the transition - updateLayout will automatically preserve matching views
  applyViewTransition(viewsToKeep, newState, reusableViews) {
    // Note: processingPopState counter is set in handlePopState and decremented in updateurl()
    // This ensures that the notifyurl() call at the end of updateLayout doesn't push history
    this.grid.updateLayout(newState);
  }

  updateurl() {
    if (!history.replaceState) return;

    // NEVER push history during popstate processing - this would destroy forward history
    if (this.processingPopState) {
      // Clear the flag - this update was triggered by a popstate
      this.processingPopState = false;
      // Just update lastCenters/lastHidden to match current URL, no history change
      this.lastCenters = this.extractCenters(document.location.search);
      this.lastHidden = this.extractHidden(document.location.search);
      // Don't call replaceState - the URL is already correct from the popstate
      return;
    }

    const newSearch = this.currenturl();
    const newCenters = this.extractCenters(newSearch);
    const newHidden = this.extractHidden(newSearch);
    var newUrl = new URL(window.location);
    newUrl.search = newSearch;

    // Use pushState if centers were removed/replaced OR hidden views changed
    const centersLost = this.lastCenters !== null &&
      centersWereLost(this.lastCenters, newCenters);
    const hiddenChanged = this.lastHidden !== null && this.lastHidden !== newHidden;

    if (centersLost || hiddenChanged) {
      history.pushState(null, '', newUrl);
    } else {
      history.replaceState(null, '', newUrl);
    }

    this.lastCenters = newCenters;
    this.lastHidden = newHidden;
  }

  // Extract the c parameter value from a URL string
  extractCenters(url) {
    const match = url.match(/[?&]c=([^&]*)/);
    return match ? match[1] : '';
  }

  // Extract the h parameter value from a URL string
  extractHidden(url) {
    const match = url.match(/[?&]h=([^&]*)/);
    return match ? match[1] : '';
  }

  setupUrlParameters() {
    // Registry of simple URL parameters with their parse logic
    // Each parse function adds properties to the configUpdates object
    this.urlParams = [
      {
        name: 'exponent',
        parse: (val, configUpdates) => {
          const exponent = Math.max(2, parseInt(val));
          configUpdates.exponent = exponent;
          if (exponent > 2) { configUpdates.firstrQD = [0.0, 0, 0, 0]; }
          // DOM update (side effect, not state)
          for (const el of document.querySelectorAll('.exponent')) {
            el.innerText = exponent;
          }
        }
      },
      {
        name: 'gpu',
        parse: (val, configUpdates) => {
          configUpdates.enableGPU = parseInt(val) !== 0;
        }
      },
      {
        name: 'board',
        parse: (val, configUpdates) => {
          const boardType = val.toLowerCase();
          const validTypes = [
            'cpu', 'ddz', 'qdz', 'gpu', 'gpuz', 'adaptive', 'qdcpu'
          ];
          if (validTypes.includes(boardType)) {
            configUpdates.forceBoard = boardType;
          } else {
            console.warn(`Invalid board type: ${boardType}. Valid types: ${validTypes.join(', ')}`);
          }
        }
      },
      {
        name: 'grid',
        parse: (val, configUpdates) => {
          configUpdates.gridcols = Math.max(1, parseInt(val));
        }
      },
      {
        name: 'a',
        parse: (val, configUpdates) => {
          const m = val.match(/(\d+):(\d+)/);
          if (m) {
            const width = parseInt(m[1]);
            const height = parseInt(m[2]);
            if (width > 0 && height > 0) {
              configUpdates.aspectRatio = width / height;
            }
          }
        }
      },
      {
        name: 'z',
        parse: (val, configUpdates) => {
          // URLSearchParams decodes '+' as space, convert back for, e.g., 3e+20
          val = val.replace(/ /g, '+');
          // Parse scientific notation to handle extreme zoom values (e.g., 1e400)
          const { mantissa, exponent } = this.parseScientificNotation(val);
          // Store zoom parameters for later - size computation needs
          // aspect-ratio-adjusted firstsize
          // which isn't available until after initSizes() is called
          this.config.zoomFromUrl = { mantissa, exponent };
        }
      },
      {
        name: 's',
        parse: (val, configUpdates) => {
          // Legacy size parameter (e.g., s=1e-15 means view size of 1e-15)
          // Read-only: we accept it but output z= in URLs
          val = val.replace(/ /g, '+');
          const { mantissa, exponent } = this.parseScientificNotation(val);
          // Store size directly - will be used as actualSize in initSizes()
          this.config.sizeFromUrl = { mantissa, exponent };
        }
      },
      {
        name: 'pixelratio',
        parse: (val, configUpdates) => {
          configUpdates.pixelRatio = Math.max(1, parseInt(val));
        }
      },
      {
        name: 'theme',
        parse: (val, configUpdates) => {
          if (this.config.colorThemes.all.includes(val)) {
            configUpdates.theme = val;
          }
        }
      },
      {
        name: 'unk',
        parse: (val, configUpdates) => {
          // Allow any CSS color (e.g., 000, rgb(32,16,64), yellow, etc.)
          let color = decodeURIComponent(val);
          // Auto-prepend # for hex colors (e.g., 888 -> #888)
          if (/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$/.test(color)) {
            color = `#${color}`;
          }
          configUpdates.unknowncolor = color;
        }
      },
      {
        name: 'debug',
        parse: (val, configUpdates) => {
          // Debug flags (comma-separated, supports key=value)
          // Suggested flags:
          //   w = load worker code on main thread (makes Board classes globally available for debugging)
          //   n = noinit (skip default view creation - starts with blank canvas)
          //   t = trace (enable detailed logging)
          //   x=value = example custom flag with value
          // Examples: ?debug=w,t  or  ?debug=w,n  or  ?debug=w,x=foobar
          configUpdates.debug = val;
        }
      },
      {
        name: 'inherit',
        parse: (val, configUpdates) => {
          // Enable/disable parent-to-child pixel inheritance
          // ?inherit=0 disables, ?inherit=1 (default) enables
          configUpdates.enableInheritance = parseInt(val) !== 0;
        }
      }
    ];
  }

  parseUrl() {
    const startstate = { hidden: [], sizes: [] };
    const params = new URLSearchParams(document.location.search);

    // Parse all registered simple parameters
    if (!this.urlParams) {
      this.setupUrlParameters();
    }

    // Collect all config updates to batch them into a single dispatch
    const configUpdates = {};
    for (const param of this.urlParams) {
      const value = params.get(param.name);
      if (value) {
        param.parse(value, configUpdates);
      }
    }

    // Batch update all config changes at once
    if (Object.keys(configUpdates).length > 0) {
      this.config.store.dispatch(
        this.config.store.actions.updateConfig(configUpdates)
      );
    }

    // Parse coordinates parameter
    // Note: URLSearchParams decodes '+' as space, so we convert spaces back to '+'
    let c = params.get('c');
    if (c) {
      c = c.replace(/ /g, '+');
      for (const coords of c.split(',')) {
        // Parse complex number string (empty string returns null to inherit)
        const parsed = parseComplexToQD(coords);

        // If parsing failed or empty string, inherit from previous or default
        if (!parsed) {
          startstate.sizes.push([
            null,  // Placeholder - will be filled in after initSizes()
            startstate.sizes.length > 0 ?
              startstate.sizes[startstate.sizes.length - 1][1] :
              this.config.firstrQD,
            startstate.sizes.length > 0 ?
              startstate.sizes[startstate.sizes.length - 1][2] :
              this.config.firstjQD
          ]);
        } else {
          // Store parsed coordinates; size will be calculated later
          startstate.sizes.push([
            null,  // Placeholder - will be filled in after initSizes()
            parsed.re,
            parsed.im
          ]);
        }
      }
    }

    // Parse hidden views parameter
    const h = params.get('h');
    if (h) {
      startstate.hidden = h.split(',').map(x => parseInt(x));
    }

    // Don't fill in default sizes yet - wait until after initSizes()
    // so that firstsize accounts for aspect ratio
    return startstate;
  }

  currenturl() {
    let state = this.grid.currentGridState();
    let compactc = '';
    let commas = '';
    let prev = [this.config.firstrQD, this.config.firstjQD];
    let prevj = -1;
    for (let j = 0; j <= state.sizes.length; j++) {
      const view = this.grid.views[j];
      const viewReQD = view ? view.re : state.sizes[j]?.[1];
      const viewImQD = view ? view.im : state.sizes[j]?.[2];
      if (j < state.sizes.length &&
          !qdCompare(viewReQD, prev[0]) &&
          !qdCompare(viewImQD, prev[1])) {
        commas += ',';
      } else {
        if (prevj >= 0) {
          const pv = this.grid.views[prevj];
          const pre = pv ? pv.re : state.sizes[prevj][1];
          const pim = pv ? pv.im : state.sizes[prevj][2];
          compactc += `${formatcomplex(j - 1, pre, pim)},`;
        }
        compactc += commas;
        if (j < state.sizes.length) {
          commas = '';
          prev = [viewReQD, viewImQD];
          prevj = j;
        }
      }
    }
    compactc = compactc.slice(0, -1);
    // Calculate zoom factor for URL (z parameter)
    let zoomFactor = this.grid.views[0].zoomFactor;

    // Format aspect ratio for URL (only if not 1:1)
    let aspectRatioParam = '';
    if (this.config.aspectRatio !== 1.0) {
      const [num, den] = toSimpleFraction(this.config.aspectRatio);
      aspectRatioParam = `&a=${num}:${den}`;
    }

    const url =
        (Math.abs(zoomFactor - 1.0) > 0.01
            ? `&z=${formatZoom(zoomFactor)}` : '') +
        aspectRatioParam +
        (this.config.exponent !== 2
            ? `&exponent=${this.config.exponent}` : '') +
        (!this.config.enableGPU
            ? '&gpu=0' : '') +
        (this.config.forceBoard
            ? `&board=${this.config.forceBoard}` : '') +
        (compactc.length
            ? `&c=${compactc}` : '') +
        (this.config.gridcols !== Math.min(2, Math.ceil(this.config.vw / 501))
            ? `&grid=${this.config.gridcols}` : '') +
        (state.hidden.length
            ? `&h=${state.hidden}` : '') +
        (this.config.theme !== 'warm'
            ? `&theme=${this.config.theme}` : '') +
        (this.config.unknowncolor !== '#000'
            ? `&unk=${encodeURIComponent(
              /^#[0-9a-fA-F]{3}$|^#[0-9a-fA-F]{6}$/.test(this.config.unknowncolor)
              ? this.config.unknowncolor.substring(1)
              : this.config.unknowncolor)}` : '') +
        (this.config.pixelRatio !== 2
            ? `&pixelratio=${this.config.pixelRatio}` : '') +
        (this.config.debug
            ? `&debug=${this.config.debug}` : '') +
        (LANG_FROM_URL ? `&lang=${SELECTED_LANG}` : '') +
        (this.config.enableInheritance === false
            ? '&inherit=0' : '');
    return url.replace('&', '?');
  }
}

// Handles mouse clicks, keyboard commands, and touch events.
class EventHandler {
  constructor(explorer) {
    this.explorer = explorer;
  }

  setup() {
    this.setupKeyboardCommands();
    this.setupEventDelegation();
    document.onmousedown = this.onmousedown.bind(this);
    document.onmousemove = this.onmousemove.bind(this);
    document.onmouseup = this.onmouseup.bind(this);
    document.body.onkeydown = this.onkeydown.bind(this);
    document.body.onmouseover = this.onmouseover.bind(this);
  }

  setupEventDelegation() {
    // Use event delegation on grid for closebox interactions
    const gridElement = document.getElementById('grid');

    gridElement.addEventListener('mousedown', (e) => {
      if (e.target.classList.contains('closebox')) {
        e.stopPropagation();
      }
    }, true);  // Use capture phase

    gridElement.addEventListener('click', (e) => {
      if (e.target.classList.contains('closebox') &&
          !this.explorer.grid.currentUpdateProcess) {
        e.target.parentElement.style.display = 'none';
        this.explorer.grid.truncatehiddenviews();
        this.explorer.zoomManager.updateZoomRectangles();
        this.explorer.grid.updateHiddenViews();
        this.explorer.grid.updateFullscreenButton();
        this.explorer.urlHandler.updateurl();
      }
    });

    // Handle right-click on canvas with custom context menu
    gridElement.addEventListener('contextmenu', (e) => {
      if (e.target.tagName === 'CANVAS' && !e.target.classList.contains('overlay')) {
        // If transparent mode, let native context menu handle it
        if (this.explorer.config.unknowncolor === 'transparent') {
          return;
        }

        e.preventDefault();
        const canvas = e.target;

        // Get view index from canvas parent id (format: b_0, b_1, etc.)
        const containerId = canvas.parentElement?.id;
        const k = containerId ? parseInt(containerId.split('_')[1]) : 0;
        const view = this.explorer.grid.views[k];

        // Build filename using view coordinates and zoom
        const zoomFactor = this.explorer.config.firstsize / view.size;
        const coords = formatcomplex(k, view.re, view.im);
        const filename = `mandelbrot-z${formatZoom(zoomFactor)}-c${coords}.png`;

        // Create composited canvas with background color
        const createCompositedBlob = () => {
          return new Promise((resolve) => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw background first, then original canvas on top
            tempCtx.fillStyle = this.explorer.config.unknowncolor;
            tempCtx.fillRect(0, 0, canvas.width, canvas.height);
            tempCtx.drawImage(canvas, 0, 0);

            tempCanvas.toBlob(resolve, 'image/png');
          });
        };

        // Create and show custom context menu (macOS style)
        const menu = document.createElement('div');
        menu.style.cssText = `
          position: fixed;
          left: ${e.clientX}px;
          top: ${e.clientY}px;
          background: rgba(227, 227, 226, 0.9);
          backdrop-filter: blur(20px);
          -webkit-backdrop-filter: blur(20px);
          border: 0.5px solid rgba(0, 0, 0, 0.15);
          border-radius: 6px;
          box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
          padding: 6px;
          z-index: 10000;
          font: 13.5px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        `;

        const createMenuItem = (text) => {
          const item = document.createElement('div');
          item.textContent = text;
          item.style.cssText = `
            padding: 5px 8px;
            margin-bottom: 1px;
            cursor: default;
            white-space: nowrap;
            border-radius: 4px;
            color: rgb(35, 35, 35);
            text-align: left;
          `;
          item.addEventListener('mouseenter', () => {
            item.style.background = 'rgb(95, 150, 244)';
            item.style.color = '#fff';
          });
          item.addEventListener('mouseleave', () => {
            item.style.background = '';
            item.style.color = 'rgb(35, 35, 35)';
          });
          return item;
        };

        // Blink animation for menu selection
        const blinkItem = async (item) => {
          item.style.animation = 'menuBlink 0.25s ease-in-out';
          await new Promise(r => setTimeout(r, 250));
        };
        if (!document.getElementById('menuBlinkStyle')) {
          const style = document.createElement('style');
          style.id = 'menuBlinkStyle';
          style.textContent = `
            @keyframes menuBlink {
              0%, 100% { background: rgb(95, 150, 244); color: #fff; }
              50% { background: transparent; color: rgb(35, 35, 35); }
            }
          `;
          document.head.appendChild(style);
        }

        // Save image option
        const hasSavePicker = !!window.showSaveFilePicker;
        const saveItem = createMenuItem(hasSavePicker ? 'Save Image As...' : 'Download Image');
        saveItem.addEventListener('click', async () => {
          if (window.showSaveFilePicker) {
            // Start blink but don't await - must call picker synchronously for user gesture
            saveItem.style.animation = 'menuBlink 0.25s ease-in-out';
            setTimeout(() => menu.remove(), 250);
            try {
              const handle = await window.showSaveFilePicker({
                suggestedName: filename,
                startIn: 'downloads',
                types: [{
                  description: 'PNG Image',
                  accept: { 'image/png': ['.png'] }
                }]
              });
              // Then create blob and write
              const blob = await createCompositedBlob();
              const writable = await handle.createWritable();
              await writable.write(blob);
              await writable.close();
            } catch (err) {
              if (err.name !== 'AbortError') console.error('Save failed:', err);
            }
          } else {
            // Fallback for browsers without showSaveFilePicker (e.g. Safari)
            await blinkItem(saveItem);
            menu.remove();
            const blob = await createCompositedBlob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
          }
        });
        menu.appendChild(saveItem);

        // Copy image option (only if ClipboardItem is supported)
        const hasClipboardItem = typeof ClipboardItem !== 'undefined' && navigator.clipboard?.write;
        if (hasClipboardItem) {
          const copyItem = createMenuItem('Copy Image');
          copyItem.addEventListener('click', async () => {
            await blinkItem(copyItem);
            menu.remove();
            const blob = await createCompositedBlob();
            try {
              await navigator.clipboard.write([
                new ClipboardItem({ 'image/png': blob })
              ]);
              // Show toast notification
              const toast = document.createElement('div');
              toast.textContent = 'Image copied';
              toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #1a3a5c;
                color: #fff;
                padding: 12px 20px;
                border-radius: 20px;
                font: 14px -apple-system, BlinkMacSystemFont, sans-serif;
                z-index: 10001;
                opacity: 1;
                transition: opacity 0.3s ease;
              `;
              document.body.appendChild(toast);
              setTimeout(() => { toast.style.opacity = '0'; }, 1500);
              setTimeout(() => toast.remove(), 1800);
            } catch (err) {
              // Show error toast (Safari doesn't allow clipboard write)
              const toast = document.createElement('div');
              toast.textContent = 'Copy not available';
              toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #5c3a3a;
                color: #fff;
                padding: 12px 20px;
                border-radius: 20px;
                font: 14px -apple-system, BlinkMacSystemFont, sans-serif;
                z-index: 10001;
                opacity: 1;
                transition: opacity 0.3s ease;
              `;
              document.body.appendChild(toast);
              setTimeout(() => { toast.style.opacity = '0'; }, 1500);
              setTimeout(() => toast.remove(), 1800);
            }
          });
          menu.appendChild(copyItem);
        }

        document.body.appendChild(menu);

        // Close menu when clicking outside or pressing Escape
        const closeMenu = (event) => {
          if (event.type === 'keydown' && event.key !== 'Escape') return;
          if (event.type === 'mousedown' && menu.contains(event.target)) return;
          menu.remove();
          document.removeEventListener('mousedown', closeMenu, true);
          document.removeEventListener('keydown', closeMenu, true);
        };
        setTimeout(() => {
          document.addEventListener('mousedown', closeMenu, true);
          document.addEventListener('keydown', closeMenu, true);
        }, 0);
      }
    });

    // Handle closebox click on help text
    const textClosebox = document.querySelector('#text .closebox');
    if (textClosebox) {
      textClosebox.addEventListener('click', () => {
        document.getElementById('text').style.display = 'none';
      });
    }
  }

  onmousedown(e) {
    let target = this.eventtarget(e);

    // Dispatch mouse down state
    if (this.explorer.store) {
      this.explorer.store.dispatch(
        this.explorer.store.actions.mouseDown(e.button, {
          x: e.clientX,
          y: e.clientY
        })
      );
    }

    if (this.explorer.movieMode.active && (!target || target.id !== 'moviescale')) {
      this.explorer.movieMode.toggle();
    }
    if (e.button !== 0) { return true; }
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (e.target.tagName === 'A') {
        if (m && !this.explorer.config.mobile) {
          e.target.href = this.explorer.grid.bigurl(m[1], e.metaKey || e.ctrlKey);
        }
        return true;
      }
      if (m) {
        let p = this.pointInTarget(e, target);
        let k = parseInt(m[1]);

        // Dispatch focused view change
        if (this.explorer.store) {
          this.explorer.store.dispatch(
            this.explorer.store.actions.setFocusedView(k)
          );
        }

        // Clear orbit before creating new view
        this.explorer.orbitComputer.updateOrbit(k, -1, target);
        this.explorer.zoomManager.cellclick(k, p.x + p.y * this.explorer.config.dimsWidth,
          e.metaKey || e.ctrlKey);
        return false;
      }
    }
    return true;
  }

  onmousemove(e) {
    let target = this.eventtarget(e);

    // Dispatch mouse move state
    if (this.explorer.store) {
      this.explorer.store.dispatch(
        this.explorer.store.actions.mouseMove({
          x: e.clientX,
          y: e.clientY
        })
      );
    }

    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (m) {
        let p = this.pointInTarget(e, target);
        let k = parseInt(m[1]);
        let j = p.x + p.y * this.explorer.config.dimsWidth;
        this.explorer.orbitComputer.updateOrbit(k, j, target);
      }
    }
  }

  onmouseup(e) {
    // Dispatch mouse up state
    if (this.explorer.store) {
      this.explorer.store.dispatch(
        this.explorer.store.actions.mouseUp()
      );
    }
  }

  setupKeyboardCommands() {
    const { grid, config, movieMode, zoomManager, urlHandler } = this.explorer;

    this.keyCommands = new Map([
      ['backspace', { // Close the deepest zoom view
        condition: () => grid.views.length > 1 && !grid.currentUpdateProcess,
        action: () => {
          const k = grid.views.length - 1;
          grid.truncateviews(k);
          grid.truncatehiddenviews();
          urlHandler.updateurl();
        }
      }],
      ['c', { // Center all views on the deepest zoom
        condition: () => grid.views.length > 1,
        action: (e) => zoomManager.centerViews(e.metaKey || e.ctrlKey)
      }],
      ['a', { // Toggle aspect ratio (1:1 ↔ 16:9)
        condition: () => !grid.currentUpdateProcess,
        action: () => {
          const oldFirstsize = config.firstsize;
          config.setAspectRatio(
            config.aspectRatio === Config.DEFAULT_ASPECT_RATIO ?
              Config.WIDESCREEN_ASPECT_RATIO : Config.DEFAULT_ASPECT_RATIO
          );
          config.initSizes();
          const newFirstsize = config.firstsize;
          const state = grid.currentGridState();
          const scaleFactor = newFirstsize / oldFirstsize;
          for (let i = 0; i < state.sizes.length; i++) {
            state.sizes[i][0] *= scaleFactor;
          }
          grid.updateLayout(state);
        }
      }],
      ['t', { // Cycle color theme (Shift for reverse)
        action: (e) => this.explorer.cycleColorTheme(e.shiftKey)
      }],
      ['u', { // Cycle unknown pixel color (Shift for reverse)
        action: (e) => this.explorer.cycleUnknownColor(e.shiftKey)
      }],
      ['i', { // Zoom in at center of deepest view
        action: (e) => zoomManager.zoomInAtCurrentPosition(e.metaKey || e.ctrlKey)
      }],
      ['?', { // Show help
        action: () => {
          document.getElementById('text').style.display = '';
          document.getElementById('text').scrollIntoView({ behavior: 'smooth' });
        }
      }],
      ['g', { // Shrink grid (fewer columns)
        condition: () => config.gridcols > 1,
        action: () => {
          config.setGridcols(config.gridcols - 1);
          grid.updateLayout();
        }
      }],
      ['h', { // Grow grid (more columns)
        action: () => {
          config.setGridcols(config.gridcols + 1);
          grid.updateLayout();
        }
      }],
      ['r', { // Restore all hidden views
        condition: () => !grid.currentUpdateProcess,
        action: () => {
          grid.showAllViews();
          urlHandler.updateurl();
          grid.updateHiddenViews();
        }
      }],
      ['x', { // Increase exponent (z² → z³ → z⁴...)
        action: () => {
          config.updateExponent(config.exponent + 1);
          grid.updateLayout(config.firststate());
        }
      }],
      ['z', { // Decrease exponent (z⁴ → z³ → z²)
        condition: () => config.exponent > 2,
        action: () => {
          config.updateExponent(config.exponent - 1);
          grid.updateLayout(config.firststate());
        }
      }],
      ['f', { // Increase pixel resolution (finer)
        action: () => {
          config.setPixelRatio(config.pixelRatio + 1);
          grid.updateLayout();
        }
      }],
      ['d', { // Decrease pixel resolution (coarser)
        condition: () => config.pixelRatio > 1,
        action: () => {
          config.setPixelRatio(config.pixelRatio - 1);
          grid.updateLayout();
        }
      }],
      ['m', { // Toggle movie mode
        condition: () => grid.views.length > 1,
        action: () => movieMode.toggle()
      }],
      ['enter', { // Toggle fullscreen
        action: (e) => {
          e.preventDefault();
          this.explorer.toggleFullscreen();
        }
      }],
      ['escape', { // Exit fullscreen
        condition: () => document.fullscreenElement,
        action: () => this.explorer.toggleFullscreen()
      }]
    ]);
  }

  onkeydown(e) {
    const key = e.key.toLowerCase();

    // Movie mode intercepts most keys
    if (this.explorer.movieMode.active &&
        !['shift', 'alt', 'control', 'meta', 'capslock'].includes(key)) {
      this.explorer.movieMode.toggle();
      return;
    }

    // Execute command if registered
    const command = this.keyCommands.get(key);
    if (command) {
      if (!command.condition || command.condition()) {
        command.action(e);
      }
    }
  }

  onmouseover(e) {
    document.body.className = 'hidemarks';
    this.explorer.grid.setFocusedView(null);
    let target = this.eventtarget(e);
    if (target) {
      let m = target.id.match(/b_(\d+)/);
      if (m) {
        let k = parseInt(m[1]);
        this.explorer.grid.setFocusedView(k);
        if (this.explorer.grid.views.length <= k) return;
        document.body.className = '';
        let overtarget = e.target;
        if (overtarget.tagName == 'A') {
          overtarget.showDebug = e.ctrlKey || e.metaKey;
          this.explorer.grid.updateProgress(overtarget, k);
          const statusDiv = overtarget.querySelector('.status');
          if (statusDiv) { statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
        }
      } else if (target.id.startsWith('movie') && (!e.target || e.target.id != 'movie')) {
        document.body.className = '';
      }
    }
  }

  eventtarget(e) {
    let target = (e.target ? e.target : e.srcElement ? e.srcElement : null);
    while (target) {
      if (target.id) { return target; }
      target = target.parentNode;
    }
    return null;
  }

  pointInTarget(ev, target) {
    let se = document.scrollingElement || document.body;
    let x = (ev.clientX + se.scrollLeft - this.absoluteLeft(target)) *
            this.explorer.config.pixelRatio;
    let y = (ev.clientY + se.scrollTop - this.absoluteTop(target)) *
            this.explorer.config.pixelRatio;
    return { x: Math.round(x), y: Math.round(y) };
  }

  absoluteLeft(target) {
    let left = 0;
    while (target) {
      left += target.offsetLeft;
      target = target.offsetParent;
    }
    return left;
  }

  absoluteTop(target) {
    let top = 0;
    while (target) {
      top += target.offsetTop;
      target = target.offsetParent;
    }
    return top;
  }
}

// Renders smooth zoom animations and encodes them as MP4 video.
class MovieMode {
  constructor(explorer) {
    this.explorer = explorer;
    this.active = false;
    this.movieCanvas = null;
    this.movieCtx = null;
    this.animationTimer = null;
    this.preRenderTimer = null;
    this.frameCanvases = [];
    this.capturedFrames = [];  // Array to store VideoFrames for WebCodecs
    this.videoEncoder = null;
    this.muxer = null;
    this.recordedBlob = null;
    this.isRecording = false;
  }

  toggle() {
    this.active = !this.active;

    // Dispatch movie mode toggle to state
    if (this.explorer.store) {
      this.explorer.store.dispatch(
        this.explorer.store.actions.toggleMovieMode()
      );
    }

    this.explorer.grid.scheduler.pauseComputation(this.active);
    if (this.active) {
      this.startMovie();
    } else {
      this.stopMovie();
    }
  }

  startMovie() {
    this.explorer.grid.grid().style.display = 'none';
    this.explorer.movieContainer.style.display = 'block';
    this.createMovieCanvas();
    this.explorer.movieContainer.scrollIntoView({ behavior: 'smooth' });
    this.preRenderTimer = setTimeout(() => {
      document.body.className = '';
      this.preRenderFrames(() => {
        this.startMovieAnimation();
      });
    }, 20);
  }

  stopMovie() {
    this.explorer.grid.grid().style.display = 'block';
    this.explorer.movieContainer.style.display = 'none';
    this.stopMovieAnimation();
    this.removeMovieCanvas();
  }

  createMovieCanvas() {
    // Recalculate dimensions in case fullscreen state has changed
    this.explorer.config.initSizes();

    this.explorer.movieContainer.innerHTML = '<div>' +
      `<canvas width=${this.explorer.config.dimsWidth} ` +
      `height=${this.explorer.config.dimsHeight} ` +
      `style="width:${this.explorer.config.cssDimsWidth}px;` +
      `height:${this.explorer.config.cssDimsHeight}px"></canvas>` +
      `<span id="moviestatus"></span>` +
      `<a id="moviescale" class="zoomnum">${MSG.pre_rendering_movie}</a></div>`;
    this.movieCanvas = this.explorer.movieContainer.firstElementChild.firstElementChild;
    this.movieCtx = this.movieCanvas.getContext('2d');
    this.movieCtx.drawImage(this.explorer.grid.canvas(0), 0, 0);
  }

  removeMovieCanvas() {
    while (this.explorer.movieContainer.firstChild) {
      this.explorer.movieContainer.removeChild(this.explorer.movieContainer.firstChild);
    }
    this.movieCanvas = null;
    this.movieCtx = null;
  }

  preRenderFrames(after) {
    this.frameCanvases = [];
    this.isPreRendering = true;
    let queueOneFrame = (k, after) => {
      return () => {
        // Abort if movie mode was stopped
        if (!this.isPreRendering) {
          return;
        }
        let status = document.getElementById('moviescale');
        if (status) {
          const scale = this.explorer.grid.views[k].zoomFactor;
          status.textContent = `${MSG.pre_rendering_}${formatScale(scale)}`;
        }
        let canvasPrev = null;
        let canvasCurrent = null;
        let canvasNext = null;

        // Render with k-1 palette (unknown = transparent)
        if (k > 0) {
          canvasPrev = document.createElement('canvas');
          canvasPrev.width = this.explorer.config.dimsWidth;
          canvasPrev.height = this.explorer.config.dimsHeight;
          const ctxPrev = canvasPrev.getContext('2d');
          this.explorer.grid.views[k].draw(ctxPrev, this.explorer.grid.views[k - 1], 'transparent');
          if (this.explorer.config.unknowncolor != '#000') {
            ctxPrev.strokeStyle = 'yellow';
            ctxPrev.lineWidth = this.explorer.config.pixelRatio * this.explorer.config.zoomfactor;
            const w = this.explorer.config.dimsWidth;
            const h = this.explorer.config.dimsHeight;
            ctxPrev.strokeRect(0, 0, w, h);
          }
        }

        // Render with k palette (unknown = black)
        canvasCurrent = document.createElement('canvas');
        canvasCurrent.width = this.explorer.config.dimsWidth;
        canvasCurrent.height = this.explorer.config.dimsHeight;
        const ctxCurrent = canvasCurrent.getContext('2d');
        this.explorer.grid.views[k].draw(ctxCurrent, this.explorer.grid.views[k], 'black');

        // Render with k+1 palette (unknown = black)
        if (k < this.explorer.grid.views.length - 1) {
          canvasNext = document.createElement('canvas');
          canvasNext.width = this.explorer.config.dimsWidth;
          canvasNext.height = this.explorer.config.dimsHeight;
          const ctxNext = canvasNext.getContext('2d');
          this.explorer.grid.views[k].draw(ctxNext, this.explorer.grid.views[k + 1], 'black');
        }
        this.frameCanvases.push({ prev: canvasPrev, current: canvasCurrent, next: canvasNext });
        this.preRenderTimer = setTimeout(after, 1);
      };
    }
    for (let k = this.explorer.grid.views.length - 1; k >= 0; k--) {
      after = queueOneFrame(k, after);
    }
    this.preRenderTimer = setTimeout(after, 0);
  }

  startMovieAnimation() {
    let frame = 0;
    let framesteps = 400;  // 60 FPS: 400 frames = 6.67 seconds (50% faster than 10 sec)
    let endpause = 120;    // Scaled for 60 FPS (was 180 for 30 FPS = 6 sec)
    let endrecord = 60;    // Keep 1 second end recording
    const totalFrames = (this.explorer.grid.views.length - 1) * framesteps;

    const scaleElement = document.getElementById('moviescale');
    const statusElement = document.getElementById('moviestatus');
    scaleElement.removeAttribute('href');
    statusElement.textContent = 'Capturing frames...';

    this.capturedFrames = [];
    this.recordedBlob = null;
    this.isRecording = true;

    const animate = () => {
      // Abort if movie mode was stopped
      if (!this.isRecording) {
        return;
      }

      const kk = Math.min(frame, totalFrames) / framesteps;
      this.drawMovieFrame(kk);

      // Capture frame for encoding (only during recording period)
      if (frame <= totalFrames + endrecord) {
        try {
          // Create VideoFrame from canvas with duration for 60 FPS
          const videoFrame = new VideoFrame(this.movieCanvas, {
            timestamp: this.capturedFrames.length * 16667,  // 60 FPS in microseconds
            duration: 16667  // Frame duration: 1/60 second = 16667 microseconds
          });
          this.capturedFrames.push(videoFrame);

          // Update status
          if (this.capturedFrames.length % 60 === 0) {
            statusElement.textContent = `Captured ${this.capturedFrames.length} frames...`;
          }
        } catch (e) {
          console.error('Error capturing frame:', e);
          statusElement.textContent = `Error: ${e.message}`;
        }
      }

      frame++;

      // Check if we're done capturing
      if (frame > totalFrames + endrecord) {
        this.isRecording = false;
        statusElement.textContent = 'Encoding video...';
        // Start encoding after a brief delay to update UI
        setTimeout(() => this.encodeVideo(statusElement), 100);
      } else if (frame <= totalFrames + endpause) {
        // Continue animation
        this.animationTimer = requestAnimationFrame(() => animate());
      }
    };
    animate();
  }

  stopMovieAnimation() {
    this.isPreRendering = false;
    this.isRecording = false;
    if (this.preRenderTimer) {
      clearTimeout(this.preRenderTimer);
      this.preRenderTimer = null;
    }
    if (this.animationTimer) {
      cancelAnimationFrame(this.animationTimer);
      this.animationTimer = null;
    }
    // Clean up prerendered frame canvases
    if (this.frameCanvases) {
      this.frameCanvases = [];
    }
    // Clean up captured frames
    if (this.capturedFrames) {
      for (let frame of this.capturedFrames) {
        frame.close();
      }
      this.capturedFrames = [];
    }
    this.recordedBlob = null;
  }

  async encodeVideo(statusElement) {
    try {
      // Check WebCodecs support
      if (!window.VideoEncoder) {
        statusElement.textContent = 'WebCodecs not supported in this browser';
        console.error('WebCodecs API not available');
        return;
      }

      if (!window.Mp4Muxer) {
        statusElement.textContent = 'mp4-muxer library not loaded';
        console.error('mp4-muxer not available');
        return;
      }

      const width = this.movieCanvas.width;
      const height = this.movieCanvas.height;

      // Calculate appropriate H.264 level based on resolution
      // H.264 uses 16x16 macroblocks, so round up to multiples of 16
      let codedWidth = Math.ceil(width / 16) * 16;
      let codedHeight = Math.ceil(height / 16) * 16;
      let codedArea = codedWidth * codedHeight;

      // H.264 level limits (format: level hex code, max coded area, level name)
      const levels = [
        ['1E', 414720, '3.0'],      // 720x576
        ['1F', 921600, '3.1'],      // 1280x720
        ['2A', 2073600, '4.2'],     // 1920x1080
        ['34', 8912896, '5.2'],     // 4096x2304 (4K)
        ['3E', 35651584, '6.2']     // 7680x4320 (8K)
      ];

      const maxArea = levels[levels.length - 1][1]; // 8K limit
      let encodingWidth = width;
      let encodingHeight = height;
      let downscaled = false;

      // If exceeds maximum, downscale to fit
      if (codedArea > maxArea) {
        const scaleFactor = Math.sqrt(maxArea * 0.95 / codedArea); // 0.95 for safety margin
        encodingWidth = Math.floor(width * scaleFactor);
        encodingHeight = Math.floor(height * scaleFactor);
        codedWidth = Math.ceil(encodingWidth / 16) * 16;
        codedHeight = Math.ceil(encodingHeight / 16) * 16;
        codedArea = codedWidth * codedHeight;
        downscaled = true;
        const msg = `Resolution ${width}x${height} exceeds H.264 limit, ` +
                    `downscaling to ${encodingWidth}x${encodingHeight}`;
        console.warn(msg);
        statusElement.textContent = msg;
      }

      // Select minimum level that supports this resolution
      let levelCode = '3E'; // Default to 6.2 (highest)
      let levelName = '6.2';
      for (const [code, levelMaxArea, name] of levels) {
        if (codedArea <= levelMaxArea) {
          levelCode = code;
          levelName = name;
          break;
        }
      }

      const codecString = `avc1.42E0${levelCode}`;
      console.log(`Video resolution: ${encodingWidth}x${encodingHeight}, ` +
                  `coded: ${codedWidth}x${codedHeight} (${codedArea} pixels), ` +
                  `using H.264 level ${levelName}`);

      // Initialize MP4 muxer
      this.muxer = new window.Mp4Muxer.Muxer({
        target: new window.Mp4Muxer.ArrayBufferTarget(),
        video: {
          codec: 'avc',
          width: encodingWidth,
          height: encodingHeight
        },
        fastStart: 'in-memory'
      });

      let encodedCount = 0;
      const totalFrames = this.capturedFrames.length;

      // Initialize video encoder
      this.videoEncoder = new VideoEncoder({
        output: (chunk, metadata) => {
          // Ensure metadata has decoderConfig with colorSpace for Safari compatibility
          if (metadata?.decoderConfig && !metadata.decoderConfig.colorSpace) {
            metadata.decoderConfig.colorSpace = {
              primaries: 'bt709',
              transfer: 'bt709',
              matrix: 'bt709',
              fullRange: false
            };
          }
          this.muxer.addVideoChunk(chunk, metadata);
          encodedCount++;
          if (encodedCount % 60 === 0) {
            const percent = Math.round(100 * encodedCount / totalFrames);
            statusElement.textContent = `Encoding: ${percent}%`;
          }
        },
        error: (e) => {
          console.error('Encoding error:', e);
          statusElement.textContent = `Encoding error: ${e.message}`;
        }
      });

      // Configure encoder for H.264 with dynamically calculated level
      this.videoEncoder.configure({
        codec: codecString,  // H.264 baseline profile with appropriate level
        width: encodingWidth,
        height: encodingHeight,
        bitrate: 30_000_000,  // 30 Mbps for high quality
        framerate: 60,
        // Provide colorSpace to ensure Safari includes it in metadata
        colorSpace: {
          primaries: 'bt709',
          transfer: 'bt709',
          matrix: 'bt709',
          fullRange: false
        }
      });

      // Create a temporary canvas for downscaling if needed
      let tempCanvas, tempCtx;
      if (downscaled) {
        tempCanvas = document.createElement('canvas');
        tempCanvas.width = encodingWidth;
        tempCanvas.height = encodingHeight;
        tempCtx = tempCanvas.getContext('2d');
      }

      // Encode all frames
      for (let i = 0; i < this.capturedFrames.length; i++) {
        const frame = this.capturedFrames[i];
        const keyFrame = i % 200 === 0;  // Keyframe every 3.33 seconds (200 frames at 60 FPS)

        if (downscaled) {
          // Scale frame to tempCanvas, then create new VideoFrame
          tempCtx.drawImage(frame, 0, 0, encodingWidth, encodingHeight);
          const scaledFrame = new VideoFrame(tempCanvas, {
            timestamp: frame.timestamp,
            duration: frame.duration
          });
          this.videoEncoder.encode(scaledFrame, { keyFrame });
          scaledFrame.close();
        } else {
          this.videoEncoder.encode(frame, { keyFrame });
        }

        frame.close();  // Release VideoFrame resources
      }

      // Wait for encoding to complete
      await this.videoEncoder.flush();
      this.videoEncoder.close();

      // Finalize muxer and get the video file
      this.muxer.finalize();
      const buffer = this.muxer.target.buffer;
      this.recordedBlob = new Blob([buffer], { type: 'video/mp4' });

      // Clean up
      this.capturedFrames = [];
      this.videoEncoder = null;
      this.muxer = null;

      // Update download link
      statusElement.textContent = '';  // Clear status
      this.updateDownloadLink();

      // Start looping animation
      this.startLoopAnimation();

    } catch (e) {
      console.error('Error encoding video:', e);
      statusElement.textContent = `Encoding failed: ${e.message}`;
    }
  }

  startLoopAnimation() {
    const framesteps = 400;  // Same as recording
    const totalFrames = (this.explorer.grid.views.length - 1) * framesteps;
    const pauseFrames = 120;  // 2 second pause at 60 FPS
    let frame = 0;

    const animate = () => {
      // During main animation
      if (frame <= totalFrames) {
        const kk = Math.min(frame, totalFrames) / framesteps;
        this.drawMovieFrame(kk);
      }
      // During pause at end - keep showing last frame

      frame++;

      // Loop back to start after pause
      if (frame > totalFrames + pauseFrames) {
        frame = 0;
      }

      // Continue animation indefinitely
      this.animationTimer = requestAnimationFrame(() => animate());
    };

    animate();
  }

  updateDownloadLink() {
    const scaleElement = document.getElementById('moviescale');
    scaleElement.textContent = 'Download mp4';
    scaleElement.href = URL.createObjectURL(this.recordedBlob);
    const k = this.explorer.grid.views.length - 1;
    const view = this.explorer.grid.views[k];
    // Use QD values for full precision at deep zoom
    const coords = formatcomplex(k, view.re, view.im);
    scaleElement.download = `mandelbrot${coords}-${view.it}.mp4`;
  }

  drawMovieFrame(kk) {
    if (this.movieCtx == null) { return; }
    const k = Math.floor(kk);
    const t = kk - k;
    const sourceView = this.explorer.grid.views[k];
    const targetView = k+1 < this.explorer.grid.views.length ?
                        this.explorer.grid.views[k+1] : sourceView;
    const sourceSize = sourceView.size;
    const targetSize = targetView.size;
    const zoomRatio = targetSize / sourceSize;

    // Use zoom ratio for exponential interpolation
    const mulT = Math.pow(zoomRatio, t);
    const expT = (zoomRatio == 1.0 ? t : (mulT - 1) / (zoomRatio - 1));
    const colorT = expT * expT;
    const interpolatedSize = sourceSize * mulT;

    // Use QD-precision spline interpolation for center coordinates at deep zoom
    const sourceCenter = [sourceView.re, sourceView.im];
    const targetCenter = [targetView.re, targetView.im];

    const p0 = k > 0 ? [
        this.explorer.grid.views[k-1].re,
        this.explorer.grid.views[k-1].im] : sourceCenter;
    const p1 = sourceCenter;
    const p2 = targetCenter
    const p3 = k+2 < this.explorer.grid.views.length ? [
        this.explorer.grid.views[k+2].re,
        this.explorer.grid.views[k+2].im] : targetCenter;
    const interpolatedCenter = catmullRomSplineQD(p0, p1, p2, p3, t);

    // Clear the movie canvas with black (so unfinished pixels appear black)
    this.movieCtx.fillStyle = 'black';
    this.movieCtx.fillRect(0, 0, this.explorer.config.dimsWidth,
                            this.explorer.config.dimsHeight);

    // Draw the current frame
    const scale = sourceSize / interpolatedSize;
    const offsetX = qdToNumber(toQDScale(toQDSub(interpolatedCenter[0], sourceCenter[0]),
                          this.explorer.config.dimsWidth / sourceSize));
    const sourceHeight = sourceSize / this.explorer.config.aspectRatio;
    const offsetY = qdToNumber(toQDScale(toQDSub(sourceCenter[1], interpolatedCenter[1]),
                          this.explorer.config.dimsHeight / sourceHeight));
    this.movieCtx.save();
    this.movieCtx.imageSmoothingEnabled = true;
    this.movieCtx.imageSmoothingQuality = 'high';
    const centerX = this.explorer.config.dimsWidth / 2;
    const centerY = this.explorer.config.dimsHeight / 2;
    this.movieCtx.translate(centerX, centerY);
    this.movieCtx.scale(scale, scale);
    this.movieCtx.translate(-this.explorer.config.dimsWidth / 2 - offsetX,
                            -this.explorer.config.dimsHeight / 2 - offsetY);
    this.movieCtx.globalAlpha = 1;
    // Use pre-rendered current canvas with black unknown pixels
    this.movieCtx.drawImage(this.frameCanvases[k].current, 0, 0);

    // Blend the color palette of the next frame (unknown = black)
    if (this.frameCanvases[k].next) {
      this.movieCtx.globalAlpha = colorT;
      this.movieCtx.drawImage(this.frameCanvases[k].next, 0, 0);
    }
    this.movieCtx.restore();

    // Draw the next frame
    if (k < this.explorer.grid.views.length - 1) {
      const targetScale = targetSize / interpolatedSize;
      const targetOffsetX = qdToNumber(toQDScale(
        toQDSub(interpolatedCenter[0], targetCenter[0]),
        this.explorer.config.dimsWidth / targetSize));
      const targetHeight = targetSize / this.explorer.config.aspectRatio;
      const targetOffsetY = qdToNumber(toQDScale(
        toQDSub(targetCenter[1], interpolatedCenter[1]),
        this.explorer.config.dimsHeight / targetHeight));
      this.movieCtx.save();
      this.movieCtx.imageSmoothingEnabled = true;
      this.movieCtx.imageSmoothingQuality = 'high';
      const targetCenterX = this.explorer.config.dimsWidth / 2;
      const targetCenterY = this.explorer.config.dimsHeight / 2;
      this.movieCtx.translate(targetCenterX, targetCenterY);
      this.movieCtx.scale(targetScale, targetScale);
      this.movieCtx.translate(-this.explorer.config.dimsWidth / 2 - targetOffsetX,
                              -this.explorer.config.dimsHeight / 2 - targetOffsetY);
      this.movieCtx.globalAlpha = 1;
      // Draw prev palette version (unknown = transparent, shows lower res through)
      this.movieCtx.drawImage(this.frameCanvases[k + 1].prev, 0, 0);
      this.movieCtx.globalAlpha = colorT;
      // Draw current palette version (unknown = black)
      this.movieCtx.drawImage(this.frameCanvases[k + 1].current, 0, 0);
      this.movieCtx.restore();
    }

    // Update scale text
    if (!this.recordedBlob) {
      const currentScale = Math.pow(this.explorer.config.zoomfactor, kk);
      document.getElementById('moviescale').textContent = formatScale(currentScale);
    }
  }
}

// Distributes computation work across web workers and balances load.
class Scheduler {
  constructor(grid) {
    this.grid = grid;
    this.workers = [];
    this.boardEfforts = new Map();
    this.boardIds = new Map();  // Track board ID at each index k
    this.assignments = {};
    this.lastBalanceTime = 0;
    this.lastReportTime = 0;
    this.balanceInterval = 5000; // Move jobs to load-balance every 5 seconds
    this.reportInterval = 60000; // Report no more than once every 1 minute
    this.workerCount = Math.max(1, Math.ceil(navigator.hardwareConcurrency * 0.75) || 1);
    this.webGPUWarningShown = false;
  }

  addWorker() {
    // Show WebGPU warning once when first worker is created
    if (this.workers.length === 0 && this.grid.config.enableGPU &&
        typeof navigator.gpu === 'undefined' && !this.webGPUWarningShown) {
      console.log('WebGPU not available in this browser, falling back to CPU boards');
      this.webGPUWarningShown = true;
    }

    try {
      const workerNum = this.workers.length;
      let worker;

      // Use MockWorker if available (debug mode with 'w' flag)
      if (typeof MockWorker !== 'undefined') {
        worker = new MockWorker(workerNum);
        console.log(`Created MockWorker ${workerNum} (main thread)`);
      } else {
        // Create real web worker
        const workerCode = this.assembleWorkerCode();
        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        worker = new Worker(workerUrl, { name: `Worker ${workerNum}` });
        URL.revokeObjectURL(workerUrl);
      }

      worker.onmessage = this.handleWorkerMessage.bind(this);
      this.workers.push(worker);
      window[`worker${workerNum}`] = worker;

      // Initialize new worker with current hidden boards state
      worker.postMessage({
        type: 'setHiddenBoards',
        data: { hiddenBoards: this.grid.getHiddenViews() }
      });

      return true;
    } catch (e) {
      console.log('Failed to start webworker', e);
      return false;
    }
  }

  assembleWorkerCode() {
    const workerCode = document.getElementById('workerCode');
    const mathCode = document.getElementById('mathCode');
    const workerStart = document.getElementById('workerStart');
    return '// Linefeeds to align line numbers with HTML.\n' +
           ''.padStart(lastScriptLineNumber, '\n') +
           '// <script id="workerCode">' +
           workerCode.textContent +
           '// <\/script>\n' +
           '// <script id="mathCode">' +
           mathCode.textContent +
           '// <\/script>\n' +
           '// <script id="workerStart">' +
           workerStart.textContent +
           '// <\/script>\n';
  }

  assignBoardToWorker(k, size, reQD, imQD, config, id, inheritedData = null) {
    let [workerNumber, minLoad] = this.findLeastLoadedWorker();
    if (workerNumber == -1 || (minLoad > 0 && this.workers.length < this.workerCount)) {
      if (this.addWorker()) {
        workerNumber = this.workers.length - 1;
      }
    }
    const worker = this.workers[workerNumber];
    // Initial effort estimate: dimsArea × base_effort(100) × zoom_factor
    // Deep zoom uses QD boards which are ~17% slower (effort=117 vs 100)
    const estimatedWork = config.dimsArea * ((size / config.dimsWidth < 1e-15) ? 117 : 100);
    this.boardEfforts.set(k, estimatedWork);
    this.boardIds.set(k, id);  // Track which board ID is at this index
    this.assignments[k] = workerNumber;

    // Ensure QD coordinates are properly formatted
    reQD = toQD(reQD);
    imQD = toQD(imQD);

    if (!isFinite(size)) {
      console.warn(`Board ${k}: non-finite size`, size);
    }
    const message = {
      type: 'addBoard',
      data: {
        k,
        size,
        reQD,
        imQD,
        config: {
          dimsArea: config.dimsArea,
          dimsWidth: config.dimsWidth,
          dimsHeight: config.dimsHeight,
          aspectRatio: config.aspectRatio,
          exponent: config.exponent,
          enableGPU: config.enableGPU,
          forceBoard: config.forceBoard,
          debug: config.debug
        },
        id,
        workerNumber,
        inheritedData
      }
    };
    const transfers = [];
    if (inheritedData && inheritedData.packed) {
      if (inheritedData.dIndices) transfers.push(inheritedData.dIndices.buffer);
      if (inheritedData.cIndices) transfers.push(inheritedData.cIndices.buffer);
      if (inheritedData.cP) transfers.push(inheritedData.cP.buffer);
      if (inheritedData.cZ) transfers.push(inheritedData.cZ.buffer);
      if (inheritedData.ranges) transfers.push(inheritedData.ranges.buffer);
      if (inheritedData.knownMask) transfers.push(inheritedData.knownMask.buffer);
    }
    if (transfers.length > 0) {
      worker.postMessage(message, transfers);
    } else {
      worker.postMessage(message);
    }
  }

  // Remove board at index k. If expectedId is provided, only remove if the
  // current board at k has that ID. This prevents removing a newer board
  // when an old view tries to clean up.
  removeBoardFromWorker(k, expectedId = null) {
    // If expectedId is provided, verify it matches before removing
    if (expectedId !== null && this.boardIds.get(k) !== expectedId) {
      // Board at this index has a different ID - don't remove it
      return;
    }

    this.boardEfforts.set(k, 0);
    this.boardIds.delete(k);
    this.workers.forEach(worker => {
      worker.postMessage({
        type: 'removeBoard',
        data: { k }
      });
    });
  }

  setFocusedBoard(k) {
    this.workers.forEach(worker => {
      worker.postMessage({
        type: 'setFocusedBoard',
        data: { k }
      });
    });
  }

  setHiddenBoards(hiddenBoards) {
    this.workers.forEach(worker => {
      worker.postMessage({
        type: 'setHiddenBoards',
        data: { hiddenBoards }
      });
    });
  }

  // Debug method: check for orphan boards (boards without matching views).
  // Call this after stableViews cleanup to detect board management bugs.
  checkForOrphanBoards(views) {
    const activeViewIds = new Set();
    for (const view of views) {
      if (view && view.id !== undefined) {
        activeViewIds.add(view.id);
      }
    }

    let orphanCount = 0;
    for (const [k, boardId] of this.boardIds.entries()) {
      if (!activeViewIds.has(boardId)) {
        console.warn(`Orphan board at k=${k} with id=${boardId} - no matching active view`);
        orphanCount++;
      }
    }

    if (orphanCount > 0) {
      console.warn(`Found ${orphanCount} orphan board(s). ` +
        `Active views: ${views.length}, tracked boards: ${this.boardIds.size}`);
    }
  }

  pauseComputation(pause) {
    this.workers.forEach(worker => worker.postMessage({ type: 'pause', data: { pause } }));
  }

  handleWorkerMessage(e) {
    const { type, data } = e.data;
    const workerIndex = this.workers.indexOf(e.target);

    switch (type) {
      case 'log':
        console.log(`Worker ${workerIndex}: ${data}`);
        break;
      case 'boardCreated':
        // GPU boards are now transferable via serialization, no special tracking needed
        break;
      case 'iterations':
        this.grid.updateViewFromWorkerResult(data.k, data, workerIndex);
        // fallthrough
      case 'update':
        if ('boardEffort' in data) { this.boardEfforts.set(data.k, data.boardEffort); }
        this.checkAndBalance(); // Check if we need to balance the load
        explorer.checkAllViewsComplete();
        break;
      case 'downloadTransfer':
        this.handleDownloadTransfer(data, workerIndex);
        break;
    }
  }

  checkAndBalance() {
    // Only apply load balancing periodically.
    const now = Date.now();
    if (now - this.lastBalanceTime < this.balanceInterval) { return; }
    this.lastBalanceTime = now;

    const workerLoads = this.workers.map((_, index) => this.getWorkerLoad(index));
    const lowEffort = Math.min(...workerLoads);
    const highEffort = Math.max(...Array.from(this.boardEfforts.values()));

    if (lowEffort * 2 < highEffort) {
      const transferCandidates = [];
      const sortedLoad = workerLoads
        .map((load, index) => [index, load])
        .sort((a, b) => b[1] - a[1]);
      for (let [workerIndex, load] of sortedLoad) {
        if (load > 2 * lowEffort) {
          const workerBoards = this.getWorkerBoards(workerIndex);
          if (workerBoards.length > 1) {
            // All boards are transferable now (GPU boards support serialization)
            const sortedBoards = workerBoards.sort(
                (a, b) => this.boardEfforts.get(b) + b/1000 - this.boardEfforts.get(a) - a/1000);
            if (now - this.lastReportTime > this.reportInterval) {
              console.log(this.report());
              this.lastReportTime = now;
            }
            transferCandidates.push(sortedBoards[1]);
            break;
          }
        }
      }
      if (transferCandidates.length > 0) {
        this.requestTransfers(transferCandidates);
      }
    }
  }

  report() {
    if (!this.workers.length) { return 'no workers'; }
    const workerLoads = this.workers.map(() => 0);
    const workerBoards = this.workers.map(() => []);
    for (const [boardK, workerIndex] of Object.entries(this.assignments)) {
      const effort = this.boardEfforts.get(parseInt(boardK));
      if (effort) {
        workerBoards[workerIndex].push([parseInt(boardK), effort]);
        workerLoads[workerIndex] += effort;
      }
    }
    let result = '';
    for (let i = 0; i < workerLoads.length; i++) {
      result += `worker ${i} (load ${workerLoads[i]}): `;
      workerBoards[i].sort((a, b) => b[1] + b[0]/1000 - a[1] - a[0]/1000);
      for (let j = 0; j < workerBoards[i].length; j++) {
        result += `${workerBoards[i][j][0]}->${workerBoards[i][j][1]} `;
      }
      result += '\n';
    }
    return result;
  }

  findLeastLoadedWorker() {
    if (!this.workers.length) { return [-1, 0]; }
    const workerLoads = new Array(this.workers.length).fill(0);
    for (const [boardK, workerIndex] of Object.entries(this.assignments)) {
      workerLoads[workerIndex] += this.boardEfforts.get(parseInt(boardK)) || 0;
    }
    const minLoad = Math.min(...workerLoads);
    return [workerLoads.indexOf(minLoad), minLoad];
  }

  getWorkerLoad(workerIndex) {
    return Object.entries(this.assignments)
      .filter(([_, assignedWorker]) => assignedWorker === workerIndex)
      .reduce((sum, [k, _]) => sum + (this.boardEfforts.get(parseInt(k)) || 0), 0);
  }

  getWorkerBoards(workerIndex) {
    return Object.entries(this.assignments)
      .filter(([k, assignedWorker]) =>
           this.boardEfforts.get(parseInt(k)) > 0 && assignedWorker === workerIndex)
      .map(([k, _]) => parseInt(k));
  }

  requestTransfers(boardKeys) {
    // Group transfer requests by worker
    for (const [workerIndex, worker] of this.workers.entries()) {
      const workerBoards = boardKeys.filter(k => this.assignments[k] === workerIndex);
      if (workerBoards.length > 0) {
        worker.postMessage({
          type: 'requestTransfer',
          data: { boardKeys: workerBoards }
        });
      }
    }
  }

  handleDownloadTransfer(data, sourceWorkerIndex) {
    const { transferredBoards } = data;
    for (const boardData of transferredBoards) {
      // Remove the board from its original worker
      delete this.assignments[boardData.k];

      // Find the least loaded worker and assign the board to it
      const [targetWorkerIndex, minLoad] = this.findLeastLoadedWorker();
      this.uploadTransferredBoard(boardData, targetWorkerIndex);
      console.log(`transferred ${boardData.type} ${boardData.k} ` +
                  `from worker ${sourceWorkerIndex} ` +
                  `to ${targetWorkerIndex} (load ${minLoad})`);
    }
  }

  uploadTransferredBoard(boardData, targetWorkerIndex) {
    // Send the board to its new worker
    this.workers[targetWorkerIndex].postMessage({
      type: 'uploadTransfer',
      data: { boardData }
    });

    // Update assignments and worker loads
    this.assignments[boardData.k] = targetWorkerIndex;
  }
}

// Computes and displays iteration orbits when hovering over points.
class OrbitComputer {
  constructor(explorer) {
    this.explorer = explorer;
    this.orbitinterval = null;
    this.orbittimeout = null;
  }

  updateOrbit(k, j, target) {
    this.stopOrbitProcess();
    const orb = [];

    const updateorbit = () => {
      const [neworb, cyc, ongoing, title] = this.calculateOrbit(k, j, orb);
      this.displayOrbit(k, neworb, cyc, target, title, orb.length > 0);
      orb.push(...neworb);
      if (!ongoing) { this.stopOrbitInterval(); }
      return ongoing;
    };

    if (updateorbit()) {
      this.orbitinterval = setInterval(updateorbit, 53);
    }
  }

  stopOrbitInterval() {
    if (this.orbitinterval) {
      clearInterval(this.orbitinterval);
      this.orbitinterval = null;
    }
  }

  stopOrbitProcess() {
    this.stopOrbitInterval();
    if (this.orbittimeout) {
      clearTimeout(this.orbittimeout);
      this.orbittimeout = null;
    }
  }

  calculateOrbit(k, j, oldOrb) {
    let cyc = [];
    let orb = [];
    let ongoing = false;
    let title = '';
    let view = this.explorer.grid.views[k];

    if (view && j >= 0 && j < this.explorer.config.dimsArea) {
      let c = view.currentc(j);  // Returns QD complex format (8 elements)
      let z = view.currentz(j);  // Returns QD complex format (8 elements)

      // Calculate a further orbit beyond the old orbit.
      // Orbits now use 8 elements per point (QD complex format)
      let finished = Math.max(view.currentp(j) || 0, Math.abs(view.nn[j] || 0));
      let whole = Math.min(finished || Math.max(view.it, 8));
      let more = Math.min(whole - oldOrb.length / 8, 53);
      if (oldOrb.length) {
        let s = oldOrb.slice(oldOrb.length - 8);
        orb = this.suborbit(s, c, more + 1);
        orb.splice(0, 8);
      } else {
        orb = this.suborbit(c, c, more);
      }
      if (!finished || (orb.length + oldOrb.length) / 8 < finished) {
        ongoing = true;
      }
      // Calculate a cycle and any messages
      // c is QD complex format: [r0, r1, r2, r3, i0, i1, i2, i3]
      // Use full QD precision (4 components each) to avoid discretization at deep zoom
      title = 'c=' +
        formatcomplex(k, [c[0], c[1], c[2], c[3]], [c[4], c[5], c[6], c[7]])
        .replaceAll('-', '\u2212');
      if (view.nn[j]) {
        if (view.nn[j] > 0) {
          title += MSG.diverges_in_ + view.nn[j];
        } else {
          let period = fibonacciPeriod(view.currentp(j));
          if (period == 1) {
            title += MSG.converges_after_ + formatLargeInt(view.currentp(j));
          } else {
            const iters = formatLargeInt(view.currentp(j));
            const periodStr = formatLargeInt(period);
            title += MSG.after_ + iters + MSG.period_ + periodStr;
          }
          let clen = fibonacciPeriod(view.currentp(j));
          // z is already in QD complex format (8 elements)
          cyc = z ? this.suborbit(z, c, clen) : [];
        }
      } else {
        ongoing = true;
      }
    }
    return [orb, cyc, ongoing, title];
  }

  displayOrbit(k, orb, cyc, target, title, preserve) {
    // Don't set title if the zoom number's custom tooltip is showing
    const zoomnum = target.querySelector('.zoomnum');
    const isZoomnumHovered = zoomnum && zoomnum.matches(':hover');
    if (!isZoomnumHovered) {
      target.setAttribute('title', title);
    }
    if (!preserve) {
      this.explorer.grid.clearseq(k);
    }
    this.showseq(k, orb, 'yellow');
    this.showseq(k, cyc, 'red');

    const orbitonallboards = () => {
      for (let i = 0; i < this.explorer.grid.views.length; i++) {
        if (!this.explorer.grid.hiddencanvas(i) && i != k) {
          if (!preserve) {
            this.explorer.grid.clearseq(i);
          }
          this.showseq(i, orb, 'yellow');
          this.showseq(i, cyc, 'red');
        }
      }
    };
    this.orbittimeout = setTimeout(orbitonallboards, 1);
  }

  suborbit(z, c, len) {
    // z and c are in QD complex format: [r0, r1, r2, r3, i0, i1, i2, i3]
    let r = [z[0], z[1], z[2], z[3]];
    let j = [z[4], z[5], z[6], z[7]];
    const cr = [c[0], c[1], c[2], c[3]];
    const cj = [c[4], c[5], c[6], c[7]];

    // Result stores 8 elements per point (QD complex format)
    let result = [r[0], r[1], r[2], r[3], j[0], j[1], j[2], j[3]];
    while (result.length < len * 8) {
      let j2 = toQDSquare(j);
      let ja = toQDMul(toQDDouble(r), j);
      let r2 = toQDSquare(r);
      let ra = toQDSub(r2, j2);
      for (let ord = 2; ord < this.explorer.config.exponent; ord++) {
        let rt = toQDSub(toQDMul(r, ra), toQDMul(j, ja));
        ja = toQDAdd(toQDMul(r, ja), toQDMul(j, ra));
        ra = rt;
      }
      r = toQDAdd(ra, cr);
      j = toQDAdd(ja, cj);
      result.push(r[0], r[1], r[2], r[3], j[0], j[1], j[2], j[3]);
    }
    return result;
  }

  showseq(k, seq, color) {
    if (k >= this.explorer.grid.views.length) { return; }
    const overlay = this.explorer.grid.overlay(k);
    if (!overlay) { return; }
    let ctx = overlay.getContext('2d');
    ctx.fillStyle = color;
    // Use QD values for full precision
    const view = this.explorer.grid.views[k];
    const s = view.size;
    const crQD = view.re;
    const cjQD = view.im;
    // seq is in QD complex format: 8 elements per point
    for (let i = 0; i < seq.length; i += 8) {
      let r = [seq[i], seq[i+1], seq[i+2], seq[i+3]];
      let j = [seq[i+4], seq[i+5], seq[i+6], seq[i+7]];
      let x = (qdToNumber(toQDSub(r, crQD)) / s + 0.5) * this.explorer.config.dimsWidth;
      const sHeight = s / this.explorer.config.aspectRatio;
      let y = (qdToNumber(toQDSub(cjQD, j)) / sHeight + 0.5) * this.explorer.config.dimsHeight;
      const w = this.explorer.config.dimsWidth;
      const h = this.explorer.config.dimsHeight;
      if (x >= 0 && y >= 0 && x < w && y < h) {
        ctx.beginPath();
        ctx.arc(x, y, 1 * this.explorer.config.pixelRatio, 0, 2 * Math.PI, false);
        ctx.fill();
      }
    }
  }
}

// Coordinates progressive canvas redraws as computation results arrive.
class RedrawProcess {
  constructor(explorer) {
    this.grid = explorer.grid;
    this.timer = null;
  }
  start() {
    this.stop();  // Ensure any existing cycle is stopped
    // Get current views and sort order (visible views first, then by index descending)
    this.canvasOrder = this.grid.views.map((b, i) => i).sort(
       (a, b) => (this.grid.hiddencanvas(a) * 1 - this.grid.hiddencanvas(b) * 1)
                 * this.grid.views.length + (b - a));
    this.drawNext();
  }
  stop() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
  drawNext() {
    if (this.canvasOrder.length) {
      const index = this.canvasOrder.shift();
      const view = this.grid.views[index];  // Always get current view from grid
      const canvas = this.grid.canvas(index);
      if (canvas && view) {
        const ctx = canvas.getContext('2d');
        view.draw(ctx);
      }
      this.timer = setTimeout(() => this.drawNext(), 0);
    } else {
      this.stop();
    }
  }
}

// Utility functions

// Check if any center points from oldCenters are missing in newCenters.
// Used to determine when to push to browser history (for back button support).
function centersWereLost(oldCenters, newCenters) {
  if (!oldCenters) return false;
  if (oldCenters === newCenters) return false;

  // Parse centers into arrays of coordinate strings
  const oldParts = oldCenters.split(',').filter(s => s.length > 0);
  const newParts = newCenters.split(',').filter(s => s.length > 0);

  // If old had more centers, some were lost
  if (oldParts.length > newParts.length) return true;

  // Check if all old centers are present in new (in order, as prefix)
  // This handles the case of zooming deeper (adding centers) vs clicking elsewhere
  for (let i = 0; i < oldParts.length; i++) {
    if (i >= newParts.length || oldParts[i] !== newParts[i]) {
      return true;
    }
  }

  return false;
}

// Format zoom level for URL (z parameter) - compact scientific notation
// Strips trailing zeros: 5.00e+3 → 5e3, 1.50e+10 → 1.5e10
function formatZoom(z) {
  let s = z.toExponential(2);
  // Strip trailing zeros from mantissa and unnecessary + in exponent
  return s.replace(/\.?0+e/, 'e').replace('e+', 'e').replace('e0$', '');
}

// Format scale for human-readable display (e.g., "2.5x", "100x", "5.25e+25")
function formatScale(scale) {
  if (scale < 10) {
    return +scale.toFixed(1) + 'x';
  } else if (scale < 100000) {
    return +scale.toFixed(0) + 'x';
  } else {
    return scale.toExponential(2);
  }
}

function toSimpleFraction(decimal, maxDenominator = 100) {
  // Use continued fractions to find the best rational approximation
  // Returns [numerator, denominator]
  let bestNum = 1, bestDen = 1;
  let bestError = Math.abs(decimal - 1);

  // Continued fractions algorithm
  let h1 = 1, h2 = 0;
  let k1 = 0, k2 = 1;
  let x = decimal;

  for (let i = 0; i < 20; i++) {  // Limit iterations
    const a = Math.floor(x);
    const h = a * h1 + h2;
    const k = a * k1 + k2;

    if (k > maxDenominator) break;

    const error = Math.abs(decimal - h/k);
    if (error < bestError) {
      bestNum = h;
      bestDen = k;
      bestError = error;
    }

    if (error < 1e-10) break;  // Close enough

    x = 1 / (x - a);
    h2 = h1; h1 = h;
    k2 = k1; k1 = k;
  }

  return [bestNum, bestDen];
}

function formatcomplex(k, re, im) {
  const view = explorer.grid.views[k];
  const pix = view.pixelSize;
  let digits = Math.max(0, -Math.floor(Math.log10(pix)));

  // Use BigInt-based conversion for exact decimal output
  const reQD = toQD(re);
  const imQD = toQD(im);

  let rd = qdToDecimalString(reQD, digits);
  let id = qdToDecimalString(imQD, digits);

  let rs = reQD[0] < 0.0 ? '-' : '+';
  let is = imQD[0] < 0.0 ? '-' : '+';

  // Omit zero terms from complex number
  return ((rs + rd + is + id + 'i').
      replace(/\+0i$/, '').replace(/^\+0(?=[-+])/, '').replace(/^\+/, ''));
}

function formatLargeInt(i) {
  // Put a comma or period between thousands.
  return Intl.NumberFormat().format(i);
}

function hclColor(h, c, l) {
  // Normalize hue to be between 0 and 360 degrees
  // Chroma and Luminance should be between 0 and 100.
  h = h % 360;
  if (h < 0) h += 360;
  c = Math.min(Math.max(c, 0), 100);
  l = Math.min(Math.max(l, 0), 100);

  // Convert to radians
  const hRad = h * Math.PI / 180;

  // Constants for conversion
  const u = Math.cos(hRad) * c;
  const v = Math.sin(hRad) * c;

  // Direct conversion from HCL to RGB
  let r = l + 0.09551990792716 * u + 0.05406649830715 * v;
  let g = l - 0.03947567534454 * u - 0.01829165033556 * v;
  let b = l - 0.19638676772419 * u - 0.45388640918783 * v;

  // Apply gamma correction and convert to eight-bit value
  [r, g, b] = [r, g, b].map((x) => {
    return intcolor(gammaCorrect(x / 100));
  });
  return `rgb(${r},${g},${b})`
}

function gammaCorrect(channel) {
  if (channel <= 0.0031308) {
    return 12.92 * channel;
  } else {
    return 1.055 * Math.pow(channel, 1/2.4) - 0.055;
  }
}

// Converts normalized [0,1] float to 8-bit color string.
function intcolor(n) {
  if (n <= 0) { return "0"; }
  if (n >= 1) { return "255"; }
  return (n * 255).toString(10);
}

// Lineweaver-Burk estimate for how many pixels will be black
function estimateLimit(data) {
  // Transform data: x becomes 1/x
  const transformedData = data.map(point => ({
    x: 1 / (point.x ** 0.75),
    y: point.y,
    weight: point.weight || 1  // Default weight to 1 if not provided
  }));

  // Calculate weighted means
  let sumWeights = 0;
  let sumWeightedX = 0;
  let sumWeightedY = 0;

  for (let point of transformedData) {
    sumWeights += point.weight;
    sumWeightedX += point.weight * point.x;
    sumWeightedY += point.weight * point.y;
  }

  const meanX = sumWeightedX / sumWeights;
  const meanY = sumWeightedY / sumWeights;

  // Calculate slope and intercept
  let numerator = 0;
  let denominator = 0;
  for (let point of transformedData) {
    numerator += point.weight * (point.x - meanX) * (point.y - meanY);
    denominator += point.weight * Math.pow(point.x - meanX, 2);
  }
  const slope = numerator / denominator;
  const intercept = meanY - slope * meanX;

  // The intercept is our estimate of the limit as 1/x approaches 0 (i.e., as x approaches infinity)
  return intercept;
}

// Under Puppeteer, use 0 so worker blob has no line padding (for coverage alignment).
var lastScriptLineNumber = navigator.webdriver ? 0 :
  new Error().stack.match(/:(\d+)/)[1] | 0;
</script>
<script id="workerCode">
// Constants
const MAX_CHAOTIC_ITERATIONS = 100000;

// Helper function to check debug flags
function hasDebugFlag(config, flag) {
  const debug = config?.debug;
  if (!debug) return false;
  const parts = debug.split(',').map(f => f.trim());
  return parts.some(p => p === flag || p.startsWith(flag + '='));
}

// Utility class for managing precomputed pixel data inherited from parent views.
// Used by all board types to skip computation for pixels known from parent.
// Uses TypedArrays for efficient storage of pending data.
class PrecomputedPoints {
  constructor(inheritedData) {
    // Track which pixels are pre-known (for excluding from compute)
    this.knownPixels = new Set();
    this.knownMask = null;
    this.knownCount = 0;
    // Map<iter, {dStart, dCount, cStart, cCount}>
    this.rangeMap = new Map();

    if (!inheritedData) {
      this.dIndices = new Uint32Array(0);
      this.cIndices = new Uint32Array(0);
      this.cP = new Uint32Array(0);
      this.cZ = new Float64Array(0);
      this.zStride = 2;
      return;
    }

    if (inheritedData.packed) {
      this.dIndices = inheritedData.dIndices || new Uint32Array(0);
      this.cIndices = inheritedData.cIndices || new Uint32Array(0);
      this.cP = inheritedData.cP || new Uint32Array(0);
      this.cZ = inheritedData.cZ || new Float64Array(0);
      this.zStride = inheritedData.zStride || 2;
      this.knownMask = inheritedData.knownMask || null;
      this.knownCount = this.dIndices.length + this.cIndices.length;

      const ranges = inheritedData.ranges || new Uint32Array(0);
      for (let i = 0; i + 4 < ranges.length; i += 5) {
        const iter = ranges[i];
        this.rangeMap.set(iter, {
          dStart: ranges[i + 1],
          dCount: ranges[i + 2],
          cStart: ranges[i + 3],
          cCount: ranges[i + 4]
        });
      }
      return;
    }

    const diverged = inheritedData.diverged || [];
    const converged = inheritedData.converged || [];

    // Sort to ensure contiguous storage per iteration
    // (Use stable sort if preserving index order matters, but here it doesn't)
    diverged.sort((a, b) => a.iter - b.iter);
    converged.sort((a, b) => a.iter - b.iter);

    // Allocate storage
    this.dIndices = new Uint32Array(diverged.length);
    this.cIndices = new Uint32Array(converged.length);
    this.cP = new Uint32Array(converged.length);

    // Determine Z stride
    this.zStride = 2;
    if (converged.length > 0 && converged[0].z && converged[0].z.length > 2) {
      this.zStride = converged[0].z.length;
    }
    this.cZ = new Float64Array(converged.length * this.zStride);

    // Fill Diverged
    let currentIter = -1;
    let start = 0;
    for (let i = 0; i < diverged.length; i++) {
      const item = diverged[i];
      this.knownPixels.add(item.index);
      this.dIndices[i] = item.index;

      if (item.iter !== currentIter) {
        if (currentIter !== -1) {
          this._getRange(currentIter).dCount = i - start;
        }
        currentIter = item.iter;
        start = i;
        this._getRange(currentIter).dStart = start;
      }
    }
    if (currentIter !== -1) {
      this._getRange(currentIter).dCount = diverged.length - start;
    }

    // Fill Converged
    currentIter = -1;
    start = 0;
    for (let i = 0; i < converged.length; i++) {
      const item = converged[i];
      this.knownPixels.add(item.index);
      this.cIndices[i] = item.index;
      this.cP[i] = item.p;
      
      const zOffset = i * this.zStride;
      const zLen = Math.min(this.zStride, item.z ? item.z.length : 0);
      for (let k = 0; k < zLen; k++) {
        this.cZ[zOffset + k] = item.z[k];
      }

      if (item.iter !== currentIter) {
        if (currentIter !== -1) {
          this._getRange(currentIter).cCount = i - start;
        }
        currentIter = item.iter;
        start = i;
        this._getRange(currentIter).cStart = start;
      }
    }
    if (currentIter !== -1) {
      this._getRange(currentIter).cCount = converged.length - start;
    }
    this.knownCount = this.knownPixels.size;
  }

  _getRange(iter) {
    if (!this.rangeMap.has(iter)) {
      this.rangeMap.set(iter, { dStart: 0, dCount: 0, cStart: 0, cCount: 0 });
    }
    return this.rangeMap.get(iter);
  }

  isPrecomputed(index) {
    if (this.knownMask) {
      return this.knownMask[index] === 1;
    }
    return this.knownPixels.has(index);
  }

  getPrecomputedCount() {
    if (this.knownMask) {
      return this.knownCount;
    }
    return this.knownPixels.size;
  }

  // Get count of pending (not yet reported) precomputed points
  getPendingCount() {
    let count = 0;
    for (const range of this.rangeMap.values()) {
      count += range.dCount + range.cCount;
    }
    return count;
  }

  // Helper to reconstruct objects from TypedArrays
  _extractData(range) {
    const diverged = [];
    if (range.dCount > 0) {
      for (let i = 0; i < range.dCount; i++) {
        diverged.push(this.dIndices[range.dStart + i]);
      }
    }

    const converged = [];
    if (range.cCount > 0) {
      for (let i = 0; i < range.cCount; i++) {
        const idx = range.cStart + i;
        const z = new Array(this.zStride);
        for (let k = 0; k < this.zStride; k++) {
          z[k] = this.cZ[idx * this.zStride + k];
        }
        converged.push({
          index: this.cIndices[idx],
          z: z,
          p: this.cP[idx]
        });
      }
    }
    return { diverged, converged };
  }

  // Called each iteration to inject pending reports into changeList.
  // Reports pixels that completed at this iteration count.
  flushAtIteration(iter, board) {
    const range = this.rangeMap.get(iter);
    if (!range) return;

    const { diverged, converged } = this._extractData(range);

    // Queue the changes for reporting to main thread
    // Note: diverged is just indices (nn), converged is objects (vv)
    board.queueChanges({
      iter,
      nn: diverged,
      vv: converged
    });

    // Update board's internal counters
    board.di += diverged.length;
    board.un -= diverged.length + converged.length;

    // Mark pixels as done in nn[]
    for (const idx of diverged) {
      board.nn[idx] = iter;
    }
    for (const c of converged) {
      board.nn[c.index] = -iter;
    }

    this.rangeMap.delete(iter);
  }

  // Get and remove pending reports for a specific iteration.
  // Returns {diverged: [...], converged: [...]} or null if none.
  // Does NOT update board counters - caller is responsible for that.
  extractAtIteration(iter) {
    const range = this.rangeMap.get(iter);
    if (!range) return null;
    
    const data = this._extractData(range);
    this.rangeMap.delete(iter);
    
    // Consumers expect {diverged: [indices], converged: [objects]}
    // _extractData provides exactly this.
    return data;
  }

  // Get all iterations that have pending reports, optionally below maxIter.
  getPendingIterations(maxIter = null) {
    const keys = Array.from(this.rangeMap.keys());
    const filtered = maxIter === null ? keys : keys.filter(iter => iter < maxIter);
    return filtered.sort((a, b) => a - b);
  }

  // Extract and remove ALL pending reports below maxIter.
  extractBelowIteration(maxIter) {
    const iters = this.getPendingIterations(maxIter);
    if (iters.length === 0) return null;

    const combined = { diverged: [], converged: [] };
    for (const iter of iters) {
      const range = this.rangeMap.get(iter);
      const data = this._extractData(range);
      
      for (const item of data.diverged) combined.diverged.push(item);
      for (const item of data.converged) combined.converged.push(item);
      
      this.rangeMap.delete(iter);
    }
    return combined.diverged.length > 0 || combined.converged.length > 0 ? combined : null;
  }

  // Flush all pending reports up to and including maxIter.
  // Used by GPU boards that compute in batches.
  flushUpToIteration(maxIter, board) {
    // Get iterations in sorted order to maintain proper changeList ordering
    const iterations = Array.from(this.rangeMap.keys())
      .filter(iter => iter <= maxIter)
      .sort((a, b) => a - b);

    for (const iter of iterations) {
      this.flushAtIteration(iter, board);
    }
  }

  // Check if all pending reports have been flushed
  isEmpty() {
    return this.rangeMap.size === 0;
  }

  // Serialize for board transfer between workers
  serialize() {
    const diverged = [];
    const converged = [];
    
    for (const iter of this.rangeMap.keys()) {
      const range = this.rangeMap.get(iter);
      const data = this._extractData(range);
      
      for (const idx of data.diverged) {
        diverged.push({ index: idx, iter });
      }
      for (const item of data.converged) {
        converged.push({ 
          index: item.index, 
          iter, 
          z: item.z, 
          p: item.p 
        });
      }
    }
    // knownPixels is redundant as it can be rebuilt from diverged/converged
    return { diverged, converged };
  }

  // Restore from serialized state
  static fromSerialized(data) {
    if (!data) return null;
    // Constructor rebuilds everything (TypedArrays, knownPixels, rangeMap)
    // from the diverged/converged arrays
    return new PrecomputedPoints(data);
  }
}

// Abstract base class for Mandelbrot computation backends.
class Board {
  constructor(k, size, re, im, config, id, inheritedData = null) {
    this.k = k;    // Number in explorer
    // Store size as double (sufficient for scaling), coordinates as QD
    this.sizesQD = [typeof size === 'number' ? size : qdToNumber(size), toQD(re), toQD(im)];
    this.id = id;  // Random ID
    this.config = config;  // Global config

    this.it = 1;            // Current iteration
    this.un = config.dimsArea; // Unfinished pixels
    this.di = 0;            // Diverged pixels
    this.ch = 0;            // Chaotic pixels
    this.effort = 100;      // Benchmarked: 4.4 ns/px-iter (baseline)

    this.pix = this.pixelSize;
    this.epsilon = this.pix / 10;
    this.epsilon2 = this.pix * 10;

    this.lastTime = 0;      // Time last message sent out
    this.changeList = [];   // List of new data to send
    this.updateSize = 0;    // Amount of data to send

    // Initialize arrays
    this.nn = new Array(this.config.dimsArea).fill(0);
    this.pp = new Array(this.config.dimsArea).fill(0);
    this.cc = [];
    this.zz = [];
    this.bb = [];

    // Initialize precomputed points from parent view (if provided)
    this.precomputed = inheritedData ? new PrecomputedPoints(inheritedData) : null;
  }

  // Getter properties that derive from sizesQD (the authoritative source)
  // sizesQD format: [sizeDouble, reQD, imQD]
  get size() { return this.sizesQD[0]; }
  get re() { return this.sizesQD[1]; }
  get im() { return this.sizesQD[2]; }

  // Derived scalar property
  get pixelSize() { return this.size / this.config.dimsWidth; }

  async serialize() {
    return {
      type: this.constructor.name,
      k: this.k,
      sizesQD: this.sizesQD,
      id: this.id,
      config: this.config,
      it: this.it,
      un: this.un,
      di: this.di,
      ch: this.ch,
      lastTime: this.lastTime,
      changeList: this.changeList,
      updateSize: this.updateSize,
      precomputed: this.precomputed ? this.precomputed.serialize() : null
    };
  }

  compact() {
  }

  queueChanges(changes) {
    if (changes !== null) {
      this.changeList.push(changes);
      this.updateSize += changes.nn.length + changes.vv.length;
    }
  }

  static fromSerialized(serialized) {
    const subclasses = new Map([
      ['CpuBoard', CpuBoard],
      ['QDCpuBoard', QDCpuBoard],
      ['DDZhuoranBoard', DDZhuoranBoard],
      ['QDZhuoranBoard', QDZhuoranBoard],
      ['GpuBoard', GpuBoard],
      ['GpuZhuoranBoard', GpuZhuoranBoard],
      ['AdaptiveGpuBoard', AdaptiveGpuBoard]
    ]);
    const board = subclasses.get(serialized.type).fromSerialized(serialized);
    return board;
  }

  inspike(re, im) {
    // We do not iterate infinitely for chaotic points in the spike.
    // -1.401155 is the Feigenbaum point boundary
    return (im == 0.0 && re > -2.0 && re < -1.401155 &&
            this.config.exponent == 2);
  }


  unfinished() {
    // Chaotic points in the spike counted as finished after max iterations.
    const result = Math.max(0, this.un + (this.it < MAX_CHAOTIC_ITERATIONS ? 0 : -this.ch));
    return result;
  }
}

// CPU board using double precision arithmetic for shallow zoom depths.
class CpuBoard extends Board {
  constructor(k, size, re, im, config, id, inheritedData = null) {
    super(k, size, re, im, config, id, inheritedData);
    const sizeScalar = this.size;
    const reDD = qdToDD(this.re);
    const imDD = qdToDD(this.im);
    // Initialize board: cc = c values, zz = current z, bb = checkpoint z, ss = active pixel indices
    for (let y = 0; y < this.config.dimsHeight; y++) {
      const jFrac = (0.5 - (y / this.config.dimsHeight));
      const j = jFrac * (sizeScalar / this.config.aspectRatio) + imDD[0];  // Scale by height
      for (let x = 0; x < this.config.dimsWidth; x++) {
        const rFrac = ((x / this.config.dimsWidth) - 0.5);
        const r = rFrac * sizeScalar + reDD[0];  // Scale by width
        this.cc.push(r, j);
        if (this.inspike(r, j)) {
          this.ch += 1;
        }
      }
    }
    this.zz = this.cc.slice();  // Start with z = c
    this.bb = this.cc.slice();  // Initial checkpoint = c
    // Initialize active pixel list, excluding precomputed pixels
    this.ss = [];
    for (let i = 0; i < this.config.dimsArea; i++) {
      if (!this.precomputed || !this.precomputed.isPrecomputed(i)) {
        this.ss.push(i);
      }
    }
    // Note: don't adjust this.un here - it will be decremented by flushAtIteration
    // when precomputed points are flushed, which properly updates di/un together
  }

  static fromSerialized(serialized) {
    const board = new CpuBoard(
      serialized.k,
      serialized.sizesQD[0],
      serialized.sizesQD[1],
      serialized.sizesQD[2],
      serialized.config,
      serialized.id
    );

    // Override initialized values with serialized data
    Object.assign(board, serialized);

    // Restore nn values for completed pixels
    board.nn = new Array(serialized.config.dimsArea).fill(0);
    if (serialized.completedIndexes) {
      for (let i = 0; i < serialized.completedIndexes.length; i++) {
        board.nn[serialized.completedIndexes[i]] = serialized.completedNn[i];
      }
    }

    // Reconstruct sparse arrays from serialized data
    const cc = board.cc;
    board.cc = [];
    board.zz = [];
    board.bb = [];
    board.pp = [];
    for (let i = 0; i < serialized.ss.length; i++) {
      const index = serialized.ss[i];
      board.cc[index * 2] = cc[index * 2];
      board.cc[index * 2 + 1] = cc[index * 2 + 1];
      board.zz[index * 2] = serialized.zz[i * 2];
      board.zz[index * 2 + 1] = serialized.zz[i * 2 + 1];
      board.bb[index * 2] = serialized.bb[i * 2];
      board.bb[index * 2 + 1] = serialized.bb[i * 2 + 1];
      board.pp[index] = serialized.pp[i];
    }

    // Restore precomputed points state
    if (serialized.precomputed) {
      board.precomputed = PrecomputedPoints.fromSerialized(serialized.precomputed);
    }

    return board;
  }

  async serialize() {
    // Build sparse nn array for completed pixels (non-zero nn values)
    const completedIndexes = [];
    const completedNn = [];
    for (let i = 0; i < this.nn.length; i++) {
      if (this.nn[i] !== 0) {
        completedIndexes.push(i);
        completedNn.push(this.nn[i]);
      }
    }
    return {
      ...(await super.serialize()),
      ss: this.ss,
      zz: this.ss.flatMap(i => [this.zz[i*2], this.zz[i*2+1]]),
      bb: this.ss.flatMap(i => [this.bb[i*2], this.bb[i*2+1]]),
      pp: this.ss.map(index => this.pp[index]),
      completedIndexes,
      completedNn,
    }
  }

  iterate(targetIters = 1) {
    // Batch multiple iterations internally
    for (let batch = 0; batch < targetIters && this.un > 0; batch++) {
      let changes = null;
      const results = [0, 0, 0];
      let s = this.ss;    // speedy list of active pixel indices to compute
      // Update checkpoints at fibonacciPeriod intervals (returns 1 at Fibonacci points)
      if (fibonacciPeriod(this.it) == 1) {
        for (let t = 0; t < s.length; ++t) {
          let m = s[t];
          if (this.nn[m]) continue;
          this.bb[m * 2] = this.zz[m * 2];      // bb = checkpoint z position
          this.bb[m * 2 + 1] = this.zz[m * 2 + 1];
          this.pp[m] = 0;  // Reset pp (period = iter when convergence first detected)
        }
      }
      for (let t = 0; t < s.length; ++t) {
        const index = s[t];
        const computeResult = this.compute(index);
        if (computeResult !== 0) {
          if (!changes) {
            changes = { iter: this.it, nn: [], vv: [] };
          }
          if (computeResult < 0) {
            changes.vv.push({
              index: index,
              z: [this.zz[index * 2], this.zz[index * 2 + 1]],  // float64 pair
              p: this.pp[index]  // period
            });
          } else {
            changes.nn.push(index);
          }
        }
      }
      if (changes) {
        this.un -= changes.nn.length + changes.vv.length; // newly finished
        this.di += changes.nn.length; // diverged
      }
      if (s.length > this.un * 1.25) {
        this.compact();
        if (this.ss.length > this.un + this.ch) {
          // Debug: Check for overlap between ss and changes
          if (changes) {
            const ssSet = new Set(this.ss);
            const changedIndexes = new Set([...changes.nn, ...changes.vv.map(v => v.index)]);
            const overlap = [...ssSet].filter(x => changedIndexes.has(x));
            if (overlap.length > 0) {
              console.warn(`Overlap detected between ss and changes: ${overlap.length} items`);
              console.warn(`Overlap indexes: ${overlap}`);
              console.warn(`ss length: ${this.ss.length}, un: ${this.un}`);
              console.warn(`changes: nn ${changes.nn.length}, vv ${changes.vv.length}`);
            }
          }

          // Additional checks
          const uniqueSS = new Set(this.ss);
          if (uniqueSS.size !== this.ss.length) {
            console.warn(
              `Duplicate entries in ss detected. ss length: ${this.ss.length}, ` +
              `unique entries: ${uniqueSS.size}`);
          }

          const invalidIndexes = this.ss.filter(i => this.nn[i]);
          if (invalidIndexes.length > 0) {
            console.warn(
              `Found ${invalidIndexes.length} indexes in ss that are ` +
              `already marked as finished in nn`);
          }

          if (this.ss.length !== this.un + this.ch) {
            console.warn(`Mismatch between ss length (${this.ss.length}) and un (${this.un})`);
          }
          throw new Error(`excess ss ${s.length}, ${this.ss.length}, ${this.un}`);
        }
      }

      // Flush precomputed points at this iteration
      if (this.precomputed) {
        this.precomputed.flushAtIteration(this.it, this);
      }

      this.queueChanges(changes);
      this.it++;
    }
  }

  compact() {
    this.ss = this.ss.filter(i => !this.nn[i]);
  }

  compute(m) {
    if (this.nn[m]) return 0;
    const m2 = m * 2;
    const m2i = m2 + 1;
    const r = this.zz[m2];
    const j = this.zz[m2i];
    const r2 = r * r;
    const j2 = j * j;
    if (r2 + j2 > 4.0) {
      this.nn[m] = this.it;
      return 1;  // Diverged
    }
    // Mandelbrot iteration: z = z^exponent + c
    let ra = r2 - j2;
    let ja = 2 * r * j;
    for (let ord = 2; ord < this.config.exponent; ord++) {
      let rt = r * ra - j * ja;
      ja = r * ja + j * ra;
      ra = rt;
    }
    ra += this.cc[m2];
    ja += this.cc[m2i];
    this.zz[m2] = ra;
    this.zz[m2i] = ja;
    // Check convergence: compare current z to checkpoint
    const rb = this.bb[m2];
    const jb = this.bb[m2i];
    const db = Math.abs(rb - ra) + Math.abs(jb - ja);  // distance from checkpoint
    const epsilon = this.epsilon;
    const epsilon2 = this.epsilon2;
    if (db <= epsilon2) {
      if (!this.pp[m]) { this.pp[m] = this.it; }  // Record iter when first detected
      if (db <= epsilon) {
        this.nn[m] = -this.it;
        if (this.inspike(this.cc[m2], this.cc[m2i]) && this.ch > 0) {
          this.ch -= 1;
        }
        return -1;  // Converged
      }
    }
    return 0;  // Continue iterating
  }

}

// CPU board using direct QD-precision iteration (no perturbation).
// Very slow but maximally accurate - serves as ground truth for verification.
class QDCpuBoard extends Board {
  constructor(k, size, re, im, config, id, inheritedData = null) {
    super(k, size, re, im, config, id, inheritedData);
    // Override epsilon for QD precision - need much tighter thresholds
    // to avoid false convergence detection at deep zoom.
    // Base Board uses pix/10 and pix*10, but for direct QD iteration
    // we need thresholds much smaller than pixel size.
    this.epsilon = this.pix * 1e-20;   // Final convergence threshold
    this.epsilon2 = this.pix * 1e-15;  // Getting close threshold
    this.effort = 11200;  // Benchmarked: 493 ns/px-iter, 112× slower than CPU
    // Use QD-precision values from getters
    // IMPORTANT: At deep zoom (z > 1e30), double precision cannot represent
    // the pixel size or offset accurately. Must use QD precision throughout.
    const reQD = this.re;
    const imQD = this.im;
    // Pre-compute size/aspectRatio in QD precision for y offsets
    // Use toQDMul instead of toQDScale to capture error terms at deep zoom
    const aspectRecipQD = toQD(1 / this.config.aspectRatio);
    const sizeOverAspect = toQDMul(this.size, aspectRecipQD);
    // Initialize board: cc = c values (8 floats per pixel), zz = current z (8 floats per pixel)
    // bb = checkpoint z, ss = active pixel indices
    // Format: [r0, r1, r2, r3, i0, i1, i2, i3] for each complex number
    for (let y = 0; y < this.config.dimsHeight; y++) {
      const jFrac = (0.5 - (y / this.config.dimsHeight));
      // Use toQDMul instead of toQDScale to capture error terms
      const jQD = toQDAdd(imQD, toQDMul(sizeOverAspect, toQD(jFrac)));
      for (let x = 0; x < this.config.dimsWidth; x++) {
        const rFrac = ((x / this.config.dimsWidth) - 0.5);
        // Use toQDMul instead of toQDScale to capture error terms
        const rQD = toQDAdd(reQD, toQDMul(this.size, toQD(rFrac)));
        // Store c as 8 floats: [r0, r1, r2, r3, i0, i1, i2, i3]
        this.cc.push(rQD[0], rQD[1], rQD[2], rQD[3], jQD[0], jQD[1], jQD[2], jQD[3]);
        const r = rQD[0] + rQD[1] + rQD[2] + rQD[3];
        const j = jQD[0] + jQD[1] + jQD[2] + jQD[3];
        if (this.inspike(r, j)) {
          this.ch += 1;
        }
      }
    }
    this.zz = this.cc.slice();  // Start with z = c
    this.bb = this.cc.slice();  // Initial checkpoint = c
    // Initialize active pixel list, excluding precomputed pixels
    this.ss = [];
    for (let i = 0; i < this.config.dimsArea; i++) {
      if (!this.precomputed || !this.precomputed.isPrecomputed(i)) {
        this.ss.push(i);
      }
    }
    // Note: don't adjust this.un here - it will be decremented by flushAtIteration
    // when precomputed points are flushed, which properly updates di/un together
  }

  static fromSerialized(serialized) {
    const board = new QDCpuBoard(
      serialized.k,
      serialized.sizesQD[0],
      serialized.sizesQD[1],
      serialized.sizesQD[2],
      serialized.config,
      serialized.id
    );

    // Override initialized values with serialized data
    Object.assign(board, serialized);

    // Restore nn values for completed pixels
    board.nn = new Array(serialized.config.dimsArea).fill(0);
    if (serialized.completedIndexes) {
      for (let i = 0; i < serialized.completedIndexes.length; i++) {
        board.nn[serialized.completedIndexes[i]] = serialized.completedNn[i];
      }
    }

    // Reconstruct sparse arrays from serialized data (8 floats per pixel)
    const cc = board.cc;
    board.cc = [];
    board.zz = [];
    board.bb = [];
    board.pp = [];
    for (let i = 0; i < serialized.ss.length; i++) {
      const index = serialized.ss[i];
      const i8 = index * 8;
      for (let j = 0; j < 8; j++) {
        board.cc[i8 + j] = cc[i8 + j];
        board.zz[i8 + j] = serialized.zz[i * 8 + j];
        board.bb[i8 + j] = serialized.bb[i * 8 + j];
      }
      board.pp[index] = serialized.pp[i];
    }

    // Restore precomputed points state
    if (serialized.precomputed) {
      board.precomputed = PrecomputedPoints.fromSerialized(serialized.precomputed);
    }

    return board;
  }

  async serialize() {
    // Build sparse nn array for completed pixels (non-zero nn values)
    const completedIndexes = [];
    const completedNn = [];
    for (let i = 0; i < this.nn.length; i++) {
      if (this.nn[i] !== 0) {
        completedIndexes.push(i);
        completedNn.push(this.nn[i]);
      }
    }
    return {
      ...(await super.serialize()),
      ss: this.ss,
      zz: this.ss.flatMap(i => {
        const i8 = i * 8;
        return [this.zz[i8], this.zz[i8+1], this.zz[i8+2], this.zz[i8+3],
                this.zz[i8+4], this.zz[i8+5], this.zz[i8+6], this.zz[i8+7]];
      }),
      bb: this.ss.flatMap(i => {
        const i8 = i * 8;
        return [this.bb[i8], this.bb[i8+1], this.bb[i8+2], this.bb[i8+3],
                this.bb[i8+4], this.bb[i8+5], this.bb[i8+6], this.bb[i8+7]];
      }),
      pp: this.ss.map(index => this.pp[index]),
      completedIndexes,
      completedNn,
    }
  }

  iterate(targetIters = 1) {
    // Batch multiple iterations internally
    for (let batch = 0; batch < targetIters && this.un > 0; batch++) {
      let changes = null;
      let s = this.ss;    // speedy list of active pixel indices to compute
      // Update checkpoints at fibonacciPeriod intervals (returns 1 at Fibonacci points)
      if (fibonacciPeriod(this.it) == 1) {
        for (let t = 0; t < s.length; ++t) {
          let m = s[t];
          if (this.nn[m]) continue;
          const m8 = m * 8;
          for (let i = 0; i < 8; i++) {
            this.bb[m8 + i] = this.zz[m8 + i];
          }
          this.pp[m] = 0;  // Reset pp (period = iter when convergence first detected)
        }
      }
      for (let t = 0; t < s.length; ++t) {
        const index = s[t];
        const computeResult = this.compute(index);
        if (computeResult !== 0) {
          if (!changes) {
            changes = { iter: this.it, nn: [], vv: [] };
          }
          if (computeResult < 0) {
            const m8 = index * 8;
            // Preserve full QD precision (8 elements: 4 real + 4 imag)
            changes.vv.push({
              index: index,
              z: [this.zz[m8], this.zz[m8+1], this.zz[m8+2], this.zz[m8+3],
                  this.zz[m8+4], this.zz[m8+5], this.zz[m8+6], this.zz[m8+7]],
              p: this.pp[index]  // period
            });
          } else {
            changes.nn.push(index);
          }
        }
      }
      if (changes) {
        this.un -= changes.nn.length + changes.vv.length; // newly finished
        this.di += changes.nn.length; // diverged
      }
      if (s.length > this.un * 1.25) {
        this.compact();
      }

      // Flush precomputed points at this iteration
      if (this.precomputed) {
        this.precomputed.flushAtIteration(this.it, this);
      }

      this.queueChanges(changes);
      this.it++;
    }
  }

  compact() {
    this.ss = this.ss.filter(i => !this.nn[i]);
  }

  compute(m) {
    if (this.nn[m]) return 0;
    const m8 = m * 8;
    // Extract z as QD complex: [r0, r1, r2, r3] and [i0, i1, i2, i3]
    const zr = [this.zz[m8], this.zz[m8+1], this.zz[m8+2], this.zz[m8+3]];
    const zi = [this.zz[m8+4], this.zz[m8+5], this.zz[m8+6], this.zz[m8+7]];

    // Mandelbrot iteration: z = z² + c using QD precision
    // z² = (zr + zi*i)² = zr² - zi² + 2*zr*zi*i
    const zr2 = toQDSquare(zr);      // zr²
    const zi2 = toQDSquare(zi);      // zi²
    const zri = toQDMul(zr, zi);     // zr * zi

    // Check escape: |z|² > 4 using FULL QD precision comparison
    // IMPORTANT: Cannot sum components to double and compare - this loses precision
    // when |z|² ≈ 4 and differences are at 1e-34 scale. Adjacent pixels would escape
    // at the same iteration, creating vertical stripes in the output.
    // Instead, compute |z|² - 4 in QD precision and check if positive.
    const mag2QD = toQDAdd(zr2, zi2);  // |z|² in QD precision
    const diffQD = toQDSub(mag2QD, [4, 0, 0, 0]);  // |z|² - 4
    // Check if diff > 0: find first non-zero component and check its sign
    const escaped = diffQD[0] > 0 ||
      (diffQD[0] === 0 && (diffQD[1] > 0 ||
        (diffQD[1] === 0 && (diffQD[2] > 0 ||
          (diffQD[2] === 0 && diffQD[3] > 0)))));
    if (escaped) {
      this.nn[m] = this.it;
      return 1;  // Diverged
    }

    const newZr = toQDSub(zr2, zi2); // zr² - zi²
    const newZi = toQDDouble(zri);   // 2 * zr * zi

    // Add c
    const cr = [this.cc[m8], this.cc[m8+1], this.cc[m8+2], this.cc[m8+3]];
    const ci = [this.cc[m8+4], this.cc[m8+5], this.cc[m8+6], this.cc[m8+7]];
    const finalZr = toQDAdd(newZr, cr);
    const finalZi = toQDAdd(newZi, ci);

    // Store back
    this.zz[m8] = finalZr[0]; this.zz[m8+1] = finalZr[1];
    this.zz[m8+2] = finalZr[2]; this.zz[m8+3] = finalZr[3];
    this.zz[m8+4] = finalZi[0]; this.zz[m8+5] = finalZi[1];
    this.zz[m8+6] = finalZi[2]; this.zz[m8+7] = finalZi[3];

    // Check convergence: compare current z to checkpoint
    // IMPORTANT: Must compute difference in QD precision FIRST, then convert to double.
    // If we sum to double first and then subtract, we lose precision due to catastrophic
    // cancellation when z ≈ 2 (fixed point) and differences are at 1e-35 scale.
    const bbR = [this.bb[m8], this.bb[m8+1], this.bb[m8+2], this.bb[m8+3]];
    const bbI = [this.bb[m8+4], this.bb[m8+5], this.bb[m8+6], this.bb[m8+7]];
    const diffR = toQDSub(finalZr, bbR);
    const diffI = toQDSub(finalZi, bbI);
    const db = Math.abs(diffR[0] + diffR[1] + diffR[2] + diffR[3]) +
               Math.abs(diffI[0] + diffI[1] + diffI[2] + diffI[3]);
    const epsilon = this.epsilon;
    const epsilon2 = this.epsilon2;
    if (db <= epsilon2) {
      if (!this.pp[m]) { this.pp[m] = this.it; }  // Record iter when first detected
      if (db <= epsilon) {
        this.nn[m] = -this.it;
        const cR = this.cc[m8] + this.cc[m8+1] + this.cc[m8+2] + this.cc[m8+3];
        const cI = this.cc[m8+4] + this.cc[m8+5] + this.cc[m8+6] + this.cc[m8+7];
        if (this.inspike(cR, cI) && this.ch > 0) {
          this.ch -= 1;
        }
        return -1;  // Converged
      }
    }
    return 0;  // Continue iterating
  }
}

// Spatial bucket for O(1) lookup of nearby points in 2D
// Uses a grid with cell size = 2*bucketRadius to guarantee 4-bucket coverage
// Base class - subclasses implement precision-specific getF64Point and verifyAndGetDelta
class SpatialBucket {
  // Minimum bucket size to avoid f64 precision issues
  static MIN_BUCKET_SIZE = 1e-12;

  /**
   * @param {number} threadingEpsilon - L∞ distance threshold for "nearby"
   */
  constructor(threadingEpsilon) {
    this.threadingEpsilon = threadingEpsilon;
    // Clamp bucket radius to avoid f64 precision problems
    this.bucketRadius = Math.max(threadingEpsilon, SpatialBucket.MIN_BUCKET_SIZE);
    this.gridSize = 2 * this.bucketRadius;  // Grid cells are 2× radius for 4-bucket guarantee
    this.buckets = new Map();  // "bx,by" -> Set of indices
  }

  // Subclasses must override: return {re, im} as f64 for coarse bucketing
  getF64Point(i) { throw new Error("subclass must implement getF64Point"); }

  // Subclasses must override: return {deltaRe, deltaIm} if within threadingEpsilon, else null
  // Uses precision-aware subtraction to avoid catastrophic cancellation
  verifyAndGetDelta(i, j) { throw new Error("subclass must implement verifyAndGetDelta"); }

  _getBucket(re, im) {
    const bx = Math.floor(re / this.gridSize);
    const by = Math.floor(im / this.gridSize);
    return { bx, by };
  }

  _getKey(bx, by) {
    return `${bx},${by}`;
  }

  /**
   * Add point at index i to the spatial structure
   */
  add(i) {
    const pt = this.getF64Point(i);
    if (!pt) return;
    const { bx, by } = this._getBucket(pt.re, pt.im);
    const key = this._getKey(bx, by);
    if (!this.buckets.has(key)) {
      this.buckets.set(key, new Set());
    }
    this.buckets.get(key).add(i);
  }

  /**
   * Find all points within threadingEpsilon L∞ distance of point i,
   * remove them from the structure, and return [{index, deltaRe, deltaIm}, ...].
   * Uses precision-aware verification via verifyAndGetDelta.
   * Does NOT remove point i itself (it may not even be in the structure).
   */
  findAndRemoveNear(i) {
    const pt = this.getF64Point(i);
    if (!pt) return [];

    const { bx, by } = this._getBucket(pt.re, pt.im);

    // Determine which 4 buckets to check based on position within bucket
    // Since gridSize = 2*bucketRadius, checking 4 adjacent buckets guarantees
    // we find all points within bucketRadius distance
    const fracX = (pt.re / this.gridSize) - bx;
    const fracY = (pt.im / this.gridSize) - by;
    const dx = fracX < 0.5 ? -1 : 1;
    const dy = fracY < 0.5 ? -1 : 1;

    const bucketsToCheck = [
      [bx, by],
      [bx + dx, by],
      [bx, by + dy],
      [bx + dx, by + dy]
    ];

    const found = [];
    for (const [checkBx, checkBy] of bucketsToCheck) {
      const key = this._getKey(checkBx, checkBy);
      const bucket = this.buckets.get(key);
      if (!bucket) continue;

      const toRemove = [];
      for (const j of bucket) {
        if (j === i) continue;  // Don't return the query point itself

        // Use precision-aware verification
        const delta = this.verifyAndGetDelta(i, j);
        if (delta !== null) {
          found.push({ index: j, deltaRe: delta.deltaRe, deltaIm: delta.deltaIm });
          toRemove.push(j);
        }
      }

      for (const j of toRemove) {
        bucket.delete(j);
      }
      if (bucket.size === 0) {
        this.buckets.delete(key);
      }
    }

    return found;
  }

  /**
   * Remove all indices older than (less than) minIndex
   */
  removeOlderThan(minIndex) {
    for (const [key, bucket] of this.buckets) {
      for (const j of bucket) {
        if (j < minIndex) {
          bucket.delete(j);
        }
      }
      if (bucket.size === 0) {
        this.buckets.delete(key);
      }
    }
  }
}

/**
 * DDSpatialBucket - for quad-double precision points
 * Point format: [re_hi, re_lo, im_hi, im_lo]
 */
class DDSpatialBucket extends SpatialBucket {
  constructor(threadingEpsilon, getDDPoint) {
    super(threadingEpsilon);
    this.getDDPoint = getDDPoint;
  }

  getF64Point(i) {
    const p = this.getDDPoint(i);
    if (!p) return null;
    return { re: p[0] + p[1], im: p[2] + p[3] };
  }

  verifyAndGetDelta(i, j) {
    const pi = this.getDDPoint(i);
    const pj = this.getDDPoint(j);
    if (!pi || !pj) return null;

    // Proper qd subtraction to avoid catastrophic cancellation
    const deltaReQd = ddSub([pi[0], pi[1]], [pj[0], pj[1]]);
    const deltaImQd = ddSub([pi[2], pi[3]], [pj[2], pj[3]]);

    // Sum qd result to f64
    const deltaRe = deltaReQd[0] + deltaReQd[1];
    const deltaIm = deltaImQd[0] + deltaImQd[1];

    // Check L∞ distance against actual threadingEpsilon
    if (Math.max(Math.abs(deltaRe), Math.abs(deltaIm)) <= this.threadingEpsilon) {
      return { deltaRe, deltaIm };
    }
    return null;
  }
}

/**
 * QDSpatialBucket - for quad-double precision points
 * Point format: [re0, re1, re2, re3, im0, im1, im2, im3]
 */
class QDSpatialBucket extends SpatialBucket {
  constructor(threadingEpsilon, getQDPoint) {
    super(threadingEpsilon);
    this.getQDPoint = getQDPoint;
  }

  getF64Point(i) {
    const p = this.getQDPoint(i);
    if (!p) return null;
    return {
      re: p[0] + p[1] + p[2] + p[3],
      im: p[4] + p[5] + p[6] + p[7]
    };
  }

  verifyAndGetDelta(i, j) {
    const pi = this.getQDPoint(i);
    const pj = this.getQDPoint(j);
    if (!pi || !pj) return null;

    // Proper QD subtraction to avoid catastrophic cancellation
    const deltaReQD = toQDSub(
      [pi[0], pi[1], pi[2], pi[3]],
      [pj[0], pj[1], pj[2], pj[3]]
    );
    const deltaImQD = toQDSub(
      [pi[4], pi[5], pi[6], pi[7]],
      [pj[4], pj[5], pj[6], pj[7]]
    );

    // Sum QD result to f64
    const deltaRe = qdToNumber(deltaReQD);
    const deltaIm = qdToNumber(deltaImQD);

    // Check L∞ distance against actual threadingEpsilon
    if (Math.max(Math.abs(deltaRe), Math.abs(deltaIm)) <= this.threadingEpsilon) {
      return { deltaRe, deltaIm };
    }
    return null;
  }
}

// Reference Orbit Threading - enables robust cycle detection despite rebasing
class ReferenceOrbitThreading {
  /**
   * @param {SpatialBucket} spatialBucket - A precision-aware spatial bucket
   *   (DDSpatialBucket or QDSpatialBucket)
   */
  constructor(spatialBucket) {
    const maxCycleLength = 1e5;
    // Window size limits bucket growth
    this.windowSize = Math.min(1024, Math.floor(maxCycleLength));
    // Threading links: {next: index, deltaRe: f32, deltaIm: f32}
    this.threads = [];
    // Spatial index for finding nearby points (precision-aware)
    this.spatialBucket = spatialBucket;
  }

  /**
   * Add a new orbit point and create threading links.
   * All nearby past points are threaded to point at this new point.
   * The spatial bucket handles precision-aware distance checking and delta computation.
   */
  addPoint(currentIndex) {
    // Find and remove all nearby past points from the bucket
    // Returns [{index, deltaRe, deltaIm}, ...] with precision-aware deltas
    const nearbyPast = this.spatialBucket.findAndRemoveNear(currentIndex);

    // Add placeholder for this point's thread
    this.threads.push({next: -1, deltaRe: 0, deltaIm: 0});

    // Thread all nearby past points to this new point
    // Note: deltaRe/deltaIm are (current - past), but we want (past -> current) delta
    // So we negate the deltas returned by the bucket
    for (const match of nearbyPast) {
      this.threads[match.index] = {
        next: currentIndex,
        deltaRe: Math.fround(-match.deltaRe),  // Negate: bucket returns (query - candidate)
        deltaIm: Math.fround(-match.deltaIm)
      };
    }

    // Add this point to the bucket for future lookups
    this.spatialBucket.add(currentIndex);

    // Cleanup old entries outside the window
    if (currentIndex >= this.windowSize) {
      this.spatialBucket.removeOlderThan(currentIndex - this.windowSize);
    }
  }

  /**
   * Get thread info for iteration i
   */
  getThread(i) {
    return this.threads[i] || null;
  }

  /**
   * Manually set a thread (used for loop configuration)
   */
  setThread(i, next, deltaRe, deltaIm) {
    this.threads[i] = {
      next,
      deltaRe: Math.fround(deltaRe),
      deltaIm: Math.fround(deltaIm)
    };
  }

  get length() {
    return this.threads.length;
  }
}

// Single reference orbit perturbation method.
// Based on Zhuoran Li's 2021 approach:
// https://mathr.co.uk/blog/2021-05-14_stretching_deep_zoom.html
// Rebasing implementation follows Imagina: https://github.com/ImaginaFractal/Imagina

// Mixin that adds DD-precision reference orbit methods to any board class.
// Used by both DDZhuoranBoard (CPU) and GpuZhuoranBoard (GPU) to share
// the reference orbit computation logic.
const DDReferenceOrbitMixin = (Base) => class extends Base {
  // Initialize DD reference orbit state. Call from constructor after super().
  initDDReferenceOrbit(refC) {
    // Reference point in DD precision [r_hi, r_lo, i_hi, i_lo]
    this.refC = refC;

    // Reference orbit array - each entry is [r_hi, r_lo, i_hi, i_lo]
    this.refOrbit = [];
    this.refOrbit.push([0, 0, 0, 0]);      // Iteration 0: z = 0
    this.refOrbit.push(this.refC.slice()); // Iteration 1: z = c

    // Reference orbit state
    this.refOrbitEscaped = false;
    this.refIterations = 1;
    this.maxRefIterations = 10000;

    // Working array for DD precision operations
    this.tt = new Array(16);

    // Build threading structure
    this.rebuildDDThreading();
  }

  // Rebuild threading structure from reference orbit (for serialization restore)
  rebuildDDThreading() {
    const threadingEpsilon = 10000 * this.epsilon;
    const getDDPoint = (i) => this.refOrbit[i] || null;
    const spatialBucket = new DDSpatialBucket(threadingEpsilon, getDDPoint);
    this.threading = new ReferenceOrbitThreading(spatialBucket);
    // Add all points from reference orbit
    for (let i = 0; i <= this.refIterations; i++) {
      this.threading.addPoint(i);
    }
  }

  // DD accessor methods
  getRefReal(ref) { return ref[0] + ref[1]; }
  getRefImag(ref) { return ref[2] + ref[3]; }
  getRefOrbit(iter) { return this.refOrbit[iter]; }
  getRefOrbitLength() { return this.refOrbit.length; }
  getRefCReal() { return this.refC[0] + this.refC[1]; }
  getRefCImag() { return this.refC[2] + this.refC[3]; }

  // Compute z = ref + dz in native DDc format (4 elements)
  refDzNative(ref, dzr, dzi) {
    // ref is DD: [r_hi, r_lo, i_hi, i_lo], returns DDc with proper DD addition
    const zr = toDDAdd([ref[0], ref[1]], dzr);
    const zi = toDDAdd([ref[2], ref[3]], dzi);
    return [zr[0], zr[1], zi[0], zi[1]];
  }

  // Extend reference orbit by one iteration in DD precision
  extendReferenceOrbit() {
    const lastIndex = this.refIterations;
    const last = this.refOrbit[lastIndex];
    const tt = this.tt;

    const r1 = last[0];
    const r2 = last[1];
    const j1 = last[2];
    const j2 = last[3];

    // Check for escape
    ArddSquare(tt, 0, r1, r2);                    // rsq = r**2
    ArddSquare(tt, 2, j1, j2);                    // jsq = j**2
    ArddAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);   // d = rsq + jsq

    if (tt[4] > 1e10) {
      this.refOrbitEscaped = true;
      return;
    }

    // Compute z^n for general exponent
    ArddMul(tt, 6, 2 * r1, 2 * r2, j1, j2);       // ja = 2*r*j
    ArddAdd(tt, 8, tt[0], tt[1], -tt[2], -tt[3]); // ra = rsq - jsq

    for (let ord = 2; ord < this.config.exponent; ord++) {
      ArddMul(tt, 0, j1, j2, tt[6], tt[7]);         // j * ja
      ArddMul(tt, 2, r1, r2, tt[8], tt[9]);         // r * ra
      ArddAdd(tt, 4, -tt[0], -tt[1], tt[2], tt[3]); // rt = r*ra - j*ja
      ArddMul(tt, 0, r1, r2, tt[6], tt[7]);         // r * ja
      ArddMul(tt, 2, j1, j2, tt[8], tt[9]);         // j * ra
      ArddAdd(tt, 6, tt[0], tt[1], tt[2], tt[3]);   // ja = r*ja + j*ra
      ArddSet(tt, 8, tt[4], tt[5]);                // ra = rt
    }

    // Add c to get next z
    const newZ = [0, 0, 0, 0];
    ArddAdd(newZ, 0, tt[8], tt[9], this.refC[0], this.refC[1]);      // real part
    ArddAdd(newZ, 2, tt[6], tt[7], this.refC[2], this.refC[3]);      // imag part

    this.refOrbit.push(newZ);
    this.refIterations++;

    // Build thread-following map
    this.threading.addPoint(this.refIterations);

    // Grow array if needed
    if (this.refIterations >= this.maxRefIterations) {
      this.maxRefIterations *= 2;
    }
  }
};

// Mixin that adds QD-precision reference orbit methods to any board class.
// Used by both QDZhuoranBoard (CPU) and AdaptiveGpuBoard (GPU) to share
// the reference orbit computation logic.
const QDReferenceOrbitMixin = (Base) => class extends Base {
  // Initialize QD reference orbit state. Call from constructor after super().
  initQDReferenceOrbit(refC_qd) {
    // Reference point in QD precision [re0, re1, re2, re3, im0, im1, im2, im3]
    this.refC_qd = refC_qd;

    // QD reference orbit array - each entry is [re0, re1, re2, re3, im0, im1, im2, im3]
    this.qdRefOrbit = [
      [0, 0, 0, 0, 0, 0, 0, 0],  // Iteration 0: z = 0
      [...refC_qd]               // Iteration 1: z = c
    ];

    // Reference orbit state
    this.refOrbitEscaped = false;
    this.refIterations = 1;
    this.maxRefIterations = 10000;

    // Working array for QD precision operations
    this.tt = new Array(32);

    // Build threading structure
    this.rebuildQDThreading();
  }

  // Rebuild threading structure from reference orbit (for serialization restore)
  rebuildQDThreading() {
    const threadingEpsilon = 10000 * this.epsilon;
    const getQDPoint = (i) => this.qdRefOrbit[i] || null;
    const spatialBucket = new QDSpatialBucket(threadingEpsilon, getQDPoint);
    this.threading = new ReferenceOrbitThreading(spatialBucket);
    // Add all points from reference orbit
    for (let i = 0; i <= this.refIterations; i++) {
      this.threading.addPoint(i);
    }
  }

  // QD accessor methods
  getRefReal(ref) { return ref[0] + ref[1] + ref[2] + ref[3]; }
  getRefImag(ref) { return ref[4] + ref[5] + ref[6] + ref[7]; }
  getRefOrbit(iter) { return this.qdRefOrbit[iter]; }
  getRefOrbitLength() { return this.qdRefOrbit.length; }
  getRefCReal() { return this.refC_qd[0] + this.refC_qd[1] + this.refC_qd[2] + this.refC_qd[3]; }
  getRefCImag() { return this.refC_qd[4] + this.refC_qd[5] + this.refC_qd[6] + this.refC_qd[7]; }

  // Compute z = ref + dz in native QDc format (8 elements)
  refDzNative(ref, dzr, dzi) {
    // ref is QD: [r0,r1,r2,r3, i0,i1,i2,i3], returns QDc
    const zrQD = toQDAdd([ref[0], ref[1], ref[2], ref[3]], [dzr, 0, 0, 0]);
    const ziQD = toQDAdd([ref[4], ref[5], ref[6], ref[7]], [dzi, 0, 0, 0]);
    return [...zrQD, ...ziQD];
  }

  // Extend reference orbit by one iteration in QD precision
  extendReferenceOrbit() {
    const last = this.qdRefOrbit[this.refIterations];
    const rr = [last[0], last[1], last[2], last[3]];
    const ri = [last[4], last[5], last[6], last[7]];
    const tt = this.tt;

    // Check for escape using sum of QD components
    const rSum = rr[0] + rr[1] + rr[2] + rr[3];
    const iSum = ri[0] + ri[1] + ri[2] + ri[3];
    const mag = rSum * rSum + iSum * iSum;
    if (mag > 1e10) {
      this.refOrbitEscaped = true;
      return;
    }

    // Compute z^n for general exponent
    // z^2 = (zr + zi*i)^2 = zr^2 - zi^2 + 2*zr*zi*i
    ArqdSquare(tt, 0, rr[0], rr[1], rr[2], rr[3]);   // rsq = r^2
    ArqdSquare(tt, 4, ri[0], ri[1], ri[2], ri[3]);   // jsq = j^2
    ArqdMul(tt, 8, 2*rr[0], 2*rr[1], 2*rr[2], 2*rr[3],
      ri[0], ri[1], ri[2], ri[3]);  // ja = 2*r*j
    ArqdAdd(tt, 16, tt[0], tt[1], tt[2], tt[3],
      -tt[4], -tt[5], -tt[6], -tt[7]);     // ra = rsq - jsq

    for (let ord = 2; ord < this.config.exponent; ord++) {
      ArqdMul(tt, 0, ri[0], ri[1], ri[2], ri[3],
        tt[8], tt[9], tt[10], tt[11]);         // j * ja
      ArqdMul(tt, 4, rr[0], rr[1], rr[2], rr[3],
        tt[16], tt[17], tt[18], tt[19]);       // r * ra
      ArqdAdd(tt, 12, -tt[0], -tt[1], -tt[2], -tt[3],
        tt[4], tt[5], tt[6], tt[7]);      // rt = r*ra - j*ja
      ArqdMul(tt, 0, rr[0], rr[1], rr[2], rr[3],
        tt[8], tt[9], tt[10], tt[11]);         // r * ja
      ArqdMul(tt, 4, ri[0], ri[1], ri[2], ri[3],
        tt[16], tt[17], tt[18], tt[19]);       // j * ra
      ArqdAdd(tt, 8, tt[0], tt[1], tt[2], tt[3],
        tt[4], tt[5], tt[6], tt[7]);           // ja = r*ja + j*ra
      ArqdSet(tt, 16, tt[12], tt[13], tt[14], tt[15]);  // ra = rt
    }

    // Add c to get next z
    const nzrQD = new Array(4);
    const nziQD = new Array(4);
    ArqdAdd(nzrQD, 0, tt[16], tt[17], tt[18], tt[19],
      this.refC_qd[0], this.refC_qd[1], this.refC_qd[2], this.refC_qd[3]);
    ArqdAdd(nziQD, 0, tt[8], tt[9], tt[10], tt[11],
      this.refC_qd[4], this.refC_qd[5], this.refC_qd[6], this.refC_qd[7]);

    this.qdRefOrbit.push([nzrQD[0], nzrQD[1], nzrQD[2], nzrQD[3],
                          nziQD[0], nziQD[1], nziQD[2], nziQD[3]]);
    this.refIterations++;

    // Build thread-following map
    this.threading.addPoint(this.refIterations);

    // Grow array if needed
    if (this.refIterations >= this.maxRefIterations) {
      this.maxRefIterations *= 2;
    }
  }
};

// Base class for CPU-based Zhuoran perturbation boards (DD and QD precision)
// Subclasses implement precision-specific reference orbit computation
class CpuZhuoranBaseBoard extends Board {
  constructor(k, size, re, im, config, id, inheritedData = null) {
    super(k, size, re, im, config, id, inheritedData);

    // Per-pixel thread tracking for convergence detection
    this.currentThreadIter = new Array(this.config.dimsArea).fill(0);
    this.threadDeltaRe = new Array(this.config.dimsArea).fill(0);
    this.threadDeltaIm = new Array(this.config.dimsArea).fill(0);

    // Reference orbit management
    this.maxRefIterations = 10000;  // Will grow dynamically
    this.refOrbitEscaped = false;
    this.refIterations = 1;  // Start with iterations 0 and 1

    // Per-pixel data (double precision) - shared by all subclasses
    this.dc = [];  // Delta c from reference point [real, imag] pairs
    this.dz = [];  // Current perturbation delta [real, imag] pairs
    this.refIter = [];  // Which iteration of reference each pixel is following
    this.pixelIndexes = [];  // Active pixel indices
    this.maxRefIter = 1;  // Track maximum refIter to avoid scanning all pixels

    this.effort = 100;  // Default for CPU Zhuoran boards, overridden by subclasses
  }

  // Abstract methods - subclasses must implement these

  // Get the double value of the real part from a ref orbit entry
  getRefReal(refEntry) { throw new Error('Abstract method'); }

  // Get the double value of the imaginary part from a ref orbit entry
  getRefImag(refEntry) { throw new Error('Abstract method'); }

  // Get the reference orbit entry at the given iteration
  getRefOrbit(iter) { throw new Error('Abstract method'); }

  // Get the current length of the reference orbit
  getRefOrbitLength() { throw new Error('Abstract method'); }

  // Get reference C real part as double
  getRefCReal() { throw new Error('Abstract method'); }

  // Get reference C imaginary part as double
  getRefCImag() { throw new Error('Abstract method'); }

  // Extend reference orbit by one iteration (precision-specific)
  extendReferenceOrbit() { throw new Error('Abstract method'); }

  // Initialize pixels (shared by DD and QD subclasses)
  initPixels() {
    // Compute delta c directly without precision loss.
    // At deep zoom, computing cr = center + offset loses precision.
    // Since the reference point IS the view center, dc is just the pixel offset from center.
    const sizeScalar = this.size;
    const dimsWidth = this.config.dimsWidth;
    const dimsHeight = this.config.dimsHeight;
    const aspectRatio = this.config.aspectRatio;

    // Convert reference point to double for spike detection
    // Subclasses implement these accessors via mixins
    const refRe = this.getRefCReal();
    const refIm = this.getRefCImag();

    for (let y = 0; y < dimsHeight; y++) {
      const yFrac = (0.5 - y / dimsHeight);
      const dci = yFrac * (sizeScalar / aspectRatio);

      for (let x = 0; x < dimsWidth; x++) {
        const xFrac = (x / dimsWidth - 0.5);
        const dcr = xFrac * sizeScalar;

        const index = y * dimsWidth + x;
        this.dc[index * 2] = dcr;
        this.dc[index * 2 + 1] = dci;
        // Start with z = c, so dz = dc
        this.dz[index * 2] = dcr;
        this.dz[index * 2 + 1] = dci;
        // Start at iteration 1 (z = c)
        this.refIter[index] = 1;

        // Skip precomputed pixels - they'll be flushed at their iteration
        if (!this.precomputed || !this.precomputed.isPrecomputed(index)) {
          this.pixelIndexes.push(index);
        }

        // Count spike pixels
        const cr = refRe + dcr;
        const ci = refIm + dci;
        if (this.inspike(cr, ci)) {
          this.ch += 1;
        }
      }
    }
  }

  // Shared iterate() method - works for both DD and QD
  iterate(targetIters = 1) {
    // Step 1: Extend reference orbit for entire batch upfront (not ahead)
    const targetRefIterations = Math.max(this.it + targetIters, this.maxRefIter + targetIters);
    while (!this.refOrbitEscaped && this.refIterations < targetRefIterations) {
      this.extendReferenceOrbit();
    }

    // Batch multiple iterations internally
    for (let batch = 0; batch < targetIters && this.un > 0; batch++) {
      let changes = null;
      // Step 2: Iterate all active pixels using perturbation
      const newPixelIndexes = [];
      for (const index of this.pixelIndexes) {
        if (this.nn[index]) continue;  // Skip finished pixels
        const result = this.iteratePixel(index);
        if (result !== 0) {
          if (!changes) {
            changes = { iter: this.it, nn: [], vv: [] };
          }
          if (result > 0) {
            // Diverged
            changes.nn.push(index);
            this.nn[index] = this.it;
            this.di += 1;
            this.un -= 1;
          } else {
            // Converged
            const index2 = index * 2;
            const nextRefIter = this.refIter[index] + 1;
            const ref = this.getRefOrbit(Math.min(nextRefIter, this.getRefOrbitLength() - 1));
            const dzr = this.dz[index2];
            const dzi = this.dz[index2 + 1];
            changes.vv.push({
              index: index,
              z: this.refDzNative(ref, dzr, dzi),  // Native format (DDc or QDc)
              p: this.pp[index]
            });
            this.nn[index] = -this.it;
            this.un -= 1;
            if (this.inspike(
              this.dc[index2] + this.getRefCReal(),
              this.dc[index2 + 1] + this.getRefCImag()
            ) && this.ch > 0) {
              this.ch -= 1;
            }
          }
        } else {
          newPixelIndexes.push(index);
        }
      }
      this.pixelIndexes = newPixelIndexes;
      // Compact if needed
      if (this.pixelIndexes.length > this.un * 1.25) {
        this.pixelIndexes = this.pixelIndexes.filter(i => !this.nn[i]);
      }

      // Flush precomputed points at this iteration
      if (this.precomputed) {
        this.precomputed.flushAtIteration(this.it, this);
      }

      this.it++;
      this.queueChanges(changes);
    }
  }

  // Shared iteratePixel() method - works for both DD and QD
  iteratePixel(index) {
    const index2 = index * 2;
    let refIter = this.refIter[index];

    // Check if current z has escaped BEFORE doing iteration
    if (refIter < this.getRefOrbitLength()) {
      const ref = this.getRefOrbit(refIter);
      const refR = this.getRefReal(ref);
      const refI = this.getRefImag(ref);
      const dr = this.dz[index2];
      const di = this.dz[index2 + 1];
      const currentZR = refR + dr;
      const currentZI = refI + di;
      const currentMag2 = currentZR * currentZR + currentZI * currentZI;
      if (currentMag2 > 4) {
        return 1;  // Diverged
      }
    }

    // Ensure reference orbit exists
    if (refIter >= this.getRefOrbitLength()) {
      if (this.refOrbitEscaped) {
        // Rebase to beginning
        const lastRef = this.getRefOrbit(this.getRefOrbitLength() - 1);
        const lastRefR = this.getRefReal(lastRef);
        const lastRefI = this.getRefImag(lastRef);
        const dr = this.dz[index2];
        const di = this.dz[index2 + 1];
        this.dz[index2] = lastRefR + dr;
        this.dz[index2 + 1] = lastRefI + di;
        this.refIter[index] = 0;
        refIter = 0;
      } else {
        return 1;  // Mark as diverged if unexpected
      }
    }

    // Check if we need to rebase (Zhuoran's key innovation)
    if (this.shouldRebase(index)) {
      const ref = this.getRefOrbit(refIter);
      const refR = this.getRefReal(ref);
      const refI = this.getRefImag(ref);
      const dr = this.dz[index2];
      const di = this.dz[index2 + 1];
      this.dz[index2] = refR + dr;
      this.dz[index2 + 1] = refI + di;
      this.refIter[index] = 0;
      refIter = 0;
    }

    // Get reference orbit value
    const ref = this.getRefOrbit(refIter);
    if (!ref) {
      return 0;
    }
    const refR = this.getRefReal(ref);
    const refI = this.getRefImag(ref);

    // Perturbation iteration using binomial expansion (Horner's method)
    const dr = this.dz[index2];
    const di = this.dz[index2 + 1];

    const exponent = this.config.exponent || 2;

    // Build binomial powers: coeff * z_ref^power for each term
    let zPowR = refR;
    let zPowI = refI;
    let coeff = exponent;

    // Start Horner's method with innermost term (just dz)
    let resultR = dr;
    let resultI = di;

    // Horner's method: accumulate terms from highest to lowest power of z_ref
    for (let k = 1; k < exponent; k++) {
      // Add coeff * z_ref^power term
      const termR = coeff * zPowR;
      const termI = coeff * zPowI;
      resultR = resultR + termR;
      resultI = resultI + termI;

      // Multiply by dz (complex multiplication)
      const tempR = resultR * dr - resultI * di;
      resultI = resultR * di + resultI * dr;
      resultR = tempR;

      // Update z_ref power: z_pow = z_pow * z_ref
      const newZPowR = zPowR * refR - zPowI * refI;
      zPowI = zPowR * refI + zPowI * refR;
      zPowR = newZPowR;

      // Update coefficient: coeff *= (n-k) / (k+1)
      coeff *= (exponent - k) / (k + 1);
    }

    // Add perturbation in c
    const newDr = resultR + this.dc[index2];
    const newDi = resultI + this.dc[index2 + 1];
    this.dz[index2] = newDr;
    this.dz[index2 + 1] = newDi;

    // CONVERGENCE DETECTION: fibonacciPeriod returns 1 at Fibonacci checkpoints
    const justUpdatedCheckpoint = (fibonacciPeriod(this.it) == 1);
    if (justUpdatedCheckpoint) {
      this.bb[index2] = dr;
      this.bb[index2 + 1] = di;
      this.pp[index] = 0;
      this.currentThreadIter[index] = refIter;
      this.threadDeltaRe[index] = 0;
      this.threadDeltaIm[index] = 0;
    } else {
      // Incrementally advance threads when thread.next == refIter
      let currentThread = this.currentThreadIter[index];
      const thread = this.threading.getThread(currentThread);
      if (thread.next == refIter) {
        this.threadDeltaRe[index] += thread.deltaRe;
        this.threadDeltaIm[index] += thread.deltaIm;
        currentThread = thread.next;
        this.currentThreadIter[index] = currentThread;
      }

      // Check convergence when currentThreadIter matches refIter
      if (this.currentThreadIter[index] === refIter) {
        const checkpoint_dr = this.bb[index2];
        const checkpoint_di = this.bb[index2 + 1];
        const dzDiffR = dr - checkpoint_dr;
        const dzDiffI = di - checkpoint_di;
        const totalDiffR = this.threadDeltaRe[index] + dzDiffR;
        const totalDiffI = this.threadDeltaIm[index] + dzDiffI;
        const db = Math.max(Math.abs(totalDiffR), Math.abs(totalDiffI));

        const epsilon = this.epsilon;
        const epsilon2 = this.epsilon2;
        if (db <= epsilon2) {
          if (!this.pp[index]) {
            this.pp[index] = this.it - 1;
          }
          if (db <= epsilon) {
            return -1;  // Converged via threading!
          }
        }
      }
    }

    // Update reference iteration counter
    this.refIter[index]++;
    if (this.refIter[index] > this.maxRefIter) {
      this.maxRefIter = this.refIter[index];
    }
    return 0;  // Continue iterating
  }

  // Shared shouldRebase() method - works for both DD and QD
  shouldRebase(index) {
    const index2 = index * 2;
    const dr = this.dz[index2];
    const di = this.dz[index2 + 1];
    const refIter = this.refIter[index];

    if (refIter === 0) return false;
    if (refIter >= this.getRefOrbitLength()) return false;

    const ref = this.getRefOrbit(refIter);
    if (!ref) return false;

    const refR = this.getRefReal(ref);
    const refI = this.getRefImag(ref);

    const dzNorm = Math.max(Math.abs(dr), Math.abs(di));
    const totalR = refR + dr;
    const totalI = refI + di;
    const totalNorm = Math.max(Math.abs(totalR), Math.abs(totalI));

    return totalNorm < dzNorm * 2.0;
  }

  async serialize() {
    // Build sparse nn array for completed pixels (non-zero nn values)
    const completedIndexes = [];
    const completedNn = [];
    for (let i = 0; i < this.nn.length; i++) {
      if (this.nn[i] !== 0) {
        completedIndexes.push(i);
        completedNn.push(this.nn[i]);
      }
    }
    return {
      ...(await super.serialize()),
      // Per-pixel state (sparse - only for active pixels)
      pixelIndexes: this.pixelIndexes,
      dc: this.pixelIndexes.flatMap(i => [this.dc[i*2], this.dc[i*2+1]]),
      dz: this.pixelIndexes.flatMap(i => [this.dz[i*2], this.dz[i*2+1]]),
      refIter: this.pixelIndexes.map(i => this.refIter[i]),
      pp: this.pixelIndexes.map(i => this.pp[i]),
      // Convergence detection state
      currentThreadIter: this.pixelIndexes.map(i => this.currentThreadIter[i]),
      threadDeltaRe: this.pixelIndexes.map(i => this.threadDeltaRe[i]),
      threadDeltaIm: this.pixelIndexes.map(i => this.threadDeltaIm[i]),
      // Reference orbit state
      refOrbitEscaped: this.refOrbitEscaped,
      refIterations: this.refIterations,
      maxRefIter: this.maxRefIter,
      // Completed pixels
      completedIndexes,
      completedNn,
    };
  }

  static restoreBaseState(board, serialized) {
    // Restore nn values for completed pixels
    board.nn = new Array(serialized.config.dimsArea).fill(0);
    if (serialized.completedIndexes) {
      for (let i = 0; i < serialized.completedIndexes.length; i++) {
        board.nn[serialized.completedIndexes[i]] = serialized.completedNn[i];
      }
    }

    // Restore per-pixel state from sparse serialized data
    board.dc = new Array(serialized.config.dimsArea * 2).fill(0);
    board.dz = new Array(serialized.config.dimsArea * 2).fill(0);
    board.refIter = new Array(serialized.config.dimsArea).fill(0);
    board.pp = new Array(serialized.config.dimsArea).fill(0);
    board.currentThreadIter = new Array(serialized.config.dimsArea).fill(0);
    board.threadDeltaRe = new Array(serialized.config.dimsArea).fill(0);
    board.threadDeltaIm = new Array(serialized.config.dimsArea).fill(0);

    const pixelIndexes = serialized.pixelIndexes || [];
    for (let i = 0; i < pixelIndexes.length; i++) {
      const index = pixelIndexes[i];
      board.dc[index * 2] = serialized.dc[i * 2];
      board.dc[index * 2 + 1] = serialized.dc[i * 2 + 1];
      board.dz[index * 2] = serialized.dz[i * 2];
      board.dz[index * 2 + 1] = serialized.dz[i * 2 + 1];
      board.refIter[index] = serialized.refIter[i];
      board.pp[index] = serialized.pp[i];
      board.currentThreadIter[index] = serialized.currentThreadIter[i];
      board.threadDeltaRe[index] = serialized.threadDeltaRe[i];
      board.threadDeltaIm[index] = serialized.threadDeltaIm[i];
    }
    board.pixelIndexes = pixelIndexes.slice();

    // Restore reference orbit state
    board.refOrbitEscaped = serialized.refOrbitEscaped || false;
    board.refIterations = serialized.refIterations || 1;
    board.maxRefIter = serialized.maxRefIter || 1;

    // Restore scalar values
    board.it = serialized.it;
    board.un = serialized.un;
    board.di = serialized.di;
    board.ch = serialized.ch || 0;
  }
}

// DD-precision implementation of CpuZhuoranBaseBoard
// Uses DDReferenceOrbitMixin for reference orbit computation
class DDZhuoranBoard extends DDReferenceOrbitMixin(CpuZhuoranBaseBoard) {
  constructor(k, size, re, im, config, id, inheritedData = null) {
    super(k, size, re, im, config, id, inheritedData);
    this.effort = 450;  // Benchmarked: 19.6 ns/px-iter, 4.5× slower than CPU

    // Initialize DD reference orbit (refC, refOrbit, threading, etc.)
    const refRe = qdToDD(this.re);
    const refIm = qdToDD(this.im);
    this.initDDReferenceOrbit([refRe[0], refRe[1], refIm[0], refIm[1]]);

    this.initPixels();
  }

  static fromSerialized(serialized) {
    const board = new DDZhuoranBoard(
      serialized.k,
      serialized.sizesQD[0],
      serialized.sizesQD[1],
      serialized.sizesQD[2],
      serialized.config,
      serialized.id
    );

    // Restore base Zhuoran state (nn, dc, dz, refIter, etc.)
    CpuZhuoranBaseBoard.restoreBaseState(board, serialized);

    // Restore DD reference orbit
    board.refOrbit = serialized.refOrbit || [];
    board.refC = serialized.refC || [0, 0, 0, 0];

    // Rebuild threading structure from restored reference orbit
    board.rebuildDDThreading();

    return board;
  }

  async serialize() {
    return {
      ...(await super.serialize()),
      refOrbit: this.refOrbit,
      refC: this.refC,
    };
  }

  getCurrentRefZ(index) {
    const refIter = this.refIter[index];
    if (refIter <= this.refIterations && this.refOrbit[refIter]) {
      return this.refOrbit[refIter];
    }
    return [0, 0, 0, 0];
  }
}

// QD-precision implementation of CpuZhuoranBaseBoard
// Provides higher precision (~212 bits) reference for very deep zooms
// Uses QDReferenceOrbitMixin for reference orbit computation
class QDZhuoranBoard extends QDReferenceOrbitMixin(CpuZhuoranBaseBoard) {
  constructor(k, size, re, im, config, id, inheritedData = null) {
    super(k, size, re, im, config, id, inheritedData);
    this.effort = 480;  // Benchmarked: 21.0 ns/px-iter, 4.8× slower than CPU

    // Initialize QD reference orbit (refC_qd, qdRefOrbit, threading, etc.)
    const refReQD = this.re.slice();
    const refImQD = this.im.slice();
    this.initQDReferenceOrbit([...refReQD, ...refImQD]);

    this.initPixels();
  }

  async serialize() {
    return {
      ...(await super.serialize()),
      refC_qd: this.refC_qd,
      qdRefOrbit: this.qdRefOrbit,
    };
  }

  static fromSerialized(serialized) {
    const board = new QDZhuoranBoard(
      serialized.k,
      serialized.sizesQD[0],
      serialized.sizesQD[1],
      serialized.sizesQD[2],
      serialized.config,
      serialized.id
    );

    // Restore base Zhuoran state (nn, dc, dz, refIter, etc.)
    CpuZhuoranBaseBoard.restoreBaseState(board, serialized);

    // Restore QD reference orbit
    board.refC_qd = serialized.refC_qd || new Array(8).fill(0);
    board.qdRefOrbit = serialized.qdRefOrbit || [];

    // Rebuild threading structure from restored reference orbit
    board.rebuildQDThreading();

    return board;
  }
}

// WebGPU-accelerated Mandelbrot computation using single-precision float32
// GPU computes all pixels in parallel using standard Mandelbrot iteration
// Base class for WebGPU-accelerated boards
// Provides shared GPU infrastructure for different computation strategies
class GpuBaseBoard extends Board {
  static GPU_DEFAULT_MAX_BUFFER = 200 * 1024 * 1024;  // 200MB

  constructor(k, size, re, im, config, id, inheritedData = null) {
    super(k, size, re, im, config, id, inheritedData);

    // Note: size, re, im are available via inherited getters from Board (computed from sizesQD)

    // WebGPU state (shared by all GPU board implementations)
    this.device = null;
    this.pipeline = null;
    this.buffers = {};
    this.isGPUReady = false;
    this.gpuInitPromise = null;
    this.isComputing = false;
    this.computePromise = null;  // Track current async computation
    this.lastReportedIters = null;
    this.cpuStatus = null;
    this._readPixelBufferPromise = null;  // Lock for readPixelBuffer
    this.effort = 10;  // Default for GPU boards (~10× faster than CPU), overridden by subclasses
    this.minBatchIters = 17;  // GPU boards need minimum iterations per batch to amortize overhead
    this.maxBatchIters = 134567;  // Cap to avoid very long batches with few pixels
  }

  checkSpike(size, re, im) {
    // Count chaotic pixels in spike region and track which pixels are in spike
    const dimsWidth = this.config.dimsWidth;
    const dimsHeight = this.config.dimsHeight;
    const size_double = Array.isArray(size) ? size.reduce((a, b) => a + (b || 0), 0) : size;
    const re_double = Array.isArray(re) ? (re[0] + re[1]) : re;
    const im_double = Array.isArray(im) ? (im[0] + im[1]) : im;

    // Only allocate inSpike array if we find spike pixels (common case: none)
    this.inSpike = null;

    for (let y = 0; y < dimsHeight; y++) {
      const yFrac = (0.5 - y / dimsHeight);
      const ci = im_double + yFrac * (size_double / this.config.aspectRatio);

      for (let x = 0; x < dimsWidth; x++) {
        const index = y * dimsWidth + x;
        const xFrac = (x / dimsWidth - 0.5);
        const cr = re_double + xFrac * size_double;

        if (this.inspike(cr, ci)) {
          // Lazily allocate array only when we find the first spike pixel
          if (!this.inSpike) {
            this.inSpike = new Uint8Array(this.config.dimsArea);
          }
          this.ch += 1;
          this.inSpike[index] = 1;
        }
      }
    }
  }

  async initGPU() {
    try {
      // Check WebGPU availability
      if (!navigator.gpu) {
        console.warn('WebGPU not supported');
        return false;
      }

      // Request adapter and device
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        console.warn('No WebGPU adapter found');
        return false;
      }

      // Request device with higher buffer limits if supported
      const requiredLimits = {};
      if (adapter.limits.maxStorageBufferBindingSize > 134217728) {
        // Request higher limit if adapter supports it (default is 128MB)
        requiredLimits.maxStorageBufferBindingSize = adapter.limits.maxStorageBufferBindingSize;
      }
      if (adapter.limits.maxBufferSize > 134217728) {
        requiredLimits.maxBufferSize = adapter.limits.maxBufferSize;
      }

      this.device = await adapter.requestDevice({
        requiredLimits: Object.keys(requiredLimits).length > 0 ? requiredLimits : undefined
      });
      if (!this.device) {
        console.warn('Failed to get WebGPU device');
        return false;
      }

      // Subclass-specific initialization
      await this.createComputePipeline();
      await this.createBuffers();
      this.createBindGroup();

      this.isGPUReady = true;
      return true;

    } catch (error) {
      console.error(`Board ${this.id}: WebGPU initialization failed:`, error.message || error);
      // Check if this is a buffer size error
      if (error.message && error.message.includes('exceeds WebGPU safe limit')) {
        console.warn(
          `Board ${this.id}: Dimensions too large for GPU ` +
          `(${this.config.dimsWidth}x${this.config.dimsHeight}). ` +
          `This board will NOT compute any pixels!`);
      }
      return false;
    }
  }

  async ensureGPUReady() {
    if (this.gpuInitPromise) {
      await this.gpuInitPromise;
      this.gpuInitPromise = null;
    }
    return this.isGPUReady;
  }

  async iterate(targetIters = null) {
    if (!this.isGPUReady) {
      return;
    }
    // Block if already computing (prevents scheduler spin on GPU boards)
    if (this.computePromise) {
      await this.computePromise;
      return;
    }
    this.computePromise = this.compute(targetIters);
    try {
      await this.computePromise;
    } finally {
      this.computePromise = null;
    }
  }

  async readBuffer(buffer, TypedArrayConstructor) {
    const size = buffer.size;
    const stagingBuffer = this.device.createBuffer({
      size,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
      label: 'Staging buffer'
    });

    const commandEncoder = this.device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(buffer, 0, stagingBuffer, 0, size);
    this.device.queue.submit([commandEncoder.finish()]);

    await stagingBuffer.mapAsync(GPUMapMode.READ);
    const data = new TypedArrayConstructor(stagingBuffer.getMappedRange()).slice();
    stagingBuffer.unmap();
    stagingBuffer.destroy();

    return data;
  }

  static isAvailable() {
    return typeof navigator !== 'undefined' && 'gpu' in navigator;
  }

  static async queryMaxBufferSize() {
    if (GpuBaseBoard.cachedMaxBufferSize !== undefined) {
      return GpuBaseBoard.cachedMaxBufferSize;
    }
    try {
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) return GpuBaseBoard.GPU_DEFAULT_MAX_BUFFER;

      // Request device with higher limits if supported
      const requiredLimits = {};
      if (adapter.limits.maxStorageBufferBindingSize > 134217728) {
        requiredLimits.maxStorageBufferBindingSize = adapter.limits.maxStorageBufferBindingSize;
      }
      if (adapter.limits.maxBufferSize > 134217728) {
        requiredLimits.maxBufferSize = adapter.limits.maxBufferSize;
      }

      const device = await adapter.requestDevice({
        requiredLimits: Object.keys(requiredLimits).length > 0 ? requiredLimits : undefined
      });
      const limit = Math.min(
        device.limits.maxBufferSize,
        device.limits.maxStorageBufferBindingSize);
      GpuBaseBoard.cachedMaxBufferSize = Math.floor(limit * 0.9);  // 90% for safety
      return GpuBaseBoard.cachedMaxBufferSize;
    } catch (e) {
      GpuBaseBoard.cachedMaxBufferSize = GpuBaseBoard.GPU_DEFAULT_MAX_BUFFER;
      return GpuBaseBoard.cachedMaxBufferSize;
    }
  }

  // ================================================================
  // Double-buffering and compaction infrastructure
  // Subclasses must define: static BYTES_PER_PIXEL, static STRIDE
  // ================================================================

  /**
   * Initialize double-buffering and compaction state.
   * Call from subclass constructor after super().
   */
  initDoubleBuffering() {
    this.stagingBufferIndex = 0;
    this.hasPendingResults = false;
    this.pendingIterationsPerBatch = 0;
    this._baseIt = 1;  // Committed iteration count

    // Compaction state - uses bandwidth cost model
    this.activeCount = this.config.dimsArea;
    this.deadSinceCompaction = 0;
    this.wastedBandwidth = 0;
    this.compactionCount = 0;
    this.pendingActiveCount = this.config.dimsArea;
    this.lastBatchCompacted = false;
  }

  /**
   * Check if compaction is worthwhile based on bandwidth cost.
   * Compaction cost = copying surviving pixels + buffer recreation overhead (~2x)
   */
  shouldCompact() {
    if (this.deadSinceCompaction === 0) return false;
    const BYTES_PER_PIXEL = this.constructor.BYTES_PER_PIXEL;
    const survivingPixels = this.activeCount - this.deadSinceCompaction;
    const compactionCost = survivingPixels * BYTES_PER_PIXEL * 2;
    return this.wastedBandwidth > compactionCost;
  }

  /**
   * Return iteration count including pending (for accurate reporting).
   */
  get it() {
    return this._baseIt + (this.hasPendingResults ? this.pendingIterationsPerBatch : 0);
  }

  set it(value) {
    this._baseIt = value;
  }

  /**
   * Compact buffers to remove dead pixels.
   * @param {Uint32Array} pixelU32 - Current pixel data to compact
   */
  async compactBuffers(pixelU32) {
    const BYTES_PER_PIXEL = this.constructor.BYTES_PER_PIXEL;
    const STRIDE = this.constructor.STRIDE;

    // Build new compacted pixel data
    const newPixelData = [];
    const P_STATUS = 2;  // status is at offset 2 (after orig_index, iter)

    for (let i = 0; i < this.activeCount; i++) {
      const idx = i * STRIDE;
      const status = pixelU32[idx + P_STATUS];

      if (status === 0) {  // Still computing
        for (let j = 0; j < STRIDE; j++) {
          newPixelData.push(pixelU32[idx + j]);
        }
      }
    }

    const newActiveCount = newPixelData.length / STRIDE;
    if (newActiveCount === 0) {
      this.activeCount = 0;
      return;
    }

    this.activeCount = newActiveCount;
    this.deadSinceCompaction = 0;
    this.wastedBandwidth = 0;
    this.compactionCount++;

    const newPixelBufferSize = newActiveCount * BYTES_PER_PIXEL;

    // Shrink all buffers to save VRAM
    this.buffers.stagingPixels[0].destroy();
    this.buffers.stagingPixels[1].destroy();
    this.buffers.stagingPixels = [
      this.device.createBuffer({
        size: newPixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 0 (compacted)'
      }),
      this.device.createBuffer({
        size: newPixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 1 (compacted)'
      })
    ];

    this.buffers.pixels.destroy();
    this.buffers.pixels = this.device.createBuffer({
      size: newPixelBufferSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Pixel state buffer (compacted)'
    });

    // Recreate bind group with new buffer
    this.createBindGroup();

    // Upload compacted data
    const compactedPixelData = new Uint32Array(newPixelData);
    this.device.queue.writeBuffer(this.buffers.pixels, 0, compactedPixelData);

    this.lastBatchCompacted = true;
  }

  // Abstract methods - subclasses must implement these
  async createComputePipeline() {
    throw new Error('createComputePipeline() must be implemented by subclass');
  }

  async createBuffers() {
    throw new Error('createBuffers() must be implemented by subclass');
  }

  createBindGroup() {
    throw new Error('createBindGroup() must be implemented by subclass');
  }

  async compute() {
    throw new Error('compute() must be implemented by subclass');
  }

  /**
   * Read the pixels buffer from GPU and return as ArrayBuffer.
   * Subclasses must have created buffers.pixels and buffers.stagingPixels.
   * Uses a lock to prevent concurrent mapAsync calls.
   * @returns {Promise<ArrayBuffer>} The pixel buffer data
   */
  async readPixelBuffer() {
    if (!this.isGPUReady || !this.buffers.pixels) {
      return null;
    }

    // Wait for any pending read to complete before starting a new one
    if (this._readPixelBufferPromise) {
      await this._readPixelBufferPromise;
    }

    // Create the actual read operation as a promise we can track
    const doRead = async () => {
      const bytesPerPixel = this.constructor.BYTES_PER_PIXEL;
      const dimsArea = this.config.dimsWidth * this.config.dimsHeight;
      const bufferSize = dimsArea * bytesPerPixel;

      // Create staging buffer if not present
      if (!this.buffers.stagingPixels) {
        this.buffers.stagingPixels = this.device.createBuffer({
          size: bufferSize,
          usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
          label: 'Staging pixels buffer (serialization)'
        });
      }

      // Copy pixels buffer to staging
      const commandEncoder = this.device.createCommandEncoder();
      commandEncoder.copyBufferToBuffer(
        this.buffers.pixels, 0, this.buffers.stagingPixels, 0, bufferSize);
      this.device.queue.submit([commandEncoder.finish()]);
      await this.device.queue.onSubmittedWorkDone();

      // Read back the data
      await this.buffers.stagingPixels.mapAsync(GPUMapMode.READ);
      const pixelData = new ArrayBuffer(bufferSize);
      const srcData = this.buffers.stagingPixels.getMappedRange();
      new Uint8Array(pixelData).set(new Uint8Array(srcData));
      this.buffers.stagingPixels.unmap();

      return pixelData;
    };

    this._readPixelBufferPromise = doRead();
    try {
      return await this._readPixelBufferPromise;
    } finally {
      this._readPixelBufferPromise = null;
    }
  }

  /**
   * Write ArrayBuffer data back to the GPU pixels buffer.
   * @param {ArrayBuffer} data - The pixel buffer data to write
   */
  async writePixelBuffer(data) {
    if (!this.isGPUReady || !this.buffers.pixels) {
      return false;
    }
    this.device.queue.writeBuffer(this.buffers.pixels, 0, data);
    await this.device.queue.onSubmittedWorkDone();
    return true;
  }
}

// WebGPU board using float32 arithmetic for shallow zoom depths.
// Uses sparse buffer compaction to improve performance as pixels complete.
class GpuBoard extends GpuBaseBoard {
  static BYTES_PER_PIXEL = 32;  // 8 fields: orig_index + iter/status/period + zr/zi/base_r/base_i
  static STRIDE = 8;            // 8 u32/f32 fields per pixel

  constructor(k, size, re, im, config, id, inheritedData = null) {
    super(k, size, re, im, config, id, inheritedData);
    this.effort = 5;

    const pix = this.pixelSize;
    this.epsilon = pix / 10;
    this.epsilon2 = pix * 10;
    this.checkSpike(size, re, im);

    // Initialize double-buffering (from GpuBaseBoard)
    this.initDoubleBuffering();

    this.gpuInitPromise = this.initGPU();
  }

  async createComputePipeline() {
    // Same shader as GpuBoard but adapted for compacted buffers
    const shaderCode = `
      struct Params {
        center_re: f32,
        center_im: f32,
        pixel_size: f32,
        aspect_ratio: f32,
        dims_width: u32,
        dims_height: u32,
        iterations_per_batch: u32,
        active_count: u32,
        epsilon: f32,
        epsilon2: f32,
        exponent: u32,
        workgroups_x: u32,
        start_iter: u32,
        checkpoint_count: u32,
        ckpt0: u32,
        ckpt1: u32,
        ckpt2: u32,
        ckpt3: u32,
        ckpt4: u32,
        ckpt5: u32,
        ckpt6: u32,
        ckpt7: u32,
      }

      struct PixelState {
        orig_index: u32,  // Original pixel index (for coordinate computation)
        iter: u32,
        status: u32,
        period: u32,
        zr: f32,
        zi: f32,
        base_r: f32,
        base_i: f32,
      }

      @group(0) @binding(0) var<uniform> params: Params;
      @group(0) @binding(1) var<storage, read_write> pixels: array<PixelState>;

      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
        let active_idx = global_id.y * params.workgroups_x + global_id.x;
        if (active_idx >= params.active_count) {
          return;
        }

        // Skip already-finished pixels (simple check in compacted buffer)
        if (pixels[active_idx].status != 0u) {
          return;
        }

        let orig_index = pixels[active_idx].orig_index;
        let x = orig_index % params.dims_width;
        let y = orig_index / params.dims_width;

        let xFrac = f32(i32(x) - i32(params.dims_width / 2u)) / f32(params.dims_width);
        let yFrac = f32(i32(params.dims_height / 2u) - i32(y)) / f32(params.dims_height);
        let cr = params.center_re + xFrac * params.pixel_size;
        let ci = params.center_im + yFrac * (params.pixel_size / params.aspect_ratio);

        var zr = pixels[active_idx].zr;
        var zi = pixels[active_idx].zi;
        var iter = pixels[active_idx].iter;
        var base_r = pixels[active_idx].base_r;
        var base_i = pixels[active_idx].base_i;
        var p = pixels[active_idx].period;

        if (iter == 0u && base_r == 0.0 && base_i == 0.0) {
          base_r = zr;
          base_i = zi;
        }

        var next_checkpoint_idx = 0u;

        // Fixed epsilon derived from pixel size (no iteration-based escalation)
        let epsilon = params.epsilon;
        let epsilon2 = params.epsilon2;

        for (var i = 0u; i < params.iterations_per_batch; i++) {
          if (next_checkpoint_idx < params.checkpoint_count) {
            var checkpoint_offset = 0u;
            switch (next_checkpoint_idx) {
              case 0u: { checkpoint_offset = params.ckpt0; }
              case 1u: { checkpoint_offset = params.ckpt1; }
              case 2u: { checkpoint_offset = params.ckpt2; }
              case 3u: { checkpoint_offset = params.ckpt3; }
              case 4u: { checkpoint_offset = params.ckpt4; }
              case 5u: { checkpoint_offset = params.ckpt5; }
              case 6u: { checkpoint_offset = params.ckpt6; }
              case 7u: { checkpoint_offset = params.ckpt7; }
              default: {}
            }
            if (i == checkpoint_offset) {
              base_r = zr;
              base_i = zi;
              p = 0u;
              next_checkpoint_idx++;
            }
          }

          let zr2 = zr * zr;
          let zi2 = zi * zi;
          let mag_sq = zr2 + zi2;

          if (mag_sq > 4.0 || !(mag_sq <= 1e38)) {
            pixels[active_idx].status = 1u;
            break;
          }

          var ra = zr2 - zi2;
          var ja = 2.0 * zr * zi;
          for (var ord = 2u; ord < params.exponent; ord++) {
            let rt = zr * ra - zi * ja;
            ja = zr * ja + zi * ra;
            ra = rt;
          }
          zr = ra + cr;
          zi = ja + ci;

          let dr = zr - base_r;
          let di = zi - base_i;
          let db = abs(dr) + abs(di);
          if (db <= epsilon2) {
            if (p == 0u) {
              p = iter;
            }
            if (db <= epsilon) {
              pixels[active_idx].status = 2u;
              break;
            }
          }
          iter++;
        }

        pixels[active_idx].zr = zr;
        pixels[active_idx].zi = zi;
        pixels[active_idx].base_r = base_r;
        pixels[active_idx].base_i = base_i;
        pixels[active_idx].iter = iter;
        pixels[active_idx].period = p;
      }
    `;

    const shaderModule = this.device.createShaderModule({
      code: shaderCode,
      label: 'SparseGpu compute shader'
    });

    this.pipeline = this.device.createComputePipeline({
      layout: 'auto',
      compute: {
        module: shaderModule,
        entryPoint: 'main'
      },
      label: 'SparseGpu compute pipeline'
    });
  }

  async createBuffers() {
    const dimsArea = this.config.dimsWidth * this.config.dimsHeight;
    const BYTES_PER_PIXEL = 32;  // 8 fields × 4 bytes

    const maxBufferSize = Math.min(
      this.device.limits.maxBufferSize,
      this.device.limits.maxStorageBufferBindingSize
    );

    // Count active pixels (excluding precomputed)
    const precomputedCount = this.precomputed ? this.precomputed.getPrecomputedCount() : 0;
    const activePixelCount = dimsArea - precomputedCount;

    // Allocate buffer for active pixels only
    // WebGPU requires non-zero buffer size, so use at least 1 pixel worth
    const pixelBufferSize = Math.max(BYTES_PER_PIXEL, activePixelCount * BYTES_PER_PIXEL);

    if (pixelBufferSize > maxBufferSize) {
      throw new Error(`Buffer size exceeds WebGPU limit`);
    }

    // Uniform buffer for parameters
    this.buffers.params = this.device.createBuffer({
      size: 128,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      label: 'Parameters buffer'
    });

    // Pixel state buffer (compacted - excludes precomputed pixels)
    // Each pixel carries its orig_index, so no separate mapping buffer needed
    this.buffers.pixels = this.device.createBuffer({
      size: pixelBufferSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Pixel state buffer'
    });

    // Double-buffered staging (compacted - matches pixel buffer size)
    this.buffers.stagingPixels = [
      this.device.createBuffer({
        size: pixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 0'
      }),
      this.device.createBuffer({
        size: pixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 1'
      })
    ];

    // Initialize only non-precomputed pixels (8 fields per pixel)
    const pixelData = new ArrayBuffer(pixelBufferSize);
    const pixelU32 = new Uint32Array(pixelData);
    const pixelF32 = new Float32Array(pixelData);

    let activeIdx = 0;
    for (let i = 0; i < dimsArea; i++) {
      // Skip precomputed pixels
      if (this.precomputed && this.precomputed.isPrecomputed(i)) {
        continue;
      }

      const idx8 = activeIdx * 8;
      pixelU32[idx8 + 0] = i;  // orig_index (each pixel knows its original position)
      pixelU32[idx8 + 1] = 0;  // iter
      pixelU32[idx8 + 2] = 0;  // status
      pixelU32[idx8 + 3] = 0;  // period
      pixelF32[idx8 + 4] = 0;  // zr
      pixelF32[idx8 + 5] = 0;  // zi
      pixelF32[idx8 + 6] = 0;  // base_r
      pixelF32[idx8 + 7] = 0;  // base_i
      activeIdx++;
    }
    this.device.queue.writeBuffer(this.buffers.pixels, 0, pixelData);

    this.activeCount = activePixelCount;
    // Note: don't adjust this.un here - it will be decremented by flushUpToIteration
    // when precomputed points are flushed, which properly updates di/un together
    this.deadSinceCompaction = 0;
  }

  createBindGroup() {
    this.bindGroup = this.device.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: this.buffers.params } },
        { binding: 1, resource: { buffer: this.buffers.pixels } }
      ],
      label: 'SparseGpu bind group'
    });
  }

  async compactBuffers(pixelU32) {
    // pixelU32 is already-read data from compute(), avoid double-read
    const BYTES_PER_PIXEL = 32;  // 8 fields × 4 bytes

    // Build new compacted pixel data
    // Each pixel carries its orig_index, so no separate mapping needed
    const newPixelData = [];

    for (let i = 0; i < this.activeCount; i++) {
      const idx8 = i * 8;
      const status = pixelU32[idx8 + 2];  // status is at offset 2

      if (status === 0) {  // Still computing
        // Copy all 8 u32 values for this pixel (including orig_index)
        for (let j = 0; j < 8; j++) {
          newPixelData.push(pixelU32[idx8 + j]);
        }
      }
    }

    const newActiveCount = newPixelData.length / 8;
    if (newActiveCount === 0) {
      this.activeCount = 0;
      return;
    }

    this.activeCount = newActiveCount;
    this.deadSinceCompaction = 0;

    const newPixelBufferSize = newActiveCount * BYTES_PER_PIXEL;

    // Shrink all buffers to save VRAM
    this.buffers.stagingPixels[0].destroy();
    this.buffers.stagingPixels[1].destroy();
    this.buffers.stagingPixels = [
      this.device.createBuffer({
        size: newPixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 0 (compacted)'
      }),
      this.device.createBuffer({
        size: newPixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 1 (compacted)'
      })
    ];

    this.buffers.pixels.destroy();
    this.buffers.pixels = this.device.createBuffer({
      size: newPixelBufferSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Pixel state buffer (compacted)'
    });

    // Recreate bind group with new buffer
    this.createBindGroup();

    // Upload compacted data
    const compactedPixelData = new Uint32Array(newPixelData);
    this.device.queue.writeBuffer(this.buffers.pixels, 0, compactedPixelData);
  }

  async compute(targetIters = null) {
    if (this.isComputing) return;
    this.isComputing = true;
    this.lastBatchCompacted = false;

    const BYTES_PER_PIXEL = 32;  // 8 fields × 4 bytes
    const workgroupSize = 64;

    try {
      // STEP 1: Check if done (before submitting new work)
      if (this.activeCount === 0 || this.un === 0) {
        // If all pixels are precomputed (no GPU work), report them now.
        if (this.activeCount === 0 && this.precomputed && this.precomputed.getPendingCount() > 0) {
          const remainingIters = this.precomputed.getPendingIterations();
          for (const iter of remainingIters) {
            const pending = this.precomputed.extractAtIteration(iter);
            if (pending) {
              const divergedIndices = [];
              const convergedData = [];
              for (const idx of pending.diverged) {
                this.nn[idx] = iter;
                this.pp[idx] = 1;
                this.di++;
                this.un--;
                divergedIndices.push(idx);
              }
              for (const c of pending.converged) {
                this.nn[c.index] = -iter;
                this.pp[c.index] = c.p;
                this.un--;
                convergedData.push({ index: c.index, z: c.z, p: c.p });
              }
              if (divergedIndices.length > 0 || convergedData.length > 0) {
                this.changeList.push({ iter, nn: divergedIndices, vv: convergedData });
                this.updateSize += divergedIndices.length + convergedData.length;
              }
            }
          }
        }
        this.un = 0;
        // Flush any pending results before returning
        if (this.hasPendingResults) {
          await this.flushPendingResults();
        }
        return;
      }

      // STEP 2: Submit new GPU batch FIRST (non-blocking)
      // This starts the GPU working while we process previous results
      const re_double = qdToNumber(this.re);
      const im_double = qdToNumber(this.im);
      const pixel_size = this.size;

      let iterationsPerBatch;
      if (targetIters !== null) {
        iterationsPerBatch = targetIters;
      } else {
        const targetWork = 333337;
        iterationsPerBatch = Math.max(17, Math.floor(targetWork / Math.max(this.un, 1)));
      }

      const numWorkgroups = Math.ceil(this.activeCount / workgroupSize);
      const workgroupsX = Math.ceil(Math.sqrt(numWorkgroups));
      const workgroupsY = Math.ceil(numWorkgroups / workgroupsX);

      const checkpointOffsets = [];
      const bufferIter = this.it;
      for (let i = 0; i < iterationsPerBatch; i++) {
        if (fibonacciPeriod(bufferIter + i) === 1) checkpointOffsets.push(i);
      }
      const checkpointCount = Math.min(checkpointOffsets.length, 8);

      const paramsBuffer = new ArrayBuffer(128);
      const paramsF32 = new Float32Array(paramsBuffer);
      const paramsU32 = new Uint32Array(paramsBuffer);

      paramsF32[0] = re_double;
      paramsF32[1] = im_double;
      paramsF32[2] = pixel_size;
      paramsF32[3] = this.config.aspectRatio;
      paramsU32[4] = this.config.dimsWidth;
      paramsU32[5] = this.config.dimsHeight;
      paramsU32[6] = iterationsPerBatch;
      paramsU32[7] = this.activeCount;
      paramsF32[8] = this.epsilon;
      paramsF32[9] = this.epsilon2;
      paramsU32[10] = this.config.exponent;
      paramsU32[11] = workgroupsX * workgroupSize;
      paramsU32[12] = bufferIter;
      paramsU32[13] = checkpointCount;
      for (let i = 0; i < 8; i++) {
        paramsU32[14 + i] = i < checkpointCount ? checkpointOffsets[i] : 0;
      }

      this.device.queue.writeBuffer(this.buffers.params, 0, paramsBuffer);

      const commandEncoder = this.device.createCommandEncoder({ label: 'GpuBoard compute' });
      const passEncoder = commandEncoder.beginComputePass({ label: 'GpuBoard pass' });
      passEncoder.setPipeline(this.pipeline);
      passEncoder.setBindGroup(0, this.bindGroup);
      passEncoder.dispatchWorkgroups(workgroupsX, workgroupsY);
      passEncoder.end();

      // Copy to current staging buffer
      const writeBuffer = this.buffers.stagingPixels[this.stagingBufferIndex];
      const activeBufferSize = this.activeCount * BYTES_PER_PIXEL;
      commandEncoder.copyBufferToBuffer(this.buffers.pixels, 0, writeBuffer, 0, activeBufferSize);

      this.device.queue.submit([commandEncoder.finish()]);
      // GPU is now computing in parallel!

      // Track this batch for later processing
      const newPendingActiveCount = this.activeCount;
      const newStagingIndex = this.stagingBufferIndex;
      this.stagingBufferIndex = 1 - this.stagingBufferIndex;  // Swap for next batch
      this.it += iterationsPerBatch;

      // Note: precomputed points are merged with GPU results below, not flushed separately

      // STEP 3: Process pending results from PREVIOUS batch (overlaps with GPU work)
      if (this.hasPendingResults) {
        const readBuffer = this.buffers.stagingPixels[1 - newStagingIndex];  // The OTHER buffer
        const readActiveCount = this.pendingActiveCount;
        const readBufferSize = readActiveCount * BYTES_PER_PIXEL;

        // Ensure the previous batch's copy to this buffer is complete before mapping
        await this.device.queue.onSubmittedWorkDone();
        await readBuffer.mapAsync(GPUMapMode.READ);
        const pixelData = new ArrayBuffer(readBufferSize);
        const srcData = readBuffer.getMappedRange();
        new Uint8Array(pixelData).set(new Uint8Array(srcData));
        readBuffer.unmap();

        const pixelU32 = new Uint32Array(pixelData);
        const pixelF32 = new Float32Array(pixelData);

        // Process results
        const pixelsByIteration = new Map();
        const convergedByIteration = new Map();
        let newDead = 0;

        for (let i = 0; i < readActiveCount; i++) {
          const idx8 = i * 8;
          const origIndex = pixelU32[idx8 + 0];  // Each pixel carries its own orig_index
          const iters = pixelU32[idx8 + 1];
          const status = pixelU32[idx8 + 2];
          const period = pixelU32[idx8 + 3];
          const zr = pixelF32[idx8 + 4];
          const zi = pixelF32[idx8 + 5];

          if (status === 0) continue;
          if (this.nn[origIndex] !== 0) continue;  // Already processed

          newDead++;

          if (status === 1) {
            this.nn[origIndex] = iters;
            this.pp[origIndex] = 1;
            this.di++;

            if (!pixelsByIteration.has(iters)) pixelsByIteration.set(iters, []);
            pixelsByIteration.get(iters).push(origIndex);

            if (this.inSpike && this.inSpike[origIndex] && this.ch > 0) this.ch -= 1;
          } else if (status === 2) {
            this.nn[origIndex] = -iters;
            this.pp[origIndex] = period + 1;

            if (!convergedByIteration.has(iters)) convergedByIteration.set(iters, []);
            convergedByIteration.get(iters).push({
              index: origIndex,
              z: [zr, zi],
              p: this.pp[origIndex]
            });

            if (this.inSpike && this.inSpike[origIndex] && this.ch > 0) this.ch -= 1;
          }
        }

        this.deadSinceCompaction += newDead;
        const pendingPrecomputed = this.precomputed ? this.precomputed.getPendingCount() : 0;
        this.un = (this.activeCount - this.deadSinceCompaction) + pendingPrecomputed;

        // Accumulate wasted bandwidth: dead pixels read this batch
        this.cumulativeWastedReads += this.deadSinceCompaction;

        // Create change objects, merging precomputed points with GPU results
        // Only iterate over GPU iterations - precomputed are merged INTO GPU batches
        const gpuIterations = new Set([...pixelsByIteration.keys(), ...convergedByIteration.keys()]);
        const sortedGpuIters = Array.from(gpuIterations).sort((a, b) => a - b);
        const minGpuIter = sortedGpuIters.length > 0 ? sortedGpuIters[0] : null;

        for (const iter of sortedGpuIters) {
          // Make copies so we don't modify the original Maps
          const divergedIndices = [...(pixelsByIteration.get(iter) || [])];
          const convergedData = [...(convergedByIteration.get(iter) || [])];

          // Merge precomputed pixels into GPU batches to avoid separate histogram entries
          if (this.precomputed) {
            // At the first GPU iteration, also merge ALL precomputed below this iteration
            // This prevents stripes from separate histogram entries at low iterations
            if (iter === minGpuIter) {
              const lowPrecomputed = this.precomputed.extractBelowIteration(iter);
              if (lowPrecomputed) {
                for (const idx of lowPrecomputed.diverged) {
                  this.nn[idx] = iter;  // Report at minGpuIter, not original iter
                  this.pp[idx] = 1;
                  this.di++;
                  this.un--;
                  divergedIndices.push(idx);
                }
                for (const c of lowPrecomputed.converged) {
                  this.nn[c.index] = -iter;  // Report at minGpuIter
                  this.pp[c.index] = c.p;
                  this.un--;
                  convergedData.push({
                    index: c.index,
                    z: c.z,
                    p: c.p
                  });
                }
              }
            }

            // Merge precomputed at THIS iteration
            const precomputed = this.precomputed.extractAtIteration(iter);
            if (precomputed) {
              for (const idx of precomputed.diverged) {
                this.nn[idx] = iter;
                this.pp[idx] = 1;
                this.di++;
                this.un--;
                divergedIndices.push(idx);
              }
              for (const c of precomputed.converged) {
                this.nn[c.index] = -iter;
                this.pp[c.index] = c.p;
                this.un--;
                convergedData.push({
                  index: c.index,
                  z: c.z,
                  p: c.p
                });
              }
            }
          }

          // Sort by index for consistent ordering
          divergedIndices.sort((a, b) => a - b);
          convergedData.sort((a, b) => a.index - b.index);

          // Report if there are any results
          if (divergedIndices.length > 0 || convergedData.length > 0) {
            this.changeList.push({
              iter,
              nn: divergedIndices,
              vv: convergedData
            });
            this.updateSize += divergedIndices.length + convergedData.length;
          }
        }

        // After GPU batch: if all GPU pixels are done but precomputed remain, flush them
        // This handles precomputed at iterations HIGHER than the last GPU result
        const activeRemaining = this.activeCount - this.deadSinceCompaction;
        if (activeRemaining === 0 && this.precomputed && this.precomputed.getPendingCount() > 0) {
          const remainingIters = this.precomputed.getPendingIterations();
          for (const iter of remainingIters) {
            const pending = this.precomputed.extractAtIteration(iter);
            if (pending) {
              const divergedIndices = [];
              const convergedData = [];
              for (const idx of pending.diverged) {
                this.nn[idx] = iter;
                this.pp[idx] = 1;
                this.di++;
                this.un--;
                divergedIndices.push(idx);
              }
              for (const c of pending.converged) {
                this.nn[c.index] = -iter;
                this.pp[c.index] = c.p;
                this.un--;
                convergedData.push({ index: c.index, z: c.z, p: c.p });
              }
              if (divergedIndices.length > 0 || convergedData.length > 0) {
                this.changeList.push({ iter, nn: divergedIndices, vv: convergedData });
                this.updateSize += divergedIndices.length + convergedData.length;
              }
            }
          }
        }

        // Check compaction: wasted reads >= compaction cost
        // Compaction cost = activeRemaining pixels to write (reuse activeRemaining from above)
        if (activeRemaining > 0 && this.cumulativeWastedReads >= activeRemaining * this.compactionCostRatio) {
          // Need to wait for current GPU batch to finish before compaction
          await this.device.queue.onSubmittedWorkDone();
          await this.compactBuffers(pixelU32);
          this.cumulativeWastedReads = 0;
          this.hasPendingResults = false;  // Buffers recreated, no pending results
          this.lastBatchCompacted = true;
          return;  // Exit - next compute() will start fresh with compacted buffers
        }
      }

      // Update pending state for next iteration
      this.pendingActiveCount = newPendingActiveCount;
      this.hasPendingResults = true;

    } catch (error) {
      console.error(`GpuBoard.compute() ERROR:`, error);
    } finally {
      this.isComputing = false;
    }
  }

  async serialize() {
    // Wait for any in-progress compute() to finish to avoid mapAsync race condition
    while (this.isComputing) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }

    // CRITICAL: Flush pending results before serializing
    // The double-buffered staging has results that haven't been processed yet
    if (this.hasPendingResults) {
      await this.flushPendingResults();
    }

    // Read the compacted GPU pixel buffer
    await this.ensureGPUReady();
    const gpuPixelData = await this.readCompactedPixelBuffer();

    // Build sparse nn array for completed pixels
    const completedIndexes = [];
    const completedNn = [];
    for (let i = 0; i < this.nn.length; i++) {
      if (this.nn[i] !== 0) {
        completedIndexes.push(i);
        completedNn.push(this.nn[i]);
      }
    }

    return {
      ...(await super.serialize()),
      gpuPixelData: gpuPixelData ? Array.from(new Uint8Array(gpuPixelData)) : null,
      effort: this.effort,
      completedIndexes,
      completedNn,
      // Compaction state (orig_index is embedded in pixel data, no separate mapping needed)
      activeCount: this.activeCount,
      deadSinceCompaction: this.deadSinceCompaction,
      cumulativeWastedReads: this.cumulativeWastedReads,
    };
  }

  async flushPendingResults() {
    // Process pending results from the staging buffer without starting a new batch
    if (!this.hasPendingResults) return;

    const BYTES_PER_PIXEL = 32;  // 8 fields × 4 bytes
    const readBuffer = this.buffers.stagingPixels[1 - this.stagingBufferIndex];
    const readActiveCount = this.pendingActiveCount;
    const readBufferSize = readActiveCount * BYTES_PER_PIXEL;

    // Ensure GPU work is complete before mapping
    await this.device.queue.onSubmittedWorkDone();
    await readBuffer.mapAsync(GPUMapMode.READ);
    const pixelData = new ArrayBuffer(readBufferSize);
    const srcData = readBuffer.getMappedRange();
    new Uint8Array(pixelData).set(new Uint8Array(srcData));
    readBuffer.unmap();

    const pixelU32 = new Uint32Array(pixelData);
    const pixelF32 = new Float32Array(pixelData);

    // Process results
    for (let i = 0; i < readActiveCount; i++) {
      const idx8 = i * 8;
      const origIndex = pixelU32[idx8 + 0];  // Each pixel carries its own orig_index
      const iters = pixelU32[idx8 + 1];
      const status = pixelU32[idx8 + 2];
      const period = pixelU32[idx8 + 3];

      if (status === 0) continue;
      if (this.nn[origIndex] !== 0) continue;

      this.deadSinceCompaction++;

      if (status === 1) {
        this.nn[origIndex] = iters;
        this.pp[origIndex] = 1;
        this.di++;
      } else if (status === 2) {
        this.nn[origIndex] = -iters;
        this.pp[origIndex] = period + 1;
      }
    }

    const pendingPrecomputed = this.precomputed ? this.precomputed.getPendingCount() : 0;
    this.un = (this.activeCount - this.deadSinceCompaction) + pendingPrecomputed;
    this.hasPendingResults = false;
  }

  async readCompactedPixelBuffer() {
    if (!this.isGPUReady || !this.buffers?.pixels) return null;

    const BYTES_PER_PIXEL = 32;  // 8 fields × 4 bytes
    const bufferSize = this.activeCount * BYTES_PER_PIXEL;

    const readBuffer = this.device.createBuffer({
      size: bufferSize,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });

    const commandEncoder = this.device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(this.buffers.pixels, 0, readBuffer, 0, bufferSize);
    this.device.queue.submit([commandEncoder.finish()]);

    await readBuffer.mapAsync(GPUMapMode.READ);
    const data = new ArrayBuffer(bufferSize);
    new Uint8Array(data).set(new Uint8Array(readBuffer.getMappedRange()));
    readBuffer.unmap();
    readBuffer.destroy();

    return data;
  }

  static fromSerialized(serialized) {
    const board = new GpuBoard(
      serialized.k,
      serialized.sizesQD[0],
      serialized.sizesQD[1],
      serialized.sizesQD[2],
      serialized.config,
      serialized.id
    );

    // Schedule async restoration after GPU init
    board.gpuInitPromise = board.gpuInitPromise.then(async () => {
      // Restore compaction state
      if (serialized.activeCount !== undefined) {
        board.activeCount = serialized.activeCount;
        board.deadSinceCompaction = serialized.deadSinceCompaction || 0;
        board.cumulativeWastedReads = serialized.cumulativeWastedReads || 0;

        // Recreate buffers at the compacted size
        const BYTES_PER_PIXEL = 32;  // 8 fields × 4 bytes
        const bufferSize = board.activeCount * BYTES_PER_PIXEL;

        board.buffers.pixels?.destroy();
        board.buffers.pixels = board.device.createBuffer({
          size: bufferSize,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
          label: 'Pixel state buffer (restored)'
        });

        // Restore GPU pixel buffer (includes orig_index for each pixel)
        if (serialized.gpuPixelData) {
          const pixelData = new Uint8Array(serialized.gpuPixelData).buffer;
          board.device.queue.writeBuffer(board.buffers.pixels, 0, new Uint8Array(pixelData));
        }

        // Recreate staging buffers at compacted size
        for (let i = 0; i < 2; i++) {
          board.buffers.stagingPixels[i]?.destroy();
          board.buffers.stagingPixels[i] = board.device.createBuffer({
            size: bufferSize,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            label: `Staging pixels buffer ${i} (restored)`
          });
        }

        // Recreate bind group with restored buffer
        board.createBindGroup();
      }

      board.effort = serialized.effort || 5;
      board.it = serialized.it;
      board.un = serialized.un;
      board.di = serialized.di;
      board.ch = serialized.ch || 0;

      // Restore nn array
      board.nn = new Array(serialized.config.dimsArea).fill(0);
      if (serialized.completedIndexes) {
        for (let i = 0; i < serialized.completedIndexes.length; i++) {
          board.nn[serialized.completedIndexes[i]] = serialized.completedNn[i];
        }
      }

      // Restore precomputed points state
      if (serialized.precomputed) {
        board.precomputed = PrecomputedPoints.fromSerialized(serialized.precomputed);
      }
    });

    return board;
  }
}

// Base class for double-buffered GPU perturbation boards (GpuZhuoranBoard, AdaptiveGpuBoard)
// Provides shared double-buffering infrastructure and result processing
class GpuZhuoranBaseBoard extends GpuBaseBoard {
  // Subclasses must define: static BYTES_PER_PIXEL, static STRIDE
  // PixelState layout: orig_index, iter, status, period, ... (orig_index at offset 0)

  // Initialize double-buffering and compaction state (call from subclass constructor)
  initDoubleBuffering() {
    this.stagingBufferIndex = 0;
    this.hasPendingResults = false;
    this.pendingIterationsPerBatch = 0;
    this._baseIt = 1;  // Committed iteration count

    // Compaction state - uses bandwidth cost model
    // Compact when cumulative wasted bandwidth > compaction cost
    this.activeCount = this.config.dimsArea;
    this.deadSinceCompaction = 0;
    this.wastedBandwidth = 0;  // Cumulative bytes wasted copying dead pixels
    this.compactionCount = 0;  // Number of compactions performed
    this.pendingActiveCount = this.config.dimsArea;
    this.lastBatchCompacted = false;
  }

  // Check if compaction is worthwhile based on bandwidth cost
  shouldCompact() {
    if (this.deadSinceCompaction === 0) return false;
    const BYTES_PER_PIXEL = this.constructor.BYTES_PER_PIXEL;
    // Compaction cost = copying surviving pixels + buffer recreation overhead (~2x)
    const survivingPixels = this.activeCount - this.deadSinceCompaction;
    const compactionCost = survivingPixels * BYTES_PER_PIXEL * 2;
    return this.wastedBandwidth > compactionCost;
  }

  // Return iteration count including pending (for accurate reporting)
  get it() {
    return this._baseIt + (this.hasPendingResults ? this.pendingIterationsPerBatch : 0);
  }

  set it(value) {
    this._baseIt = value;
  }

  // Compact buffers to remove dead pixels
  async compactBuffers(pixelU32) {
    const BYTES_PER_PIXEL = this.constructor.BYTES_PER_PIXEL;
    const STRIDE = this.constructor.STRIDE;

    // Build new compacted pixel data
    // Each pixel carries its orig_index, so no separate mapping needed
    const newPixelData = [];
    const P_STATUS = 2;  // status is at offset 2 (after orig_index, iter)

    for (let i = 0; i < this.activeCount; i++) {
      const idx = i * STRIDE;
      const status = pixelU32[idx + P_STATUS];

      if (status === 0) {  // Still computing
        // Copy all values for this pixel (including orig_index)
        for (let j = 0; j < STRIDE; j++) {
          newPixelData.push(pixelU32[idx + j]);
        }
      }
    }

    const newActiveCount = newPixelData.length / STRIDE;
    if (newActiveCount === 0) {
      this.activeCount = 0;
      return;
    }

    this.activeCount = newActiveCount;
    this.deadSinceCompaction = 0;
    this.wastedBandwidth = 0;  // Reset after compaction
    this.compactionCount++;

    const newPixelBufferSize = newActiveCount * BYTES_PER_PIXEL;

    // Shrink all buffers to save VRAM
    this.buffers.stagingPixels[0].destroy();
    this.buffers.stagingPixels[1].destroy();
    this.buffers.stagingPixels = [
      this.device.createBuffer({
        size: newPixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 0 (compacted)'
      }),
      this.device.createBuffer({
        size: newPixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 1 (compacted)'
      })
    ];

    this.buffers.pixels.destroy();
    this.buffers.pixels = this.device.createBuffer({
      size: newPixelBufferSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Pixel state buffer (compacted)'
    });

    // Recreate bind group with new buffer
    this.createBindGroup();

    // Upload compacted data
    const compactedPixelData = new Uint32Array(newPixelData);
    this.device.queue.writeBuffer(this.buffers.pixels, 0, compactedPixelData);

    this.lastBatchCompacted = true;
  }

  async flushPendingResults() {
    // Process pending results from the staging buffer without starting a new batch
    if (!this.hasPendingResults) return;

    const BYTES_PER_PIXEL = this.constructor.BYTES_PER_PIXEL;
    const STRIDE = this.constructor.STRIDE;
    const readBuffer = this.buffers.stagingPixels[1 - this.stagingBufferIndex];
    const readActiveCount = this.pendingActiveCount;
    const pixelBufferSize = readActiveCount * BYTES_PER_PIXEL;

    // Ensure GPU work is complete before mapping
    await this.device.queue.onSubmittedWorkDone();
    await readBuffer.mapAsync(GPUMapMode.READ);
    const pixelData = new ArrayBuffer(pixelBufferSize);
    const srcData = readBuffer.getMappedRange();
    new Uint8Array(pixelData).set(new Uint8Array(srcData));
    readBuffer.unmap();

    const pixelsI32 = new Int32Array(pixelData);

    // Update global iteration counter using _baseIt directly
    this._baseIt += this.pendingIterationsPerBatch;

    // PixelState field indices (orig_index at 0)
    const P_ORIG_INDEX = 0, P_ITER = 1, P_STATUS = 2, P_PERIOD = 3;

    // Process results
    let newDead = 0;
    for (let i = 0; i < readActiveCount; i++) {
      const idx = i * STRIDE;
      const origIndex = pixelsI32[idx + P_ORIG_INDEX];
      const status = pixelsI32[idx + P_STATUS];
      const period = pixelsI32[idx + P_PERIOD];

      if (this.nn[origIndex] !== 0) continue;

      if (status === 1) {
        const iters = pixelsI32[idx + P_ITER];
        this.nn[origIndex] = iters;
        this.pp[origIndex] = period;
        this.di++;
        this.un--;
        newDead++;
      } else if (status === 2) {
        const iters = pixelsI32[idx + P_ITER];
        this.nn[origIndex] = -iters;
        this.pp[origIndex] = period - 1;
        this.un--;
        newDead++;
      }
    }

    this.deadSinceCompaction += newDead;
    const pendingPrecomputed = this.precomputed ? this.precomputed.getPendingCount() : 0;
    this.un = (this.activeCount - this.deadSinceCompaction) + pendingPrecomputed;
    this.hasPendingResults = false;
  }

  async readPixelBuffer() {
    // Handle double-buffered staging array for serialization
    if (!this.isGPUReady || !this.buffers.pixels) {
      return null;
    }

    const BYTES_PER_PIXEL = this.constructor.BYTES_PER_PIXEL;
    const bufferSize = this.activeCount * BYTES_PER_PIXEL;

    // Use the first staging buffer for serialization reads
    const stagingBuffer = this.buffers.stagingPixels[0];

    // Copy pixels buffer to staging
    const commandEncoder = this.device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(this.buffers.pixels, 0, stagingBuffer, 0, bufferSize);
    this.device.queue.submit([commandEncoder.finish()]);
    await this.device.queue.onSubmittedWorkDone();

    // Read back the data - use getMappedRange with size to only get what we need
    await stagingBuffer.mapAsync(GPUMapMode.READ, 0, bufferSize);
    const pixelData = new ArrayBuffer(bufferSize);
    const srcData = stagingBuffer.getMappedRange(0, bufferSize);
    new Uint8Array(pixelData).set(new Uint8Array(srcData));
    stagingBuffer.unmap();

    return pixelData;
  }
}

// WebGPU-accelerated perturbation board using Zhuoran's approach
// Computes high-precision reference orbit on CPU, perturbations on GPU
// Uses DDReferenceOrbitMixin for reference orbit computation
class GpuZhuoranBoard extends DDReferenceOrbitMixin(GpuZhuoranBaseBoard) {
  static BYTES_PER_PIXEL = 60;  // 7 u32 + 8 f32 (with orig_index for compaction)
  static STRIDE = 15;           // 15 fields per pixel

  constructor(k, size, re, im, config, id, inheritedData = null) {
    super(k, size, re, im, config, id, inheritedData);
    this.effort = 9;  // Benchmarked: 0.4 ns/px-iter, 11× faster than CPU

    // Initialize DD reference orbit (refC, refOrbit, threading, etc.)
    const refRe = Array.isArray(re) ? re : toDD(re);
    const refIm = Array.isArray(im) ? im : toDD(im);
    this.initDDReferenceOrbit([refRe[0], refRe[1], refIm[0], refIm[1]]);

    // Initialize per-pixel perturbation data
    this.initPixels(size, re, im);

    // Initialize double-buffering (from GpuZhuoranBaseBoard)
    this.initDoubleBuffering();

    // Start GPU initialization (async)
    this.gpuInitPromise = this.initGPU();
  }

  initPixels(size, re, im) {
    const dimsWidth = this.config.dimsWidth;
    const dimsHeight = this.config.dimsHeight;
    const dimsArea = this.config.dimsArea;

    // Convert re/im to DD precision if needed
    const re_dd = Array.isArray(re) ? re : toDD(re);
    const im_dd = Array.isArray(im) ? im : toDD(im);
    // Convert size to scalar if it's a QD array (fixes NaN when size is array)
    const size_scalar = Array.isArray(size) ? size.reduce((a, b) => a + (b || 0), 0) : size;
    const size_dd = toDD(size_scalar);
    const sizeY_dd = toDD(size_scalar / this.config.aspectRatio);

    // Per-pixel data arrays
    this.dc = new Float32Array(dimsArea * 2);
    // Delta c from reference [real, imag] pairs
    this.dz = new Float32Array(dimsArea * 2);
    // Current perturbation delta [real, imag] pairs
    this.refIter = new Uint32Array(dimsArea);
    // Which iteration of reference each pixel is following

    // Working arrays for DD precision arithmetic
    const cr_dd = new Array(4);
    const ci_dd = new Array(4);
    const dcr_dd = new Array(4);
    const dci_dd = new Array(4);
    const temp = new Array(4);

    // Initialize all pixels as perturbations from the reference point
    for (let y = 0; y < dimsHeight; y++) {
      // Use integer arithmetic to avoid float64 rounding: (dims/2 - y) / dims
      const yFrac = (dimsHeight / 2 - y) / dimsHeight;

      // ci_dd = im_dd + yFrac * sizeY_dd (in DD precision)
      ArddMul(temp, 0, toDD(yFrac)[0], toDD(yFrac)[1], sizeY_dd[0], sizeY_dd[1]);
      ArddAdd(ci_dd, 0, im_dd[0], im_dd[1], temp[0], temp[1]);

      // dci_dd = ci_dd - refC_imag
      ArddAdd(dci_dd, 0, ci_dd[0], ci_dd[1], -this.refC[2], -this.refC[3]);

      for (let x = 0; x < dimsWidth; x++) {
        // Use integer arithmetic to avoid float64 rounding: (x - dims/2) / dims
        const xFrac = (x - dimsWidth / 2) / dimsWidth;

        // cr_dd = re_dd + xFrac * size_dd (in DD precision)
        ArddMul(temp, 0, toDD(xFrac)[0], toDD(xFrac)[1], size_dd[0], size_dd[1]);
        ArddAdd(cr_dd, 0, re_dd[0], re_dd[1], temp[0], temp[1]);

        // dcr_dd = cr_dd - refC_real
        ArddAdd(dcr_dd, 0, cr_dd[0], cr_dd[1], -this.refC[0], -this.refC[1]);

        const index = y * dimsWidth + x;
        const index2 = index * 2;

        // Convert DD precision deltas to float32 (Math.fround simulates GPU precision)
        this.dc[index2] = Math.fround(dcr_dd[0] + dcr_dd[1]);
        this.dc[index2 + 1] = Math.fround(dci_dd[0] + dci_dd[1]);

        // Start with dz = dc (so z = c_ref + dc = c)
        this.dz[index2] = this.dc[index2];
        this.dz[index2 + 1] = this.dc[index2 + 1];

        // Start at iteration 1 (where refOrbit[1] = c_ref)
        this.refIter[index] = 1;
      }
    }

    this.checkSpike(size, re, im);
  }

  async createBuffers() {
    const dimsArea = this.config.dimsWidth * this.config.dimsHeight;
    const BYTES_PER_PIXEL = GpuZhuoranBoard.BYTES_PER_PIXEL;
    const STRIDE = GpuZhuoranBoard.STRIDE;

    // Check buffer size limits before creating (safety margin applied upstream)
    const maxBufferSize = Math.min(
      this.device.limits.maxBufferSize,
      this.device.limits.maxStorageBufferBindingSize
    );
    // Unified PixelState struct: 7 u32 + 8 f32 = 60 bytes per pixel (with orig_index)
    const precomputedCount = this.precomputed ? this.precomputed.getPrecomputedCount() : 0;
    const activePixelCount = dimsArea - precomputedCount;
    const pixelBufferSize = Math.max(BYTES_PER_PIXEL, activePixelCount * BYTES_PER_PIXEL);

    if (pixelBufferSize > maxBufferSize) {
      throw new Error(
        `Buffer size (${(pixelBufferSize / (1024 * 1024)).toFixed(1)} MB) ` +
        `exceeds WebGPU limit (${(maxBufferSize / (1024 * 1024)).toFixed(1)} MB). ` +
        `Board ${this.config.dimsWidth}x${this.config.dimsHeight} is too large ` +
        `for GPU acceleration.`);
    }

    // Single unified pixel state buffer (PixelState struct: 7 u32 + 8 f32 = 60 bytes per pixel)
    // Layout per pixel: [orig_index, iter, status, period, ref_iter, ckpt_refidx, pending_refidx,
    //                    dzr, dzi, bbr, bbi, ckpt_bbr, ckpt_bbi, dcr, dci]
    this.buffers.pixels = this.device.createBuffer({
      size: pixelBufferSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
      label: 'Pixel state buffer'
    });

    // Unified iteration state buffer (IterState struct: 5 f32 = 20 bytes per iteration)
    // Combines reference orbit (re, im) and threading data (next, deltaRe, deltaIm)
    // Start with 1MB, will grow by doubling up to 128MB cap
    this.buffers.iters = this.device.createBuffer({
      size: 1 * 1024 * 1024,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      label: 'Iteration state buffer'
    });

    // Track last uploaded iteration length
    this.lastUploadedIterLength = -1;  // -1 means nothing uploaded yet

    // Uniform buffer for parameters
    this.buffers.params = this.device.createBuffer({
      size: 128,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      label: 'Params buffer'
    });

    // Double-buffered staging for overlapping CPU/GPU work
    this.buffers.stagingPixels = [
      this.device.createBuffer({
        size: pixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 0'
      }),
      this.device.createBuffer({
        size: pixelBufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        label: 'Staging pixels buffer 1'
      })
    ];

    // Initialize pixel state buffer using overlapping typed array views
    // ArrayBuffer holds 60 bytes per pixel (15 x 4 bytes, with orig_index)
    const pixelData = new ArrayBuffer(pixelBufferSize);
    const pixelU32 = new Uint32Array(pixelData);   // For u32 fields (indices 0-6)
    const pixelF32 = new Float32Array(pixelData);  // For f32 fields (indices 7-14)

    let activeIdx = 0;
    for (let i = 0; i < dimsArea; i++) {
      if (this.precomputed && this.precomputed.isPrecomputed(i)) {
        continue;
      }
      const idx = activeIdx * STRIDE;  // 15 x 4-byte values per pixel
      // Integer fields (offsets 0-6)
      pixelU32[idx + 0] = i;                       // orig_index (for coordinate computation after compaction)
      pixelU32[idx + 1] = 1;                       // iter (start at 1, z=c is iteration 1)
      pixelU32[idx + 2] = 0;                       // status (0 = computing)
      pixelU32[idx + 3] = 0;                       // period
      pixelU32[idx + 4] = this.refIter[i];        // ref_iter
      pixelU32[idx + 5] = 0xFFFFFFFF;             // ckpt_refidx (sentinel)
      pixelU32[idx + 6] = 0xFFFFFFFF;             // pending_refidx (sentinel)
      // Float fields (offsets 7-14)
      pixelF32[idx + 7] = this.dz[i * 2];         // dzr
      pixelF32[idx + 8] = this.dz[i * 2 + 1];     // dzi
      pixelF32[idx + 9] = 0;                       // bbr
      pixelF32[idx + 10] = 0;                      // bbi
      pixelF32[idx + 11] = 0;                      // ckpt_bbr
      pixelF32[idx + 12] = 0;                      // ckpt_bbi
      pixelF32[idx + 13] = this.dc[i * 2];        // dcr
      pixelF32[idx + 14] = this.dc[i * 2 + 1];    // dci
      activeIdx++;
    }

    // Initialize unified iters buffer with initial data (iter 0 and 1)
    // IterState struct: [ref_re, ref_im, thread_next, thread_delta_re, thread_delta_im] = 5 f32
    const initialIterData = new Float32Array(10);  // 2 iters * 5 floats
    // iter 0: z=0, no thread
    initialIterData[0] = 0;   // ref_re
    initialIterData[1] = 0;   // ref_im
    initialIterData[2] = -1;  // thread_next (-1 = no thread)
    initialIterData[3] = 0;   // thread_delta_re
    initialIterData[4] = 0;   // thread_delta_im
    // iter 1: z=c_ref, no thread
    initialIterData[5] = this.refC[0] + this.refC[1];  // ref_re
    initialIterData[6] = this.refC[2] + this.refC[3];  // ref_im
    initialIterData[7] = -1;  // thread_next
    initialIterData[8] = 0;   // thread_delta_re
    initialIterData[9] = 0;   // thread_delta_im

    this.device.queue.writeBuffer(this.buffers.pixels, 0, pixelU32);
    this.device.queue.writeBuffer(this.buffers.iters, 0, initialIterData);

    // Mark initial data as uploaded
    this.lastUploadedIterLength = 1;  // Uploaded iters 0 and 1

    this.activeCount = activePixelCount;
    this.pendingActiveCount = activePixelCount;
    this.deadSinceCompaction = 0;
    this.wastedBandwidth = 0;
  }

  createBindGroup() {
    // Unified 3-binding layout for maximum cache coherency
    this.bindGroup = this.device.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: this.buffers.params } },
        { binding: 1, resource: { buffer: this.buffers.pixels } },
        { binding: 2, resource: { buffer: this.buffers.iters } }
      ],
      label: 'Perturbation bind group'
    });
  }

  // extendReferenceOrbit() inherited from DDReferenceOrbitMixin

  setupReferenceOrbitLoop() {
    // When reference orbit hits threading limit, find a close point to loop back to
    const THREADING_CAPACITY = 1048576;  // 2^20
    const SEARCH_WINDOW = 12000;

    if (this.refIterations < THREADING_CAPACITY || this.refOrbitLoopConfigured) {
      return; // Not at limit yet, or already configured
    }

    // Get endpoint (current position at threading limit)
    const endpoint = this.refOrbit[THREADING_CAPACITY];
    const endR = endpoint[0] + endpoint[1];
    const endI = endpoint[2] + endpoint[3];

    // Search back to find closest point
    let closestIter = THREADING_CAPACITY - SEARCH_WINDOW;
    let closestDist = Infinity;

    for (let i = THREADING_CAPACITY - SEARCH_WINDOW; i < THREADING_CAPACITY; i++) {
      const pt = this.refOrbit[i];
      const ptR = pt[0] + pt[1];
      const ptI = pt[2] + pt[3];
      const dr = endR - ptR;
      const di = endI - ptI;
      const dist = Math.max(Math.abs(dr), Math.abs(di)); // Chebyshev distance

      if (dist <= closestDist) {  // Use <= to take latest point when tied
        closestDist = dist;
        closestIter = i;
      }
    }

    // Compute delta in DD precision
    const closestPt = this.refOrbit[closestIter];
    const tt = this.tt;
    ArddAdd(tt, 0, endpoint[0], endpoint[1], -closestPt[0], -closestPt[1]); // real delta
    ArddAdd(tt, 2, endpoint[2], endpoint[3], -closestPt[2], -closestPt[3]); // imag delta

    // Store loop parameters
    this.refOrbitLoop = {
      enabled: true,
      threshold: THREADING_CAPACITY,
      jumpAmount: THREADING_CAPACITY - closestIter,
      deltaR: tt[0] + tt[1], // Convert to float64
      deltaI: tt[2] + tt[3]
    };

    this.refOrbitLoopConfigured = true;

    // Update threading for loop segment to wrap around
    const loopDeltaR = this.refOrbitLoop.deltaR;
    const loopDeltaI = this.refOrbitLoop.deltaI;
    const epsilon3 = this.threading.epsilon3;

    // For each iteration in the loop segment, check if it can thread to another iteration
    // considering the loop wrap (iterations will repeat with a delta offset)
    for (let i = closestIter; i <= THREADING_CAPACITY; i++) {
      const iPt = this.refOrbit[i];
      const iR = iPt[0] + iPt[1];
      const iI = iPt[2] + iPt[3];

      // Check if we can thread to same or later iteration (considering it will wrap with delta)
      // Allow j = i for self-threading within the loop (period-N orbits repeat with delta)
      for (let j = i; j <= THREADING_CAPACITY; j++) {
        const jPt = this.refOrbit[j];
        // After loop, iteration j will be at position refOrbit[j] + loop_delta
        const jR = jPt[0] + jPt[1] + loopDeltaR;
        const jI = jPt[2] + jPt[3] + loopDeltaI;

        const dr = iR - jR;
        const di = iI - jI;
        const dist = Math.max(Math.abs(dr), Math.abs(di));

        if (dist <= epsilon3) {
          // Thread i -> j (wrapping through the loop)
          this.threading.setThread(i, j, jR - iR, jI - iI);
          break;  // Take first match
        }
      }
    }
  }

  async createComputePipeline() {
    const shaderCode = `
      struct Params {
        dims_width: u32,
        dims_height: u32,
        iterations_per_batch: u32,
        active_count: u32,
        ref_orbit_length: u32,
        exponent: u32,
        workgroups_x: u32,
        start_iter: u32,
        checkpoint_count: u32,
        ckpt0: u32,
        ckpt1: u32,
        ckpt2: u32,
        ckpt3: u32,
        ckpt4: u32,
        ckpt5: u32,
        ckpt6: u32,
        ckpt7: u32,
        loop_enabled: u32,      // 1 if loop enabled, 0 otherwise
        loop_threshold: u32,    // ref_iter threshold to trigger loop
        loop_jump: u32,         // Amount to subtract from ref_iter
        _padding: u32,          // Alignment padding
        pixel_size: f32,
        aspect_ratio: f32,
        loop_delta_r: f32,      // Delta to add to dzr
        loop_delta_i: f32,      // Delta to add to dzi
      }

      // Per-pixel state: 7 u32 + 8 f32 = 60 bytes (with orig_index for compaction)
      // Layout (u32 view):
      //   [0] orig_index: u32  (original pixel index for sparse processing)
      //   [1] iter: u32
      //   [2] status: u32
      //   [3] period: u32
      //   [4] ref_iter: u32
      //   [5] ckpt_refidx: u32
      //   [6] pending_refidx: u32
      //   [7] dzr: f32
      //   [8] dzi: f32
      //   [9] bbr: f32
      //   [10] bbi: f32
      //   [11] ckpt_bbr: f32
      //   [12] ckpt_bbi: f32
      //   [13] dcr: f32
      //   [14] dci: f32
      struct PixelState {
        // Integer fields (7 u32)
        orig_index: u32,
        iter: u32,
        status: u32,
        period: u32,
        ref_iter: u32,
        ckpt_refidx: u32,
        pending_refidx: u32,
        // Float fields (8 f32)
        dzr: f32,
        dzi: f32,
        bbr: f32,
        bbi: f32,
        ckpt_bbr: f32,
        ckpt_bbi: f32,
        dcr: f32,
        dci: f32,
      }

      // Per-iteration state (reference orbit + threading): 5 f32 = 20 bytes
      // Layout (f32 view):
      //   [0] ref_re: f32
      //   [1] ref_im: f32
      //   [2] thread_next: f32 (-1 = no thread)
      //   [3] thread_delta_re: f32
      //   [4] thread_delta_im: f32
      struct IterState {
        ref_re: f32,      // Reference orbit real part
        ref_im: f32,      // Reference orbit imag part
        thread_next: f32, // Next thread index (as f32, -1 = no thread)
        thread_delta_re: f32,
        thread_delta_im: f32,
      }

      @group(0) @binding(0) var<uniform> params: Params;
      @group(0) @binding(1) var<storage, read_write> pixels: array<PixelState>;
      @group(0) @binding(2) var<storage, read> iters: array<IterState>;

      // Get threading data from unified iters buffer
      // Returns vec3: [next_index_as_f32, deltaRe, deltaIm]
      fn getThread(idx: u32) -> vec3<f32> {
        if (idx >= params.ref_orbit_length) { return vec3<f32>(-1.0, 0.0, 0.0); }
        let iter_data = iters[idx];
        return vec3<f32>(iter_data.thread_next,
          iter_data.thread_delta_re, iter_data.thread_delta_im);
      }

      // Get reference orbit values from unified iters buffer
      fn getRefOrbit(idx: u32) -> vec2<f32> {
        if (idx >= params.ref_orbit_length) { return vec2<f32>(0.0, 0.0); }
        return vec2<f32>(iters[idx].ref_re, iters[idx].ref_im);
      }

      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
        // 2D dispatch: calculate linear index from 2D coordinates
        let index = global_id.y * params.workgroups_x + global_id.x;
        if (index >= params.active_count) { return; }

        // Skip if already finished
        if (pixels[index].status != 0u) { return; }

        // Load state from unified pixel struct
        var iter = pixels[index].iter;
        var pp = pixels[index].period;
        var ref_iter = pixels[index].ref_iter;
        var checkpoint_refidx = pixels[index].ckpt_refidx;
        var pending_checkpoint_refidx = pixels[index].pending_refidx;
        var dzr = pixels[index].dzr;
        var dzi = pixels[index].dzi;
        var bbr = pixels[index].bbr;
        var bbi = pixels[index].bbi;
        var checkpoint_bb_r = pixels[index].ckpt_bbr;
        var checkpoint_bb_i = pixels[index].ckpt_bbi;
        let dcr = pixels[index].dcr;
        let dci = pixels[index].dci;

        // Convergence thresholds scale with pixel size for deep zooms (no iteration-based escalation)
        // GPU uses float32 precision, so thresholds must be larger than CPU's float64
        let epsilon_base = params.pixel_size / 10.0;   // Final convergence threshold
        let epsilon2_base = params.pixel_size * 10.0;  // Getting close threshold
        let epsilon = epsilon_base;
        let epsilon2 = epsilon2_base;

        // Track next checkpoint using O(1) counter for adaptive checkpoints
        var next_checkpoint_idx = 0u;

        // Iterate for the batch
        for (var batch_iter = 0u; batch_iter < params.iterations_per_batch; batch_iter++) {
          // Early exit if pixel already finished (converged/diverged)
          if (pixels[index].status != 0u) {
            break;
          }

          // Check rebasing before loading reference orbit values to avoid using stale data
          let dz_norm = max(abs(dzr), abs(dzi));

          // Peek at reference orbit to check rebasing condition
          if (ref_iter < params.ref_orbit_length) {
            let ref_check = getRefOrbit(ref_iter);
            let total_r_pre = ref_check.x + dzr;
            let total_i_pre = ref_check.y + dzi;
            let total_norm = max(abs(total_r_pre), abs(total_i_pre));

            // Rebase when orbit approaches critical point
            if (ref_iter > 0u && total_norm < dz_norm * 2.0) {
              dzr = total_r_pre;  // Set dz = z_total (absolute position)
              dzi = total_i_pre;
              ref_iter = 0u;  // Restart from beginning of reference orbit

              // Reset lazy threading state after rebase:
              // - pending_checkpoint_refidx back to checkpoint_refidx
              // - bb back to checkpoint_bb (original dz at checkpoint)
              if (checkpoint_refidx != 0xFFFFFFFFu) {
                pending_checkpoint_refidx = checkpoint_refidx;
                bbr = checkpoint_bb_r;
                bbi = checkpoint_bb_i;
              }
            }
          }

          // Load reference orbit values for current (possibly rebased) ref_iter
          if (ref_iter >= params.ref_orbit_length) {
            break;  // Reference orbit too short
          }
          let ref_val = getRefOrbit(ref_iter);
          var refr = ref_val.x;
          var refi = ref_val.y;

          // Check current z for divergence
          let curr_total_r = refr + dzr;
          let curr_total_i = refi + dzi;
          let curr_mag_sq = curr_total_r * curr_total_r + curr_total_i * curr_total_i;

          // Check divergence (escape radius 2, or NaN/Infinity from numerical errors)
          // NaN/Inf check: !(x <= large) catches both
          if (curr_mag_sq > 4.0 || !(curr_mag_sq <= 1e38)) {
            pixels[index].status = 1u;
            pixels[index].period = pp;
            break;
          }

          // Save dz before iteration (for checkpoint timing)
          let old_dzr = dzr;
          let old_dzi = dzi;
          let old_ref_iter = ref_iter;

          // Perturbation iteration using binomial expansion (Horner's method)
          // (z_ref+dz)^n - z_ref^n = sum(k=1 to n) C(n,k) * z_ref^(n-k) * dz^k
          // Computed as: dz * (C(n,1)*z_ref^(n-1) + dz * (C(n,2)*z_ref^(n-2) + ...))

          // Build binomial powers: coeff * z_ref^power for each term
          var z_pow_r = refr;
          var z_pow_i = refi;
          var coeff = f32(params.exponent);

          // Start Horner's method with innermost term
          var result_r = dzr;
          var result_i = dzi;

          // Horner's method: accumulate terms from highest to lowest power of z_ref
          for (var k = 1u; k < params.exponent; k++) {
            // Add coeff * z_ref^power term
            let term_r = coeff * z_pow_r;
            let term_i = coeff * z_pow_i;
            result_r = result_r + term_r;
            result_i = result_i + term_i;

            // Multiply by dz (complex multiplication)
            let temp_r = result_r * dzr - result_i * dzi;
            result_i = result_r * dzi + result_i * dzr;
            result_r = temp_r;

            // Update z_ref power: z_pow = z_pow * z_ref
            let new_z_pow_r = z_pow_r * refr - z_pow_i * refi;
            z_pow_i = z_pow_r * refi + z_pow_i * refr;
            z_pow_r = new_z_pow_r;

            // Update coefficient: coeff *= (n-k) / (k+1)
            coeff *= f32(params.exponent - k) / f32(k + 1u);
          }

          // Add perturbation in c
          dzr = result_r + dcr;
          dzi = result_i + dci;

          // Check if reference orbit is long enough for next iteration
          let next_ref_check = (ref_iter + 1u) * 2u;
          if (next_ref_check + 1u >= params.ref_orbit_length * 2u) {
            break;
          }

          // CONVERGENCE DETECTION: Check if this iteration is a checkpoint
          var just_updated = false;
          if (next_checkpoint_idx < params.checkpoint_count) {
            // Get the offset for the next checkpoint based on index
            var checkpoint_offset = 0u;
            switch (next_checkpoint_idx) {
              case 0u: { checkpoint_offset = params.ckpt0; }
              case 1u: { checkpoint_offset = params.ckpt1; }
              case 2u: { checkpoint_offset = params.ckpt2; }
              case 3u: { checkpoint_offset = params.ckpt3; }
              case 4u: { checkpoint_offset = params.ckpt4; }
              case 5u: { checkpoint_offset = params.ckpt5; }
              case 6u: { checkpoint_offset = params.ckpt6; }
              case 7u: { checkpoint_offset = params.ckpt7; }
              default: {}
            }

            // Check if current batch_iter matches this checkpoint
            if (batch_iter == checkpoint_offset) {
              just_updated = true;
              // Store both bb (current) and checkpoint_bb (original, for reset after rebase)
              bbr = old_dzr;  // dz real at checkpoint (BEFORE iteration)
              bbi = old_dzi;  // dz imag at checkpoint
              checkpoint_bb_r = old_dzr;  // Save original for reset
              checkpoint_bb_i = old_dzi;
              checkpoint_refidx = old_ref_iter;  // Store reference iteration (fixed)
              pending_checkpoint_refidx = old_ref_iter;  // Start lazy threading at checkpoint
              pp = 0u;
              next_checkpoint_idx++;  // Move to next checkpoint
            }
          }
          // Check convergence (if we have a checkpoint and didn't just update it)
          // Use 0xFFFFFFFF as sentinel for "no checkpoint yet"
          if (checkpoint_refidx != 0xFFFFFFFFu && !just_updated) {
            // Threading buffer capacity: 64MB / 16 bytes per iteration = 4,194,304 (2^22)
            const THREADING_CAPACITY = 1048576u;

            // Fallback: when ref_iter exceeds threading buffer, use absolute position comparison
            if (ref_iter >= THREADING_CAPACITY) {
              // Compute absolute positions (accepts float32 precision loss)
              let z_total_r = refr + old_dzr;
              let z_total_i = refi + old_dzi;
              let checkpoint_ref = getRefOrbit(checkpoint_refidx);
              let z_checkpoint_r = checkpoint_ref.x + checkpoint_bb_r;
              let z_checkpoint_i = checkpoint_ref.y + checkpoint_bb_i;

              let diff_r = z_total_r - z_checkpoint_r;
              let diff_i = z_total_i - z_checkpoint_i;
              let db = max(abs(diff_r), abs(diff_i));

              if (db <= epsilon2) {
                if (pp == 0u) {
                  pp = iter;
                }
                if (db <= epsilon) {
                  pixels[index].status = 2u;
                  pixels[index].period = pp;
                  break;
                }
              }
            } else {
              // LAZY THREADING convergence check (high precision)
              // Case 1: ref_iter == checkpoint_refidx (after rebasing or naturally arriving)
              // Compare dz - bb directly (bb equals checkpoint_bb at this point)
              if (ref_iter == checkpoint_refidx) {
                let dz_diff_r = old_dzr - bbr;
                let dz_diff_i = old_dzi - bbi;
                let db = max(abs(dz_diff_r), abs(dz_diff_i));

                if (db <= epsilon2) {
                  if (pp == 0u) {
                    pp = iter;
                  }
                  if (db <= epsilon) {
                    pixels[index].status = 2u;
                    pixels[index].period = pp;
                    break;
                  }
                }
              }

              // Case 2: Check if thread[pending_checkpoint_refidx].next == ref_iter
              // This handles threading case where we lazily follow thread links
              if (pending_checkpoint_refidx >= 2584u &&
                  pending_checkpoint_refidx < params.ref_orbit_length) {
                let thread = getThread(pending_checkpoint_refidx);
                if (thread.x >= 0.0 && u32(thread.x) == ref_iter) {
                  // Check convergence: add thread delta to diff (matches old code)
                  // total_diff = threaded_delta + dz_diff = thread.delta + (dz - bb)
                  let dz_diff_r = old_dzr - bbr + thread.y;
                  let dz_diff_i = old_dzi - bbi + thread.z;
                  let db = max(abs(dz_diff_r), abs(dz_diff_i));

                  if (db <= epsilon2) {
                    if (pp == 0u) {
                      pp = iter;
                    }
                    if (db <= epsilon) {
                      pixels[index].status = 2u;
                      pixels[index].period = pp;
                      break;
                    }
                  }

                  // Update bb for future checks: bb -= thread.delta
                  // So future: dz - bb_new + next_delta = dz - (bb - delta) + next_delta
                  //          = (dz - bb) + delta + next_delta (accumulated)
                  bbr -= thread.y;
                  bbi -= thread.z;
                  pending_checkpoint_refidx = ref_iter;
                }
              }
            }
          }

          iter++;
          ref_iter++;

          // Reference orbit loop: when ref_iter hits threshold, apply delta and jump back
          if (params.loop_enabled != 0u && ref_iter >= params.loop_threshold) {
            dzr += params.loop_delta_r;
            dzi += params.loop_delta_i;
            ref_iter -= params.loop_jump;
          }
        }
        // Write back state to unified pixel struct
        pixels[index].iter = iter;
        pixels[index].period = pp;
        pixels[index].ref_iter = ref_iter;
        pixels[index].ckpt_refidx = checkpoint_refidx;
        pixels[index].pending_refidx = pending_checkpoint_refidx;
        pixels[index].dzr = dzr;
        pixels[index].dzi = dzi;
        pixels[index].bbr = bbr;
        pixels[index].bbi = bbi;
        pixels[index].ckpt_bbr = checkpoint_bb_r;
        pixels[index].ckpt_bbi = checkpoint_bb_i;
      }
    `;

    const shaderModule = this.device.createShaderModule({
      code: shaderCode,
      label: 'Perturbation compute shader'
    });

    this.pipeline = this.device.createComputePipeline({
      layout: 'auto',
      compute: {
        module: shaderModule,
        entryPoint: 'main'
      },
      label: 'Perturbation compute pipeline'
    });
  }

  async compute(targetIters = null) {
    // Prevent concurrent compute() calls
    if (this.isComputing) return;
    this.isComputing = true;
    this.lastBatchCompacted = false;
    const BYTES_PER_PIXEL = GpuZhuoranBoard.BYTES_PER_PIXEL;  // 60 bytes (7 u32 + 8 f32)
    const STRIDE = GpuZhuoranBoard.STRIDE;  // 15 fields per pixel
    const THREADING_CAPACITY = 1048576;  // 2^20
    const BYTES_PER_ITER = 20;  // 5 f32 = 20 bytes

    try {
    // ================================================================
    // STEP 1: Check if done BEFORE submitting new work
    // ================================================================
    if (this.activeCount === 0) {
      if (this.precomputed && this.precomputed.getPendingCount() > 0) {
        const remainingIters = this.precomputed.getPendingIterations();
        for (const iter of remainingIters) {
          const pending = this.precomputed.extractAtIteration(iter);
          if (pending) {
            const divergedIndices = [];
            const convergedData = [];
            for (const idx of pending.diverged) {
              this.nn[idx] = iter;
              this.pp[idx] = 1;
              this.di++;
              this.un--;
              divergedIndices.push(idx);
            }
            for (const c of pending.converged) {
              this.nn[c.index] = -iter;
              this.pp[c.index] = c.p;
              this.un--;
              convergedData.push({ index: c.index, z: c.z, p: c.p });
            }
            if (divergedIndices.length > 0 || convergedData.length > 0) {
              this.queueChanges({ iter, nn: divergedIndices, vv: convergedData });
            }
          }
        }
      }
      this.un = 0;
      if (this.hasPendingResults) {
        await this.flushPendingResults();
      }
      return;
    }
    if (this.un === 0) {
      if (this.hasPendingResults) {
        await this.flushPendingResults();
      }
      return;
    }

    // ================================================================
    // STEP 2: Calculate batch size and extend reference orbit
    // ================================================================
    const pixelsToIterate = this.un + this.ch;
    let iterationsPerBatch;
    if (targetIters !== null) {
      iterationsPerBatch = targetIters;
    } else {
      iterationsPerBatch = Math.max(17, Math.floor(333337 / Math.max(pixelsToIterate, 1)));
    }

    // Extend reference orbit to exactly what this batch needs
    const currentNeed = this.it + iterationsPerBatch;
    const targetRefIterations = Math.min(currentNeed, THREADING_CAPACITY);
    while (!this.refOrbitEscaped && this.refIterations < targetRefIterations) {
      this.extendReferenceOrbit();
    }

    // Setup reference orbit loop when we hit the threading capacity
    if (this.refIterations >= THREADING_CAPACITY && !this.refOrbitLoopConfigured) {
      this.setupReferenceOrbitLoop();
    }

    // ================================================================
    // STEP 3: Upload iteration state to GPU (INCREMENTAL UPLOADS)
    // ================================================================
    const totalIters = this.refIterations + 1;

    // Resize iters buffer if needed, cap at 128MB
    const requiredIterSize = totalIters * BYTES_PER_ITER;
    const maxBufferSize = 128 * 1024 * 1024;
    const allocSize = Math.min(Math.max(requiredIterSize * 2, 1024), maxBufferSize);
    if (this.buffers.iters.size < requiredIterSize &&
        this.buffers.iters.size < allocSize) {
      await this.device.queue.onSubmittedWorkDone();
      this.buffers.iters.destroy();
      this.buffers.iters = this.device.createBuffer({
        size: allocSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        label: 'Iteration state buffer'
      });
      this.lastUploadedIterLength = -1;
      this.createBindGroup();
    }

    // INCREMENTAL UPLOAD: Only upload new iteration data
    if (this.lastUploadedIterLength < this.refIterations) {
      const startIdx = Math.max(0, this.lastUploadedIterLength + 1);
      const maxIters = Math.floor(this.buffers.iters.size / BYTES_PER_ITER);
      const endIdx = Math.min(this.refIterations, maxIters - 1);
      const count = endIdx - startIdx + 1;

      if (count > 0) {
        const iterF32 = new Float32Array(count * 5);

        for (let i = 0; i < count; i++) {
          const iterIdx = startIdx + i;
          const ref = this.refOrbit[iterIdx];
          const thread = this.threading.getThread(iterIdx);

          const base = i * 5;
          iterF32[base + 0] = ref[0] + ref[1];
          iterF32[base + 1] = ref[2] + ref[3];
          if (!thread) {
            iterF32[base + 2] = -1;
            iterF32[base + 3] = 0;
            iterF32[base + 4] = 0;
          } else {
            iterF32[base + 2] = thread.next;
            iterF32[base + 3] = thread.deltaRe;
            iterF32[base + 4] = thread.deltaIm;
          }
        }

        const byteOffset = startIdx * BYTES_PER_ITER;
        this.device.queue.writeBuffer(this.buffers.iters, byteOffset, iterF32);
      }

      this.lastUploadedIterLength = this.refIterations;
    }

    // ================================================================
    // STEP 4: Set up parameters and dispatch GPU (NON-BLOCKING)
    // ================================================================
    const pixelSize = this.pixelSize;
    const checkpointOffsets = [];
    const bufferIter = this.it;
    for (let i = 0; i < iterationsPerBatch; i++) {
      if (fibonacciPeriod(bufferIter + i) === 1) checkpointOffsets.push(i);
    }
    const checkpointCount = Math.min(checkpointOffsets.length, 8);

    const workgroupSize = 64;
    const numWorkgroups = Math.ceil(this.activeCount / workgroupSize);
    const workgroupsX = Math.ceil(Math.sqrt(numWorkgroups));
    const workgroupsY = Math.ceil(numWorkgroups / workgroupsX);

    const paramsBuffer = new ArrayBuffer(128);
    const paramsU32 = new Uint32Array(paramsBuffer);
    const paramsF32 = new Float32Array(paramsBuffer);
    paramsU32[0] = this.config.dimsWidth;
    paramsU32[1] = this.config.dimsHeight;
    paramsU32[2] = iterationsPerBatch;
    paramsU32[3] = this.activeCount;
    paramsU32[4] = this.refIterations + 1;
    paramsU32[5] = this.config.exponent || 2;
    paramsU32[6] = workgroupsX * workgroupSize;
    paramsU32[7] = bufferIter;
    paramsU32[8] = checkpointCount;

    for (let i = 0; i < 8; i++) {
      paramsU32[9 + i] = i < checkpointCount ? checkpointOffsets[i] : 0;
    }

    const loop = this.refOrbitLoop || { enabled: false };
    paramsU32[17] = loop.enabled ? 1 : 0;
    paramsU32[18] = loop.threshold || 0;
    paramsU32[19] = loop.jumpAmount || 0;
    paramsU32[20] = 0;
    paramsF32[21] = pixelSize;
    paramsF32[22] = this.config.aspectRatio;
    paramsF32[23] = loop.deltaR || 0;
    paramsF32[24] = loop.deltaI || 0;

    this.device.queue.writeBuffer(this.buffers.params, 0, paramsBuffer);

    const commandEncoder = this.device.createCommandEncoder({ label: 'Perturbation compute' });
    const passEncoder = commandEncoder.beginComputePass({ label: 'Perturbation pass' });
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, this.bindGroup);
    passEncoder.dispatchWorkgroups(workgroupsX, workgroupsY);
    passEncoder.end();

    // Copy results to current staging buffer (for double-buffering)
    const writeBuffer = this.buffers.stagingPixels[this.stagingBufferIndex];
    const pixelBufferSize = this.activeCount * BYTES_PER_PIXEL;
    commandEncoder.copyBufferToBuffer(this.buffers.pixels, 0, writeBuffer, 0, pixelBufferSize);

    const gpuStartTime = performance.now();
    this.device.queue.submit([commandEncoder.finish()]);
    // GPU is now computing in parallel!

    // Track this batch for later processing
    const newPendingActiveCount = this.activeCount;
    const newStagingIndex = this.stagingBufferIndex;
    this.stagingBufferIndex = 1 - this.stagingBufferIndex;  // Swap for next batch

    // ================================================================
    // STEP 5: Process pending results from PREVIOUS batch (overlaps with GPU)
    // ================================================================
    let pixelU32ForCompaction = null;
    if (this.hasPendingResults) {
      const readBuffer = this.buffers.stagingPixels[1 - newStagingIndex];  // The OTHER buffer
      const readActiveCount = this.pendingActiveCount;
      const readBufferSize = readActiveCount * BYTES_PER_PIXEL;

      // Ensure the previous batch's copy to this buffer is complete before mapping
      await this.device.queue.onSubmittedWorkDone();
      await readBuffer.mapAsync(GPUMapMode.READ);
      const pixelData = new ArrayBuffer(readBufferSize);
      const srcData = readBuffer.getMappedRange();
      new Uint8Array(pixelData).set(new Uint8Array(srcData));
      readBuffer.unmap();

      const pixelU32 = new Uint32Array(pixelData);
      const pixelF32 = new Float32Array(pixelData);

      // Update global iteration counter
      this._baseIt += this.pendingIterationsPerBatch;

      // PixelState struct offsets (15 values per pixel, orig_index at offset 0)
      const INT_ORIG_INDEX = 0, INT_ITER = 1, INT_STATUS = 2, INT_PERIOD = 3, INT_REF_ITER = 4;
      const FLOAT_DZR = 7, FLOAT_DZI = 8;

      // Update board state
      const pixelsByIteration = new Map();
      const convergedByIteration = new Map();
      let hasConverged = false;
      let newDead = 0;

      // First pass: check for diverged pixels and count converged
      for (let i = 0; i < readActiveCount; i++) {
        const idx = i * STRIDE;
        const origIndex = pixelU32[idx + INT_ORIG_INDEX];
        const status = pixelU32[idx + INT_STATUS];
        const period = pixelU32[idx + INT_PERIOD];

        if (this.nn[origIndex] !== 0) continue;

        if (status === 1) {
          const iters = pixelU32[idx + INT_ITER];
          this.nn[origIndex] = iters;
          this.pp[origIndex] = period;

          if (!pixelsByIteration.has(iters)) pixelsByIteration.set(iters, []);
          pixelsByIteration.get(iters).push(origIndex);
          this.di++;
          this.un--;
          newDead++;

          if (this.inSpike && this.inSpike[origIndex] && this.ch > 0) this.ch -= 1;
        } else if (status === 2) {
          hasConverged = true;
        }
      }

      // Second pass: process converged pixels
      if (hasConverged) {
        for (let i = 0; i < readActiveCount; i++) {
          const idx = i * STRIDE;
          const origIndex = pixelU32[idx + INT_ORIG_INDEX];
          const status = pixelU32[idx + INT_STATUS];
          const period = pixelU32[idx + INT_PERIOD];

          if (this.nn[origIndex]) continue;

          if (status === 2) {
            const iters = pixelU32[idx + INT_ITER];
            this.nn[origIndex] = -iters;
            this.pp[origIndex] = period - 1;

            const refIter = pixelU32[idx + INT_REF_ITER];
            const nextRefIter = refIter + 1;
            const dzr = pixelF32[idx + FLOAT_DZR];
            const dzi = pixelF32[idx + FLOAT_DZI];

            const ref = this.refOrbit[Math.min(nextRefIter, this.refOrbit.length - 1)];
            const zr = toDDAdd([ref[0], ref[1]], dzr);
            const zi = toDDAdd([ref[2], ref[3]], dzi);
            if (!convergedByIteration.has(iters)) convergedByIteration.set(iters, []);
            convergedByIteration.get(iters).push({
              index: origIndex,
              z: [zr[0], zr[1], zi[0], zi[1]],
              p: this.pp[origIndex]
            });
            this.un--;
            newDead++;

            if (this.inSpike && this.inSpike[origIndex] && this.ch > 0) this.ch -= 1;
          }
        }
      }

      // Create change objects, merging precomputed points with GPU results
      const gpuIterations = new Set([...pixelsByIteration.keys(), ...convergedByIteration.keys()]);
      const sortedGpuIters = Array.from(gpuIterations).sort((a, b) => a - b);
      const minGpuIter = sortedGpuIters.length > 0 ? sortedGpuIters[0] : null;

      for (const iter of sortedGpuIters) {
        const divergedIndices = [...(pixelsByIteration.get(iter) || [])];
        const convergedData = [...(convergedByIteration.get(iter) || [])];

        if (this.precomputed) {
          if (iter === minGpuIter) {
            const lowPrecomputed = this.precomputed.extractBelowIteration(iter);
            if (lowPrecomputed) {
              for (const idx of lowPrecomputed.diverged) {
                this.nn[idx] = iter;
                this.pp[idx] = 1;
                this.di++;
                this.un--;
                divergedIndices.push(idx);
              }
              for (const c of lowPrecomputed.converged) {
                this.nn[c.index] = -iter;
                this.pp[c.index] = c.p;
                this.un--;
                convergedData.push({ index: c.index, z: c.z, p: c.p });
              }
            }
          }

          const precomputed = this.precomputed.extractAtIteration(iter);
          if (precomputed) {
            for (const idx of precomputed.diverged) {
              this.nn[idx] = iter;
              this.pp[idx] = 1;
              this.di++;
              this.un--;
              divergedIndices.push(idx);
            }
            for (const c of precomputed.converged) {
              this.nn[c.index] = -iter;
              this.pp[c.index] = c.p;
              this.un--;
              convergedData.push({ index: c.index, z: c.z, p: c.p });
            }
          }
        }

        divergedIndices.sort((a, b) => a - b);
        convergedData.sort((a, b) => a.index - b.index);

        if (divergedIndices.length > 0 || convergedData.length > 0) {
          this.queueChanges({ iter, nn: divergedIndices, vv: convergedData });
        }
      }


      this.deadSinceCompaction += newDead;
      this.wastedBandwidth += this.deadSinceCompaction * BYTES_PER_PIXEL;

      // After GPU batch: if all GPU pixels are done but precomputed remain, flush them
      const activeRemaining = this.activeCount - this.deadSinceCompaction;
      if (activeRemaining === 0 && this.precomputed && this.precomputed.getPendingCount() > 0) {
        const remainingIters = this.precomputed.getPendingIterations();
        for (const iter of remainingIters) {
          const pending = this.precomputed.extractAtIteration(iter);
          if (pending) {
            const divergedIndices = [];
            const convergedData = [];
            for (const idx of pending.diverged) {
              this.nn[idx] = iter;
              this.pp[idx] = 1;
              this.di++;
              this.un--;
              divergedIndices.push(idx);
            }
            for (const c of pending.converged) {
              this.nn[c.index] = -iter;
              this.pp[c.index] = c.p;
              this.un--;
              convergedData.push({ index: c.index, z: c.z, p: c.p });
            }
            if (divergedIndices.length > 0 || convergedData.length > 0) {
              this.queueChanges({ iter, nn: divergedIndices, vv: convergedData });
            }
          }
        }
      }

      // Check if compaction is worthwhile based on bandwidth cost
      if (this.shouldCompact()) {
        pixelU32ForCompaction = pixelU32;
      }
    }

    // Compact if needed (must wait for GPU before modifying buffers)
    if (pixelU32ForCompaction) {
      await this.device.queue.onSubmittedWorkDone();
      await this.compactBuffers(pixelU32ForCompaction);
      // After compaction, don't mark new pending - buffers were recreated
      this.hasPendingResults = false;
      return;
    }

    // ================================================================
    // STEP 6: Speculative reference orbit extension while GPU works
    // ================================================================
    const speculativeTimeLimit = 100;  // ms
    const nextBatchIt = this.it + iterationsPerBatch;
    const nextBatchNeed = nextBatchIt + iterationsPerBatch;
    const speculativeTarget = Math.min(
      Math.max(nextBatchNeed + 10000, Math.round(nextBatchNeed * 1.1)),
      THREADING_CAPACITY
    );

    while (!this.refOrbitEscaped &&
           this.refIterations < speculativeTarget &&
           (performance.now() - gpuStartTime) < speculativeTimeLimit) {
      this.extendReferenceOrbit();
    }

    // ================================================================
    // STEP 7: Update pending state for next iteration
    // ================================================================
    this.pendingActiveCount = newPendingActiveCount;
    this.pendingIterationsPerBatch = iterationsPerBatch;
    this.hasPendingResults = true;

    } catch (error) {
      console.error(`GpuZhuoranBoard.compute() ERROR:`, error);
    } finally {
      this.isComputing = false;
    }
  }

  // flushPendingResults() and readPixelBuffer() inherited from GpuZhuoranBaseBoard

  async serialize() {
    // Wait for any in-progress compute() to finish to avoid mapAsync race condition
    while (this.isComputing) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }

    // CRITICAL: Flush pending results before serializing
    if (this.hasPendingResults) {
      await this.flushPendingResults();
    }

    // Ensure GPU is ready before reading buffers
    await this.ensureGPUReady();

    // Read GPU pixel buffer
    const gpuPixelData = await this.readPixelBuffer();

    // Build sparse nn array for completed pixels
    const completedIndexes = [];
    const completedNn = [];
    for (let i = 0; i < this.nn.length; i++) {
      if (this.nn[i] !== 0) {
        completedIndexes.push(i);
        completedNn.push(this.nn[i]);
      }
    }

    return {
      ...(await super.serialize()),
      // GPU pixel buffer as array (for JSON serialization)
      gpuPixelData: gpuPixelData ? Array.from(new Uint8Array(gpuPixelData)) : null,
      // DD reference orbit state
      refOrbit: this.refOrbit,
      refC: this.refC,
      refIterations: this.refIterations,
      refOrbitEscaped: this.refOrbitEscaped,
      refOrbitLoop: this.refOrbitLoop || null,
      refOrbitLoopConfigured: this.refOrbitLoopConfigured || false,
      // Board state
      effort: this.effort,
      completedIndexes,
      completedNn,
      activeCount: this.activeCount,
      deadSinceCompaction: this.deadSinceCompaction,
      wastedBandwidth: this.wastedBandwidth,
    };
  }

  static fromSerialized(serialized) {
    // GPU boards require async initialization, so this returns a board
    // that will continue initializing in the background
    const board = new GpuZhuoranBoard(
      serialized.k,
      serialized.sizesQD[0],
      serialized.sizesQD[1],
      serialized.sizesQD[2],
      serialized.config,
      serialized.id
    );

    // Schedule async restoration after GPU init
    board.gpuInitPromise = board.gpuInitPromise.then(async () => {
      if (serialized.activeCount !== undefined) {
        board.activeCount = serialized.activeCount;
        board.deadSinceCompaction = serialized.deadSinceCompaction || 0;
        board.wastedBandwidth = serialized.wastedBandwidth || 0;
        board.pendingActiveCount = board.activeCount;

        const bufferSize = board.activeCount * GpuZhuoranBoard.BYTES_PER_PIXEL;
        board.buffers.pixels?.destroy();
        board.buffers.pixels = board.device.createBuffer({
          size: bufferSize,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
          label: 'Pixel state buffer (restored)'
        });
        board.buffers.stagingPixels?.forEach(buf => buf.destroy());
        board.buffers.stagingPixels = [
          board.device.createBuffer({
            size: bufferSize,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            label: 'Staging pixels buffer 0 (restored)'
          }),
          board.device.createBuffer({
            size: bufferSize,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            label: 'Staging pixels buffer 1 (restored)'
          })
        ];
        board.createBindGroup();
      }

      // Restore GPU pixel buffer
      if (serialized.gpuPixelData && board.isGPUReady) {
        const pixelData = new Uint8Array(serialized.gpuPixelData).buffer;
        await board.writePixelBuffer(pixelData);
      }

      // Restore DD reference orbit state
      board.refOrbit = serialized.refOrbit || [];
      board.refC = serialized.refC || [0, 0, 0, 0];
      board.refIterations = serialized.refIterations || 1;
      board.refOrbitEscaped = serialized.refOrbitEscaped || false;
      board.refOrbitLoop = serialized.refOrbitLoop || null;
      board.refOrbitLoopConfigured = serialized.refOrbitLoopConfigured || false;

      // Rebuild threading structure from restored reference orbit
      board.rebuildDDThreading();

      // Restore Board state
      board.it = serialized.it;
      board.un = serialized.un;
      board.di = serialized.di;
      board.ch = serialized.ch || 0;
      board.effort = serialized.effort || 2;

      if (serialized.precomputed) {
        board.precomputed = PrecomputedPoints.fromSerialized(serialized.precomputed);
      }

      // Restore nn array
      board.nn = new Array(serialized.config.dimsArea).fill(0);
      if (serialized.completedIndexes) {
        for (let i = 0; i < serialized.completedIndexes.length; i++) {
          board.nn[serialized.completedIndexes[i]] = serialized.completedNn[i];
        }
      }
    });

    return board;
  }
}


/**
 * Adaptive Per-Pixel Scaling GPU Perturbation Board
 *
 * This board uses per-pixel adaptive scaling for deep zooms. It
 * tracks a per-pixel scale exponent that adapts dynamically during iteration.
 *
 * Key insight: Each pixel's perturbation δ is stored as (dz, scale) where
 * δ_actual = dz × 2^scale. When |dz| > 2, we halve dz and increment scale,
 * keeping dz bounded while preserving the actual δ value.
 *
 * This enables accurate escape detection at extreme zoom depths (z=10^40+)
 * where the quadratic term δ² underflows in fixed-scale approaches.
 *
 * See docs/ADAPTIVE-SCALING.md for full mathematical derivation.
 */
// Uses QDReferenceOrbitMixin for reference orbit computation
class AdaptiveGpuBoard extends QDReferenceOrbitMixin(GpuZhuoranBaseBoard) {
  static BYTES_PER_PIXEL = 64;  // 16 × 4 bytes (7 i32 + 8 f32 + 1 i32, with orig_index)
  static STRIDE = 16;           // 16 fields per pixel

  constructor(k, size, re, im, config, id, inheritedData = null) {
    super(k, size, re, im, config, id, inheritedData);
    this.effort = 10;  // Benchmarked: 0.4 ns/px-iter, 10× faster than CPU

    // Initialize QD reference orbit (refC_qd, qdRefOrbit, threading, etc.)
    const refReQD = toQD(re);
    const refImQD = toQD(im);
    this.initQDReferenceOrbit([...refReQD, ...refImQD]);

    // Initialize per-pixel perturbation data (sets initialScale and pixelScale)
    this.initPixels(size, re, im);

    // Initialize double-buffering (from GpuZhuoranBaseBoard)
    this.initDoubleBuffering();

    // Start GPU initialization (async)
    this.gpuInitPromise = this.initGPU();
  }

  // get it(), set it() inherited from GpuZhuoranBaseBoard
  // extendReferenceOrbit() inherited from QDReferenceOrbitMixin

  // Setup reference orbit loop for very long orbits
  setupReferenceOrbitLoop() {
    // When reference orbit hits threading limit, find a close point to loop back to
    const THREADING_CAPACITY = 1048576;  // 2^20
    const SEARCH_WINDOW = 12000;

    if (this.refIterations < THREADING_CAPACITY || this.refOrbitLoopConfigured) {
      return; // Not at limit yet, or already configured
    }

    // Get endpoint (current position at threading limit) - QD precision
    const endpoint = this.qdRefOrbit[THREADING_CAPACITY];

    // Search back to find closest point (using QD arithmetic)
    let closestIter = THREADING_CAPACITY - SEARCH_WINDOW;
    let closestDist = Infinity;
    const tt = this.tt;

    for (let i = THREADING_CAPACITY - SEARCH_WINDOW; i < THREADING_CAPACITY; i++) {
      const pt = this.qdRefOrbit[i];
      // Compute difference in QD precision
      ArqdAdd(tt, 0, endpoint[0], endpoint[1], endpoint[2], endpoint[3],
                     -pt[0], -pt[1], -pt[2], -pt[3]); // dr
      ArqdAdd(tt, 4, endpoint[4], endpoint[5], endpoint[6], endpoint[7],
                     -pt[4], -pt[5], -pt[6], -pt[7]); // di

      // Chebyshev distance: max(|dr|, |di|)
      const dr = tt[0] + tt[1] + tt[2] + tt[3];
      const di = tt[4] + tt[5] + tt[6] + tt[7];
      const dist = Math.max(Math.abs(dr), Math.abs(di));

      if (dist <= closestDist) {  // Use <= to take latest point when tied
        closestDist = dist;
        closestIter = i;
      }
    }

    // Compute delta in QD precision
    const closestPt = this.qdRefOrbit[closestIter];
    ArqdAdd(tt, 0, endpoint[0], endpoint[1], endpoint[2], endpoint[3],
                   -closestPt[0], -closestPt[1], -closestPt[2], -closestPt[3]); // real delta
    ArqdAdd(tt, 4, endpoint[4], endpoint[5], endpoint[6], endpoint[7],
                   -closestPt[4], -closestPt[5], -closestPt[6], -closestPt[7]); // imag delta

    // Store loop parameters with QD precision delta
    const deltaR_qd = [tt[0], tt[1], tt[2], tt[3]];
    const deltaI_qd = [tt[4], tt[5], tt[6], tt[7]];

    this.refOrbitLoop = {
      enabled: true,
      threshold: THREADING_CAPACITY,
      jumpAmount: THREADING_CAPACITY - closestIter,
      deltaR_qd: deltaR_qd,
      deltaI_qd: deltaI_qd,
      deltaR: deltaR_qd[0] + deltaR_qd[1] + deltaR_qd[2] + deltaR_qd[3], // f64 for GPU
      deltaI: deltaI_qd[0] + deltaI_qd[1] + deltaI_qd[2] + deltaI_qd[3]
    };

    this.refOrbitLoopConfigured = true;

    // Update threading for loop segment to wrap around (using QD precision)
    const loopDeltaR = deltaR_qd[0] + deltaR_qd[1] + deltaR_qd[2] + deltaR_qd[3];
    const loopDeltaI = deltaI_qd[0] + deltaI_qd[1] + deltaI_qd[2] + deltaI_qd[3];
    const epsilon3 = this.threading.epsilon3;

    // For each iteration in the loop segment, check if it can thread to another iteration
    // considering the loop wrap (iterations will repeat with a delta offset)
    for (let i = closestIter; i <= THREADING_CAPACITY; i++) {
      const iPt = this.qdRefOrbit[i];
      const iR = iPt[0] + iPt[1] + iPt[2] + iPt[3];
      const iI = iPt[4] + iPt[5] + iPt[6] + iPt[7];

      // Check if we can thread to same or later iteration (considering it will wrap with delta)
      // Allow j = i for self-threading within the loop (period-N orbits repeat with delta)
      for (let j = i; j <= THREADING_CAPACITY; j++) {
        const jPt = this.qdRefOrbit[j];
        // After loop, iteration j will be at position qdRefOrbit[j] + loop_delta
        const jR = jPt[0] + jPt[1] + jPt[2] + jPt[3] + loopDeltaR;
        const jI = jPt[4] + jPt[5] + jPt[6] + jPt[7] + loopDeltaI;

        const dr = iR - jR;
        const di = iI - jI;
        const dist = Math.max(Math.abs(dr), Math.abs(di));

        if (dist <= epsilon3) {
          // Thread i -> j (wrapping through the loop)
          this.threading.setThread(i, j, jR - iR, jI - iI);
          break;  // Take first match
        }
      }
    }
  }

  // Upload combined ref orbit + threading to iters buffer
  async uploadIters() {
    const ITER_BYTES = 20;  // 5 f32 per iteration
    const threadingData = this.threading.threads;
    const totalIters = this.refIterations + 1;

    // Resize iters buffer if needed
    const requiredSize = totalIters * ITER_BYTES;
    if (this.buffers.iters.size < requiredSize) {
      await this.device.queue.onSubmittedWorkDone();
      this.buffers.iters.destroy();
      this.buffers.iters = this.device.createBuffer({
        size: Math.max(requiredSize * 2, 1024),
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
      });
      this.createBindGroup();
      this.lastUploadedItersLength = -1;  // Force full re-upload after resize
    }

    // Upload incrementally from lastUploadedItersLength
    if (this.lastUploadedItersLength < this.refIterations) {
      const startIdx = Math.max(0, this.lastUploadedItersLength + 1);
      const count = this.refIterations - startIdx + 1;

      // IterState: [ref_re, ref_im, thread_next, thread_delta_re, thread_delta_im]
      const itersF32 = new Float32Array(count * 5);
      for (let i = 0; i < count; i++) {
        const orbitIdx = startIdx + i;
        const ref = this.qdRefOrbit[orbitIdx];
        const thread = threadingData[orbitIdx] || { next: -1, deltaRe: 0, deltaIm: 0 };

        const idx = i * 5;
        // Sum QD components to get f32 value for ref orbit
        itersF32[idx + 0] = ref ? ref[0] + ref[1] + ref[2] + ref[3] : 0;  // ref_re
        itersF32[idx + 1] = ref ? ref[4] + ref[5] + ref[6] + ref[7] : 0;  // ref_im
        itersF32[idx + 2] = thread.next;      // thread_next
        itersF32[idx + 3] = thread.deltaRe;   // thread_delta_re
        itersF32[idx + 4] = thread.deltaIm;   // thread_delta_im
      }

      this.device.queue.writeBuffer(this.buffers.iters, startIdx * ITER_BYTES, itersF32);
      this.lastUploadedItersLength = this.refIterations;
    }
  }

  initPixels(size, re, im) {
    const dimsWidth = this.config.dimsWidth;
    const dimsHeight = this.config.dimsHeight;
    const dimsArea = this.config.dimsArea;

    // Convert size to scalar if it's a QD array
    const size_scalar = Array.isArray(size) ? size.reduce((a, b) => a + (b || 0), 0) : size;
    const pixelSize = size_scalar / dimsWidth;

    // Compute initial scale: k = floor(log2(pixelSize))
    const log2_pixelSize = Math.log2(pixelSize);
    this.initialScale = Math.floor(log2_pixelSize);

    // Mantissa factor: 2^(log2(pixelSize) - k) is in [1, 2)
    const mantissa = Math.pow(2, log2_pixelSize - this.initialScale);

    // Per-pixel data arrays
    this.dc = new Float32Array(dimsArea * 2);       // Delta c [real, imag] pairs
    this.dz = new Float32Array(dimsArea * 2);       // Current perturbation delta [real, imag]
    this.pixelScale = new Int32Array(dimsArea);     // Per-pixel scale exponent
    this.refIter = new Uint32Array(dimsArea);       // Reference iteration index

    // Initialize each pixel
    // Both x and y offsets are in raw pixel units. The pixelSize (size/dimsWidth) is
    // already correct because sizeY = size/aspectRatio = size*dimsHeight/dimsWidth,
    // and sizeY/dimsHeight = size/dimsWidth = pixelSize. So no extra scaling needed.
    for (let y = 0; y < dimsHeight; y++) {
      const yOffset = dimsHeight / 2 - y;

      for (let x = 0; x < dimsWidth; x++) {
        const xOffset = x - dimsWidth / 2;

        const index = y * dimsWidth + x;
        const index2 = index * 2;

        // δc_stored = mantissa × pixel_offset (normalized to [~-1, ~+1] range)
        this.dc[index2] = Math.fround(mantissa * xOffset);
        this.dc[index2 + 1] = Math.fround(mantissa * yOffset);

        // Start with dz = dc
        this.dz[index2] = this.dc[index2];
        this.dz[index2 + 1] = this.dc[index2 + 1];

        // All pixels start with the same scale
        this.pixelScale[index] = this.initialScale;

        // Start at iteration 1
        this.refIter[index] = 1;
      }
    }

    this.checkSpike(size, re, im);
  }

  initPixelsQD() {
    // Override to prevent parent from overwriting our scaled arrays
  }

  async createBuffers() {
    const dimsArea = this.config.dimsArea;
    const STRIDE = AdaptiveGpuBoard.STRIDE;  // 16 fields per pixel

    // Consolidated 3-binding layout:
    // 0: params (uniform)
    // 1: pixels (PixelState): 7 i32 + 8 f32 + 1 i32 = 64 bytes per pixel (with orig_index)
    // 2: iters (IterState): 5 f32 = 20 bytes per iteration (refOrbit + threading combined)
    const PIXEL_BYTES = AdaptiveGpuBoard.BYTES_PER_PIXEL;  // 64 bytes
    const ITER_BYTES = 20;   // 5 × 4 bytes

    const precomputedCount = this.precomputed ? this.precomputed.getPrecomputedCount() : 0;
    const activePixelCount = dimsArea - precomputedCount;
    const pixelBufferSize = Math.max(PIXEL_BYTES, activePixelCount * PIXEL_BYTES);
    this.buffers = {
      params: this.device.createBuffer({
        size: 128,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      }),
      pixels: this.device.createBuffer({
        size: pixelBufferSize,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
      }),
      iters: this.device.createBuffer({
        size: 1024 * ITER_BYTES,  // Start small, will resize as needed
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
      }),
      // Double-buffered staging for overlapping CPU/GPU work
      stagingPixels: [
        this.device.createBuffer({
          size: pixelBufferSize,
          usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
          label: 'Staging pixels buffer 0'
        }),
        this.device.createBuffer({
          size: pixelBufferSize,
          usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
          label: 'Staging pixels buffer 1'
        })
      ]
    };

    // Initialize pixels buffer with overlapping typed array views
    // PixelState layout: [orig_index, iter, status, period, ref_iter, ckpt_refidx, pending_refidx,
    //                     dzr, dzi, bbr, bbi, ckpt_bbr, ckpt_bbi, dcr, dci, scale]
    const pixelBuffer = new ArrayBuffer(pixelBufferSize);
    const pixelsI32 = new Int32Array(pixelBuffer);
    const pixelsF32 = new Float32Array(pixelBuffer);

    let activeIdx = 0;
    for (let i = 0; i < dimsArea; i++) {
      if (this.precomputed && this.precomputed.isPrecomputed(i)) {
        continue;
      }
      const idx = activeIdx * STRIDE;  // 16 fields per pixel
      // Integer fields (indices 0-6)
      pixelsI32[idx + 0] = i;                    // orig_index (for coordinate computation after compaction)
      pixelsI32[idx + 1] = 1;                    // iter starts at 1
      pixelsI32[idx + 2] = 0;                    // status = computing
      pixelsI32[idx + 3] = 0;                    // period = 0
      pixelsI32[idx + 4] = this.refIter[i];     // ref_iter
      pixelsI32[idx + 5] = -1;                   // ckpt_refidx (-1 = no checkpoint)
      pixelsI32[idx + 6] = -1;                   // pending_refidx
      // Float fields (indices 7-14)
      pixelsF32[idx + 7] = this.dz[i * 2];      // dzr (scaled by per-pixel scale)
      pixelsF32[idx + 8] = this.dz[i * 2 + 1];  // dzi
      pixelsF32[idx + 9] = 0;                    // bbr (scaled by initialScale)
      pixelsF32[idx + 10] = 0;                   // bbi
      pixelsF32[idx + 11] = 0;                   // ckpt_bbr
      pixelsF32[idx + 12] = 0;                   // ckpt_bbi
      pixelsF32[idx + 13] = this.dc[i * 2];     // dcr (scaled by initialScale)
      pixelsF32[idx + 14] = this.dc[i * 2 + 1]; // dci
      // AdaptiveGpuBoard-specific field at end (index 15)
      pixelsI32[idx + 15] = this.pixelScale[i]; // scale from initPixels
      activeIdx++;
    }
    this.device.queue.writeBuffer(this.buffers.pixels, 0, pixelBuffer);

    this.lastUploadedItersLength = -1;
    this.activeCount = activePixelCount;
    this.pendingActiveCount = activePixelCount;
    this.deadSinceCompaction = 0;
    this.wastedBandwidth = 0;
  }

  createBindGroup() {
    this.bindGroup = this.device.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: this.buffers.params } },
        { binding: 1, resource: { buffer: this.buffers.pixels } },
        { binding: 2, resource: { buffer: this.buffers.iters } }
      ]
    });
  }

  async createComputePipeline() {
    // Consolidated 3-binding adaptive per-pixel scaling perturbation shader
    // Scale conventions:
    //   dz: per-pixel adaptive scale
    //   bb, checkpoint_bb, dc: global initialScale (Option C)
    // Lazy threading: bb gets modified by thread deltas, checkpoint_bb stores original for reset
    const shaderCode = `
      struct Params {
        dims_width: u32,
        dims_height: u32,
        iterations_per_batch: u32,
        active_count: u32,
        ref_orbit_length: u32,
        exponent: u32,
        workgroups_x: u32,
        start_iter: u32,
        checkpoint_count: u32,
        ckpt0: u32,
        ckpt1: u32,
        ckpt2: u32,
        ckpt3: u32,
        ckpt4: u32,
        ckpt5: u32,
        ckpt6: u32,
        ckpt7: u32,
        loop_enabled: u32,
        loop_threshold: u32,
        loop_jump: u32,
        initial_scale: i32,    // Global scale for dc, bb, threaded_delta
        pixel_size: f32,
        aspect_ratio: f32,
        loop_delta_r: f32,
        loop_delta_i: f32,
      }

      // Per-pixel state: 7 i32 + 8 f32 + 1 i32 = 64 bytes (with orig_index for compaction)
      // Layout matches GpuZhuoranBoard for first 15 fields (scale at end)
      // Layout (i32/u32 view):
      //   [0] orig_index: i32  (original pixel index for sparse processing)
      //   [1] iter: i32
      //   [2] status: i32
      //   [3] period: i32
      //   [4] ref_iter: i32
      //   [5] ckpt_refidx: i32
      //   [6] pending_refidx: i32
      //   [7] dzr: f32
      //   [8] dzi: f32
      //   [9] bbr: f32
      //   [10] bbi: f32
      //   [11] ckpt_bbr: f32
      //   [12] ckpt_bbi: f32
      //   [13] dcr: f32
      //   [14] dci: f32
      //   [15] scale: i32  (AdaptiveGpuBoard-specific, at end for layout compatibility)
      struct PixelState {
        // Integer fields (7 i32) - orig_index first, then matches GpuZhuoranBoard
        orig_index: i32,
        iter: i32,
        status: i32,
        period: i32,
        ref_iter: i32,
        ckpt_refidx: i32,
        pending_refidx: i32,
        // Float fields (8 f32)
        dzr: f32,
        dzi: f32,
        bbr: f32,
        bbi: f32,
        ckpt_bbr: f32,
        ckpt_bbi: f32,
        dcr: f32,
        dci: f32,
        // AdaptiveGpuBoard-specific field at end
        scale: i32,
      }

      // Per-iteration state (reference orbit + threading): 5 f32 = 20 bytes
      // Layout (f32 view):
      //   [0] ref_re: f32
      //   [1] ref_im: f32
      //   [2] thread_next: f32
      //   [3] thread_delta_re: f32
      //   [4] thread_delta_im: f32
      struct IterState {
        ref_re: f32,
        ref_im: f32,
        thread_next: f32,
        thread_delta_re: f32,
        thread_delta_im: f32,
      }

      @group(0) @binding(0) var<uniform> params: Params;
      @group(0) @binding(1) var<storage, read_write> pixels: array<PixelState>;
      @group(0) @binding(2) var<storage, read> iters: array<IterState>;

      fn getThread(idx: u32) -> vec3<f32> {
        if (idx >= params.ref_orbit_length) { return vec3<f32>(-1.0, 0.0, 0.0); }
        let iter_data = iters[idx];
        return vec3<f32>(iter_data.thread_next,
          iter_data.thread_delta_re, iter_data.thread_delta_im);
      }

      fn getRefOrbit(idx: u32) -> vec2<f32> {
        if (idx >= params.ref_orbit_length) { return vec2<f32>(0.0, 0.0); }
        return vec2<f32>(iters[idx].ref_re, iters[idx].ref_im);
      }

      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
        let index = global_id.y * params.workgroups_x + global_id.x;
        if (index >= params.active_count) { return; }

        // Read pixel state
        let status = pixels[index].status;
        if (status != 0) { return; }

        var iter = u32(pixels[index].iter);
        var scale = pixels[index].scale;
        var pp = u32(pixels[index].period);
        var ref_iter = u32(pixels[index].ref_iter);
        var checkpoint_refidx = u32(pixels[index].ckpt_refidx);
        var pending_checkpoint_refidx = u32(pixels[index].pending_refidx);

        // Read float state (all checkpoint-related values in initialScale)
        var dzr = pixels[index].dzr;
        var dzi = pixels[index].dzi;
        var bbr = pixels[index].bbr;
        var bbi = pixels[index].bbi;
        var checkpoint_bb_r = pixels[index].ckpt_bbr;
        var checkpoint_bb_i = pixels[index].ckpt_bbi;
        let dcr = pixels[index].dcr;
        let dci = pixels[index].dci;

        // Convergence thresholds - scaled by initialScale for comparison (no iteration-based escalation)
        let epsilon_base = params.pixel_size / 10.0;
        let epsilon2_base = params.pixel_size * 10.0;
        // Convert to initialScale for scaled comparisons
        let epsilon = ldexp(epsilon_base, -params.initial_scale);
        let epsilon2 = ldexp(epsilon2_base, -params.initial_scale);

        // Track next checkpoint using O(1) counter for adaptive checkpoints
        var next_checkpoint_idx = 0u;

        for (var batch_iter = 0u; batch_iter < params.iterations_per_batch; batch_iter++) {
          if (pixels[index].status != 0) { break; }

          if (ref_iter >= params.ref_orbit_length) { break; }

          let ref_orbit = getRefOrbit(ref_iter);
          var refr = ref_orbit.x;
          var refi = ref_orbit.y;

          // Compute actual delta and position: z = Z_ref + δ_actual
          var dzr_actual = 0.0;
          var dzi_actual = 0.0;
          if (scale >= -126) {
            dzr_actual = ldexp(dzr, scale);
            dzi_actual = ldexp(dzi, scale);
          }
          var zr = refr + dzr_actual;
          var zi = refi + dzi_actual;

          // === ESCAPE CHECK ===
          // Check BEFORE rebasing to match QDZhuoranBoard behavior
          let z_mag_sq = zr * zr + zi * zi;
          // Check divergence (escape radius 2, or NaN/Infinity from numerical errors)
          if (z_mag_sq > 4.0 || !(z_mag_sq <= 1e38)) {  // NaN/Inf check: !(x <= large) catches both
            pixels[index].status = 1;
            pixels[index].period = i32(pp);
            break;
          }

          // === REBASING ===
          let z_norm = max(abs(zr), abs(zi));
          let dz_norm = max(abs(dzr_actual), abs(dzi_actual));
          if (ref_iter > 0u && z_norm < dz_norm * 2.0) {
            let new_log2 = floor(log2(z_norm));
            let new_scale = max(i32(new_log2), params.initial_scale);
            dzr = ldexp(zr, -new_scale);
            dzi = ldexp(zi, -new_scale);
            scale = new_scale;
            ref_iter = 0u;

            // Reset lazy threading state after rebase
            if (checkpoint_refidx != 0xFFFFFFFFu) {
              pending_checkpoint_refidx = checkpoint_refidx;
              bbr = checkpoint_bb_r;
              bbi = checkpoint_bb_i;
            }

            let ref0 = getRefOrbit(0u);
            refr = ref0.x;
            refi = ref0.y;
            dzr_actual = ldexp(dzr, scale);
            dzi_actual = ldexp(dzi, scale);
            zr = refr + dzr_actual;
            zi = refi + dzi_actual;
          }

          // === CONVERGENCE DETECTION ===
          // bb and threaded_delta are in initialScale, so convert dz to initialScale for comparison
          var just_updated = false;
          if (next_checkpoint_idx < params.checkpoint_count) {
            var checkpoint_offset = 0u;
            switch (next_checkpoint_idx) {
              case 0u: { checkpoint_offset = params.ckpt0; }
              case 1u: { checkpoint_offset = params.ckpt1; }
              case 2u: { checkpoint_offset = params.ckpt2; }
              case 3u: { checkpoint_offset = params.ckpt3; }
              case 4u: { checkpoint_offset = params.ckpt4; }
              case 5u: { checkpoint_offset = params.ckpt5; }
              case 6u: { checkpoint_offset = params.ckpt6; }
              case 7u: { checkpoint_offset = params.ckpt7; }
              default: {}
            }

            if (batch_iter == checkpoint_offset) {
              just_updated = true;
              // Store bb and checkpoint_bb in initialScale: bb = dz_actual / 2^initialScale
              let bb_val_r = ldexp(dzr_actual, -params.initial_scale);
              let bb_val_i = ldexp(dzi_actual, -params.initial_scale);
              bbr = bb_val_r;
              bbi = bb_val_i;
              checkpoint_bb_r = bb_val_r;  // Save original for reset after rebase
              checkpoint_bb_i = bb_val_i;
              checkpoint_refidx = ref_iter;
              pending_checkpoint_refidx = ref_iter;  // Start lazy threading at checkpoint
              pp = 0u;
              next_checkpoint_idx = next_checkpoint_idx + 1u;
            }
          }

          // Check convergence with lazy threading (all comparisons in initialScale)
          if (checkpoint_refidx != 0xFFFFFFFFu && !just_updated && scale >= -126) {
              // LAZY THREADING convergence check in initialScale
              // Convert current dz to initialScale for comparison
              let dzr_scaled = ldexp(dzr_actual, -params.initial_scale);
              let dzi_scaled = ldexp(dzi_actual, -params.initial_scale);

              // Case 1: ref_iter == checkpoint_refidx (after rebasing or naturally arriving)
              if (ref_iter == checkpoint_refidx) {
                let dz_diff_r = dzr_scaled - bbr;
                let dz_diff_i = dzi_scaled - bbi;
                let db = max(abs(dz_diff_r), abs(dz_diff_i));

                if (db <= epsilon2) {
                  if (pp == 0u) { pp = iter; }
                  if (db <= epsilon) {
                    pixels[index].status = 2;
                    pixels[index].period = i32(pp);
                    break;
                  }
                }
              }

              // Case 2: Check if thread[pending_checkpoint_refidx].next == ref_iter
              if (pending_checkpoint_refidx >= 2584u &&
                  pending_checkpoint_refidx < params.ref_orbit_length) {
                let thread = getThread(pending_checkpoint_refidx);
                if (thread.x >= 0.0 && u32(thread.x) == ref_iter) {
                  // Check convergence: add thread delta to diff (convert to initialScale)
                  let thread_r_scaled = ldexp(thread.y, -params.initial_scale);
                  let thread_i_scaled = ldexp(thread.z, -params.initial_scale);
                  let dz_diff_r = dzr_scaled - bbr + thread_r_scaled;
                  let dz_diff_i = dzi_scaled - bbi + thread_i_scaled;
                  let db = max(abs(dz_diff_r), abs(dz_diff_i));

                  if (db <= epsilon2) {
                    if (pp == 0u) { pp = iter; }
                    if (db <= epsilon) {
                      pixels[index].status = 2;
                      pixels[index].period = i32(pp);
                      break;
                    }
                  }

                  // Update bb for future checks: bb -= thread.delta
                  bbr = bbr - thread_r_scaled;
                  bbi = bbi - thread_i_scaled;
                  pending_checkpoint_refidx = ref_iter;
                }
              }
          }

          // === PERTURBATION ITERATION ===
          // Binomial expansion: (Z+δz)^n - Z^n = Σ C(n,k)·Z^(n-k)·δz^k
          // All terms computed in scaled coordinates to avoid float32 overflow
          var new_dzr: f32;
          var new_dzi: f32;
          let scale_diff = params.initial_scale - scale;
          let dc_r = ldexp(dcr, scale_diff);
          let dc_i = ldexp(dci, scale_diff);

          if (params.exponent == 2u) {
            // z² + c: 2·Z·δz + δz²
            let linear_r = 2.0 * (refr * dzr - refi * dzi);
            let linear_i = 2.0 * (refr * dzi + refi * dzr);
            let dz2_r = ldexp(dzr * dzr - dzi * dzi, scale);
            let dz2_i = ldexp(2.0 * dzr * dzi, scale);
            new_dzr = linear_r + dz2_r + dc_r;
            new_dzi = linear_i + dz2_i + dc_i;
          } else if (params.exponent == 3u) {
            // z³ + c: 3·Z²·δz + 3·Z·δz² + δz³
            let ref2_r = refr * refr - refi * refi;
            let ref2_i = 2.0 * refr * refi;
            let t1_r = 3.0 * (ref2_r * dzr - ref2_i * dzi);
            let t1_i = 3.0 * (ref2_r * dzi + ref2_i * dzr);
            let dz2_r = dzr * dzr - dzi * dzi;
            let dz2_i = 2.0 * dzr * dzi;
            let t2_r = ldexp(3.0 * (refr * dz2_r - refi * dz2_i), scale);
            let t2_i = ldexp(3.0 * (refr * dz2_i + refi * dz2_r), scale);
            let dz3_r = dzr * dz2_r - dzi * dz2_i;
            let dz3_i = dzr * dz2_i + dzi * dz2_r;
            let t3_r = ldexp(dz3_r, scale + scale);
            let t3_i = ldexp(dz3_i, scale + scale);
            new_dzr = t1_r + t2_r + t3_r + dc_r;
            new_dzi = t1_i + t2_i + t3_i + dc_i;
          } else if (params.exponent == 4u) {
            // z⁴ + c: 4·Z³·δz + 6·Z²·δz² + 4·Z·δz³ + δz⁴
            let ref2_r = refr * refr - refi * refi;
            let ref2_i = 2.0 * refr * refi;
            let ref3_r = refr * ref2_r - refi * ref2_i;
            let ref3_i = refr * ref2_i + refi * ref2_r;
            let t1_r = 4.0 * (ref3_r * dzr - ref3_i * dzi);
            let t1_i = 4.0 * (ref3_r * dzi + ref3_i * dzr);
            let dz2_r = dzr * dzr - dzi * dzi;
            let dz2_i = 2.0 * dzr * dzi;
            let t2_r = ldexp(6.0 * (ref2_r * dz2_r - ref2_i * dz2_i), scale);
            let t2_i = ldexp(6.0 * (ref2_r * dz2_i + ref2_i * dz2_r), scale);
            let dz3_r = dzr * dz2_r - dzi * dz2_i;
            let dz3_i = dzr * dz2_i + dzi * dz2_r;
            let t3_r = ldexp(4.0 * (refr * dz3_r - refi * dz3_i), scale + scale);
            let t3_i = ldexp(4.0 * (refr * dz3_i + refi * dz3_r), scale + scale);
            let dz4_r = dz2_r * dz2_r - dz2_i * dz2_i;
            let dz4_i = 2.0 * dz2_r * dz2_i;
            let t4_r = ldexp(dz4_r, scale + scale + scale);
            let t4_i = ldexp(dz4_i, scale + scale + scale);
            new_dzr = t1_r + t2_r + t3_r + t4_r + dc_r;
            new_dzi = t1_i + t2_i + t3_i + t4_i + dc_i;
          } else {
            // Higher exponents: use direct computation (less efficient)
            let dzr_actual = ldexp(dzr, scale);
            let dzi_actual = ldexp(dzi, scale);
            var zr = refr + dzr_actual;
            var zi = refi + dzi_actual;
            var zn_r = zr;
            var zn_i = zi;
            for (var p = 1u; p < params.exponent; p++) {
              let temp_r = zn_r * zr - zn_i * zi;
              zn_i = zn_r * zi + zn_i * zr;
              zn_r = temp_r;
            }
            var refn_r = refr;
            var refn_i = refi;
            for (var p = 1u; p < params.exponent; p++) {
              let temp_r = refn_r * refr - refn_i * refi;
              refn_i = refn_r * refi + refn_i * refr;
              refn_r = temp_r;
            }
            new_dzr = (zn_r - refn_r) + dc_r;
            new_dzi = (zn_i - refn_i) + dc_i;
          }
          var new_scale = scale;

          // === ADAPTIVE RESCALING ===
          let dz_mag = max(abs(new_dzr), abs(new_dzi));
          if (dz_mag > 0.0 && dz_mag < 1e30) {  // Guard against Infinity/NaN
            let log2_mag = floor(log2(dz_mag));
            if (log2_mag >= 1.0) {
              let steps = i32(log2_mag);
              // Clamp scale to prevent overflow (max scale ~100, min scale ~initial_scale)
              if (new_scale + steps <= 100) {
                new_dzr = ldexp(new_dzr, -steps);
                new_dzi = ldexp(new_dzi, -steps);
                new_scale = new_scale + steps;
              }
            } else if (log2_mag < -1.0 && new_scale > params.initial_scale) {
              let steps = min(i32(-log2_mag) - 1, new_scale - params.initial_scale);
              if (steps > 0) {
                new_dzr = ldexp(new_dzr, steps);
                new_dzi = ldexp(new_dzi, steps);
                new_scale = new_scale - steps;
              }
            }
          }

          dzr = new_dzr;
          dzi = new_dzi;
          scale = new_scale;
          ref_iter = ref_iter + 1u;
          iter = iter + 1u;
        }

        // Write back integer state
        pixels[index].iter = i32(iter);
        pixels[index].scale = scale;
        pixels[index].ref_iter = i32(ref_iter);
        pixels[index].ckpt_refidx = i32(checkpoint_refidx);
        pixels[index].pending_refidx = i32(pending_checkpoint_refidx);
        if (pixels[index].status == 0) {
          pixels[index].period = i32(pp);
        }

        // Write back float state
        pixels[index].dzr = dzr;
        pixels[index].dzi = dzi;
        pixels[index].bbr = bbr;
        pixels[index].bbi = bbi;
        pixels[index].ckpt_bbr = checkpoint_bb_r;
        pixels[index].ckpt_bbi = checkpoint_bb_i;
      }
    `;

    const shaderModule = this.device.createShaderModule({
      code: shaderCode,
      label: 'Adaptive per-pixel scaling perturbation shader'
    });

    // Check for shader compilation errors
    const compilationInfo = await shaderModule.getCompilationInfo();
    for (const msg of compilationInfo.messages) {
      const level = msg.type === 'error' ? 'ERROR' : msg.type === 'warning' ? 'WARN' : 'INFO';
      console.log(`AdaptiveGpuBoard shader ${level}: ${msg.message} ` +
        `(line ${msg.lineNum}, col ${msg.linePos})`);
    }

    this.pipeline = this.device.createComputePipeline({
      layout: 'auto',
      compute: {
        module: shaderModule,
        entryPoint: 'main'
      },
      label: 'Adaptive perturbation pipeline'
    });
  }

  async compute(targetIters = null) {
    // Prevent concurrent compute() calls
    if (this.isComputing) return;
    this.isComputing = true;
    this.lastBatchCompacted = false;

    // Wait for async GPU initialization to complete
    await this.gpuInitPromise;

    // GPU required - if device unavailable, computation cannot proceed
    if (!this.device) {
      console.warn('AdaptiveGpuBoard: GPU device not available, cannot compute');
      this.isComputing = false;
      return;
    }

    try {
      const THREADING_CAPACITY = 1048576;
      const BYTES_PER_PIXEL = AdaptiveGpuBoard.BYTES_PER_PIXEL;  // 64 bytes
      const STRIDE = AdaptiveGpuBoard.STRIDE;  // 16 fields

      // ================================================================
      // STEP 1: Check if done BEFORE submitting new work
      // ================================================================
      if (this.activeCount === 0) {
        if (this.precomputed && this.precomputed.getPendingCount() > 0) {
          const remainingIters = this.precomputed.getPendingIterations();
          for (const iter of remainingIters) {
            const pending = this.precomputed.extractAtIteration(iter);
            if (pending) {
              const divergedIndices = [];
              const convergedData = [];
              for (const idx of pending.diverged) {
                this.nn[idx] = iter;
                this.pp[idx] = 1;
                this.di++;
                this.un--;
                divergedIndices.push(idx);
              }
              for (const c of pending.converged) {
                this.nn[c.index] = -iter;
                this.pp[c.index] = c.p;
                this.un--;
                convergedData.push({ index: c.index, z: c.z, p: c.p });
              }
              if (divergedIndices.length > 0 || convergedData.length > 0) {
                this.queueChanges({ iter, nn: divergedIndices, vv: convergedData });
              }
            }
          }
        }
        this.un = 0;
        if (this.hasPendingResults) {
          await this.flushPendingResults();
        }
        return;
      }
      if (this.un === 0) {
        if (this.hasPendingResults) {
          await this.flushPendingResults();
        }
        return;
      }

      // ================================================================
      // STEP 2: Calculate batch size and extend reference orbit
      // ================================================================
      const pixelsToIterate = this.un + this.ch;
      let iterationsPerBatch;
      if (targetIters !== null) {
        iterationsPerBatch = targetIters;
      } else {
        iterationsPerBatch = Math.max(17, Math.floor(333337 / Math.max(pixelsToIterate, 1)));
      }

      // Extend reference orbit to exactly what this batch needs
      const currentNeed = this.it + iterationsPerBatch;
      const targetRefIterations = Math.min(currentNeed, THREADING_CAPACITY);
      while (!this.refOrbitEscaped && this.refIterations < targetRefIterations) {
        this.extendReferenceOrbit();
      }

      // Setup reference orbit loop when we hit the threading capacity
      if (this.refIterations >= THREADING_CAPACITY && !this.refOrbitLoopConfigured) {
        this.setupReferenceOrbitLoop();
      }

      // ================================================================
      // STEP 3: Upload iteration state to GPU
      // ================================================================
      await this.uploadIters();

      // ================================================================
      // STEP 4: Set up parameters and dispatch GPU (NON-BLOCKING)
      // ================================================================
      const checkpointOffsets = [];
      const bufferIter = this.it;
      for (let i = 0; i < iterationsPerBatch; i++) {
        const globalIter = bufferIter + i;
        if (fibonacciPeriod(globalIter) === 1) {
          checkpointOffsets.push(i);
        }
      }
      const checkpointCount = Math.min(checkpointOffsets.length, 8);

      const size_scalar = this.size;
      const pixelSize = size_scalar / this.config.dimsWidth;

      const workgroupSize = 64;
      const numWorkgroups = Math.ceil(this.activeCount / workgroupSize);
      const workgroupsX = Math.ceil(Math.sqrt(numWorkgroups));
      const workgroupsY = Math.ceil(numWorkgroups / workgroupsX);

      const paramsBuffer = new ArrayBuffer(128);
      const paramsU32 = new Uint32Array(paramsBuffer);
      const paramsI32 = new Int32Array(paramsBuffer);
      const paramsF32 = new Float32Array(paramsBuffer);

      paramsU32[0] = this.config.dimsWidth;
      paramsU32[1] = this.config.dimsHeight;
      paramsU32[2] = iterationsPerBatch;
      paramsU32[3] = this.activeCount;
      paramsU32[4] = this.refIterations + 1;
      paramsU32[5] = this.config.exponent || 2;
      paramsU32[6] = workgroupsX * workgroupSize;
      paramsU32[7] = bufferIter;
      paramsU32[8] = checkpointCount;

      for (let i = 0; i < 8; i++) {
        paramsU32[9 + i] = i < checkpointCount ? checkpointOffsets[i] : 0;
      }

      const loop = this.refOrbitLoop || { enabled: false };
      paramsU32[17] = loop.enabled ? 1 : 0;
      paramsU32[18] = loop.threshold || 0;
      paramsU32[19] = loop.jumpAmount || 0;
      paramsI32[20] = this.initialScale;
      paramsF32[21] = pixelSize;
      paramsF32[22] = this.config.aspectRatio;
      paramsF32[23] = loop.deltaR || 0;
      paramsF32[24] = loop.deltaI || 0;

      this.device.queue.writeBuffer(this.buffers.params, 0, paramsBuffer);

      const commandEncoder = this.device.createCommandEncoder(
        { label: 'Adaptive perturbation compute' });
      const passEncoder = commandEncoder.beginComputePass(
        { label: 'Adaptive perturbation pass' });
      passEncoder.setPipeline(this.pipeline);
      passEncoder.setBindGroup(0, this.bindGroup);
      passEncoder.dispatchWorkgroups(workgroupsX, workgroupsY);
      passEncoder.end();

      // Copy results to current staging buffer (for double-buffering)
      const writeBuffer = this.buffers.stagingPixels[this.stagingBufferIndex];
      const pixelBufferSize = this.activeCount * BYTES_PER_PIXEL;
      commandEncoder.copyBufferToBuffer(this.buffers.pixels, 0, writeBuffer, 0, pixelBufferSize);

      const gpuStartTime = performance.now();
      this.device.queue.submit([commandEncoder.finish()]);
      // GPU is now computing in parallel!

      // Track this batch for later processing
      const newPendingActiveCount = this.activeCount;
      const newStagingIndex = this.stagingBufferIndex;
      this.stagingBufferIndex = 1 - this.stagingBufferIndex;  // Swap for next batch

      // ================================================================
      // STEP 5: Process pending results from PREVIOUS batch (overlaps with GPU)
      // ================================================================
      let pixelU32ForCompaction = null;
      if (this.hasPendingResults) {
        const readBuffer = this.buffers.stagingPixels[1 - newStagingIndex];  // The OTHER buffer
        const readActiveCount = this.pendingActiveCount;
        const readBufferSize = readActiveCount * BYTES_PER_PIXEL;

        // Ensure the previous batch's copy to this buffer is complete before mapping
        await this.device.queue.onSubmittedWorkDone();
        await readBuffer.mapAsync(GPUMapMode.READ);
        const pixelData = new ArrayBuffer(readBufferSize);
        const srcData = readBuffer.getMappedRange();
        new Uint8Array(pixelData).set(new Uint8Array(srcData));
        readBuffer.unmap();

        const pixelsI32 = new Int32Array(pixelData);
        const pixelsF32 = new Float32Array(pixelData);

        // Update global iteration counter
        this._baseIt += this.pendingIterationsPerBatch;

        // PixelState field indices (16 fields per pixel, orig_index at 0)
        const P_ORIG_INDEX = 0, P_ITER = 1, P_STATUS = 2, P_PERIOD = 3, P_REF_ITER = 4;
        const P_DZR = 7, P_DZI = 8, P_SCALE = 15;

        // Process GPU results
        const pixelsByIteration = new Map();
        const convergedByIteration = new Map();
        let hasConverged = false;
        let newDead = 0;

        for (let i = 0; i < readActiveCount; i++) {
          const idx = i * STRIDE;
          const origIndex = pixelsI32[idx + P_ORIG_INDEX];
          const status = pixelsI32[idx + P_STATUS];
          const period = pixelsI32[idx + P_PERIOD];
          if (this.nn[origIndex] !== 0) continue;
          if (status === 1) {
            const iters = pixelsI32[idx + P_ITER];
            this.nn[origIndex] = iters;
            this.pp[origIndex] = period;
            if (!pixelsByIteration.has(iters)) pixelsByIteration.set(iters, []);
            pixelsByIteration.get(iters).push(origIndex);
            this.di++;
            this.un--;
            newDead++;
            if (this.inSpike && this.inSpike[origIndex] && this.ch > 0) this.ch -= 1;
          } else if (status === 2) {
            hasConverged = true;
          }
        }

        if (hasConverged) {
          for (let i = 0; i < readActiveCount; i++) {
            const idx = i * STRIDE;
            const origIndex = pixelsI32[idx + P_ORIG_INDEX];
            const status = pixelsI32[idx + P_STATUS];
            const period = pixelsI32[idx + P_PERIOD];
            if (this.nn[origIndex]) continue;
            if (status === 2) {
              const iters = pixelsI32[idx + P_ITER];
              this.nn[origIndex] = -iters;
              this.pp[origIndex] = period - 1;
              const refIter = pixelsI32[idx + P_REF_ITER];
              const scale = pixelsI32[idx + P_SCALE];
              const dzr = pixelsF32[idx + P_DZR] * Math.pow(2, scale);
              const dzi = pixelsF32[idx + P_DZI] * Math.pow(2, scale);
              const ref = this.qdRefOrbit[Math.min(refIter, this.qdRefOrbit.length - 1)];
              const zrQD = toQDAdd([ref[0], ref[1], ref[2], ref[3]], [dzr, 0, 0, 0]);
              const ziQD = toQDAdd([ref[4], ref[5], ref[6], ref[7]], [dzi, 0, 0, 0]);
              if (!convergedByIteration.has(iters)) convergedByIteration.set(iters, []);
              convergedByIteration.get(iters).push(
                { index: origIndex, z: [...zrQD, ...ziQD], p: this.pp[origIndex] });
              this.un--;
              newDead++;
              if (this.inSpike && this.inSpike[origIndex] && this.ch > 0) this.ch -= 1;
            }
          }
        }

        // Queue changes grouped by iteration, merging precomputed points
        const gpuIterations = new Set([...pixelsByIteration.keys(),
                                        ...convergedByIteration.keys()]);
        const sortedGpuIters = Array.from(gpuIterations).sort((a, b) => a - b);
        const minGpuIter = sortedGpuIters.length > 0 ? sortedGpuIters[0] : null;

        for (const iter of sortedGpuIters) {
          const divergedIndices = [...(pixelsByIteration.get(iter) || [])];
          const convergedData = [...(convergedByIteration.get(iter) || [])];

          if (this.precomputed) {
            if (iter === minGpuIter) {
              const lowPrecomputed = this.precomputed.extractBelowIteration(iter);
              if (lowPrecomputed) {
                for (const idx of lowPrecomputed.diverged) {
                  this.nn[idx] = iter;
                  this.pp[idx] = 1;
                  this.di++;
                  this.un--;
                  divergedIndices.push(idx);
                }
                for (const c of lowPrecomputed.converged) {
                  this.nn[c.index] = -iter;
                  this.pp[c.index] = c.p;
                  this.un--;
                  convergedData.push({ index: c.index, z: c.z, p: c.p });
                }
              }
            }

            const precomputed = this.precomputed.extractAtIteration(iter);
            if (precomputed) {
              for (const idx of precomputed.diverged) {
                this.nn[idx] = iter;
                this.pp[idx] = 1;
                this.di++;
                this.un--;
                divergedIndices.push(idx);
              }
              for (const c of precomputed.converged) {
                this.nn[c.index] = -iter;
                this.pp[c.index] = c.p;
                this.un--;
                convergedData.push({ index: c.index, z: c.z, p: c.p });
              }
            }
          }

          divergedIndices.sort((a, b) => a - b);
          convergedData.sort((a, b) => a.index - b.index);

          if (divergedIndices.length > 0 || convergedData.length > 0) {
            this.queueChanges({ iter, nn: divergedIndices, vv: convergedData });
          }
        }

        this.deadSinceCompaction += newDead;
        this.wastedBandwidth += this.deadSinceCompaction * BYTES_PER_PIXEL;

        // After GPU batch: if all GPU pixels are done but precomputed remain, flush them
        const activeRemaining = this.activeCount - this.deadSinceCompaction;
        if (activeRemaining === 0 && this.precomputed && this.precomputed.getPendingCount() > 0) {
          const remainingIters = this.precomputed.getPendingIterations();
          for (const iter of remainingIters) {
            const pending = this.precomputed.extractAtIteration(iter);
            if (pending) {
              const divergedIndices = [];
              const convergedData = [];
              for (const idx of pending.diverged) {
                this.nn[idx] = iter;
                this.pp[idx] = 1;
                this.di++;
                this.un--;
                divergedIndices.push(idx);
              }
              for (const c of pending.converged) {
                this.nn[c.index] = -iter;
                this.pp[c.index] = c.p;
                this.un--;
                convergedData.push({ index: c.index, z: c.z, p: c.p });
              }
              if (divergedIndices.length > 0 || convergedData.length > 0) {
                this.queueChanges({ iter, nn: divergedIndices, vv: convergedData });
              }
            }
          }
        }

        // Check if compaction is worthwhile based on bandwidth cost
        if (this.shouldCompact()) {
          pixelU32ForCompaction = new Uint32Array(pixelData);
        }
      }

      // Compact if needed (must wait for GPU before modifying buffers)
      if (pixelU32ForCompaction) {
        await this.device.queue.onSubmittedWorkDone();
        await this.compactBuffers(pixelU32ForCompaction);
        // After compaction, don't mark new pending - buffers were recreated
        this.hasPendingResults = false;
        return;
      }

      // ================================================================
      // STEP 6: Speculative reference orbit extension while GPU works
      // ================================================================
      const speculativeTimeLimit = 100;  // ms
      const nextBatchIt = this.it + iterationsPerBatch;
      const nextBatchNeed = nextBatchIt + iterationsPerBatch;
      const speculativeTarget = Math.min(
        Math.max(nextBatchNeed + 10000, Math.round(nextBatchNeed * 1.1)),
        THREADING_CAPACITY
      );

      while (!this.refOrbitEscaped &&
             this.refIterations < speculativeTarget &&
             (performance.now() - gpuStartTime) < speculativeTimeLimit) {
        this.extendReferenceOrbit();
      }

      // ================================================================
      // STEP 7: Update pending state for next iteration
      // ================================================================
      this.pendingActiveCount = newPendingActiveCount;
      this.pendingIterationsPerBatch = iterationsPerBatch;
      this.hasPendingResults = true;

    } catch (error) {
      console.error('AdaptiveGpuBoard.compute() ERROR:',
        error?.message || error, error?.stack || '');
    } finally {
      this.isComputing = false;
    }
  }

  // flushPendingResults() and readPixelBuffer() inherited from GpuZhuoranBaseBoard

  async serialize() {
    // Wait for any in-progress compute() to finish to avoid mapAsync race condition
    while (this.isComputing) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }

    // CRITICAL: Flush pending results before serializing
    if (this.hasPendingResults) {
      await this.flushPendingResults();
    }

    // Ensure GPU is ready before reading buffers
    await this.ensureGPUReady();

    // Read GPU pixel buffer
    const gpuPixelData = await this.readPixelBuffer();

    // Build sparse nn array for completed pixels
    const completedIndexes = [];
    const completedNn = [];
    for (let i = 0; i < this.nn.length; i++) {
      if (this.nn[i] !== 0) {
        completedIndexes.push(i);
        completedNn.push(this.nn[i]);
      }
    }

    return {
      ...(await super.serialize()),
      // GPU pixel buffer as array (for JSON serialization)
      gpuPixelData: gpuPixelData ? Array.from(new Uint8Array(gpuPixelData)) : null,
      // QD reference orbit state
      qdRefOrbit: this.qdRefOrbit,
      refC_qd: this.refC_qd,
      refIterations: this.refIterations,
      refOrbitEscaped: this.refOrbitEscaped,
      refOrbitLoop: this.refOrbitLoop || null,
      refOrbitLoopConfigured: this.refOrbitLoopConfigured || false,
      // Per-pixel adaptive scaling
      initialScale: this.initialScale,
      // Board state
      effort: this.effort,
      completedIndexes,
      completedNn,
      activeCount: this.activeCount,
      deadSinceCompaction: this.deadSinceCompaction,
      wastedBandwidth: this.wastedBandwidth,
    };
  }

  static fromSerialized(serialized) {
    // GPU boards require async initialization, so this returns a board
    // that will continue initializing in the background
    const board = new AdaptiveGpuBoard(
      serialized.k,
      serialized.sizesQD[0],
      serialized.sizesQD[1],
      serialized.sizesQD[2],
      serialized.config,
      serialized.id
    );

    // Schedule async restoration after GPU init
    board.gpuInitPromise = board.gpuInitPromise.then(async () => {
      if (serialized.activeCount !== undefined) {
        board.activeCount = serialized.activeCount;
        board.deadSinceCompaction = serialized.deadSinceCompaction || 0;
        board.wastedBandwidth = serialized.wastedBandwidth || 0;
        board.pendingActiveCount = board.activeCount;

        const bufferSize = board.activeCount * AdaptiveGpuBoard.BYTES_PER_PIXEL;
        board.buffers.pixels?.destroy();
        board.buffers.pixels = board.device.createBuffer({
          size: bufferSize,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
        });
        board.buffers.stagingPixels?.forEach(buf => buf.destroy());
        board.buffers.stagingPixels = [
          board.device.createBuffer({
            size: bufferSize,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            label: 'Staging pixels buffer 0 (restored)'
          }),
          board.device.createBuffer({
            size: bufferSize,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            label: 'Staging pixels buffer 1 (restored)'
          })
        ];
        board.createBindGroup();
      }

      // Restore GPU pixel buffer
      if (serialized.gpuPixelData && board.isGPUReady) {
        const pixelData = new Uint8Array(serialized.gpuPixelData).buffer;
        await board.writePixelBuffer(pixelData);
      }

      // Restore QD reference orbit state
      board.qdRefOrbit = serialized.qdRefOrbit || [];
      board.refC_qd = serialized.refC_qd || new Array(8).fill(0);
      board.refIterations = serialized.refIterations || 1;
      board.refOrbitEscaped = serialized.refOrbitEscaped || false;
      board.refOrbitLoop = serialized.refOrbitLoop || null;
      board.refOrbitLoopConfigured = serialized.refOrbitLoopConfigured || false;

      // Restore per-pixel adaptive scaling
      if (serialized.initialScale !== undefined) {
        board.initialScale = serialized.initialScale;
      }

      // Rebuild threading structure from restored reference orbit
      board.rebuildQDThreading();

      // Restore Board state
      board.it = serialized.it;
      board.un = serialized.un;
      board.di = serialized.di;
      board.ch = serialized.ch || 0;
      board.effort = serialized.effort || 2;

      if (serialized.precomputed) {
        board.precomputed = PrecomputedPoints.fromSerialized(serialized.precomputed);
      }

      // Restore nn array
      board.nn = new Array(serialized.config.dimsArea).fill(0);
      if (serialized.completedIndexes) {
        for (let i = 0; i < serialized.completedIndexes.length; i++) {
          board.nn[serialized.completedIndexes[i]] = serialized.completedNn[i];
        }
      }
    });

    return board;
  }
}


const forcedBoardTypes = {
    'cpu': CpuBoard,
    'ddz': DDZhuoranBoard,
    'qdz': QDZhuoranBoard,
    'gpu': GpuBoard,
    'gpuz': GpuZhuoranBoard,
    'adaptive': AdaptiveGpuBoard,
    'qdcpu': QDCpuBoard
};

function selectBoardClass(pixelSize, dimsArea, gpuMaxBufferSize, forceBoard) {
  if (forceBoard) {
    if (forceBoard in forcedBoardTypes) {
      return forcedBoardTypes[forceBoard];
    } else {
      throw new Error(`Unknown board type: ${forcedBoardType}.` +
        ` Valid types: ${Object.keys(forcedBoardTypes).join(', ')}`);
    }
  }

  // First, try to select a GPU board.
  if (gpuMaxBufferSize) {
    // Select board type based on zoom level and float32 precision limits
    // Float32 has ~7 decimal digits, so direct iteration works to ~1e-7 pixel size
    // Shallow zooms (z < ~1e7): GpuBoard with simple float32 iteration
    // Medium zooms (z ~1e7 to ~1e30): GpuZhuoranBoard with quad-precision reference
    // Deep zooms (z > ~1e30): AdaptiveGpuBoard with QD-precision reference
    //   orbit and adaptive per-pixel scaling for correct escape detection
    const GpuBoardClass = (
        (pixelSize > 1e-7) ? GpuBoard :
        (pixelSize > 1e-30) ? GpuZhuoranBoard :
        AdaptiveGpuBoard);
    const largestBufferSize = dimsArea * GpuBoardClass.BYTES_PER_PIXEL;
    if (largestBufferSize <= gpuMaxBufferSize) {
      return GpuBoardClass;
    } else {
      const bufferSizeMB = (largestBufferSize / (1024*1024)).toFixed(0);
      const limitMB = (gpuMaxBufferSize / (1024*1024)).toFixed(0);
      console.log(
        `${GpuBoardClass}: dimsArea=${dimsArea} too large for GPU ` +
            `(buffer size ${bufferSizeMB} MB > ${limitMB} MB), using CPU`);
    }
  }

  // If GPU is not available, select a CPU board
  const CpuBoardClass = (
      (pixelSize > 1e-15) ? CpuBoard :
      (pixelSize > 1e-30) ? DDZhuoranBoard :
      QDZhuoranBoard);
  return CpuBoardClass;
}


// FractalWorker manages board computation on both main thread and in workers
// Always defined on the main thread (for MockWorker to extend)
// and instantiated in real workers via workerStart
class FractalWorker {
  constructor(workerNumber, name) {
    this.workerNumber = workerNumber;
    this.name = name;
    this.boards = new Map();
    this.hiddenBoards = new Set();
    this.focusedBoardK = null;
    this.computationPaused = false;
    this.steps = 0;
    this.startTime = 0;
    this.endTime = -1;
    this.timer = null;
    this.gpuMaxBufferSize = null;
    // Batch timing collection for benchmarking (debug=b)
    // Maps board.k -> array of {pixels, iters, timeMs}
    this.batchTimings = new Map();
    this.collectBatchTimings = false;
    // Console.log timing output (debug=t)
    this.logTimings = false;
    // Random batch sizes for benchmarking (debug=r)
    this.randomBatching = false;
    this.randomBatchMin = 1;
    this.randomBatchMax = 16;
    // Target time per batch in milliseconds (configurable)
    this.batchTimeMs = 100;
  }

  // Record a batch timing sample for benchmarking
  // startPixels should be board.un captured BEFORE iterate()
  recordBatchTiming(board, startTime, startIter, startPixels) {
    if (!this.collectBatchTimings) return;
    const timeMs = performance.now() - startTime;
    const iters = board.it - startIter;
    // Use the pixel count from before the batch (some may have diverged during)
    const pixels = startPixels;

    if (iters > 0 && pixels > 0 && timeMs > 0) {
      if (!this.batchTimings.has(board.k)) {
        this.batchTimings.set(board.k, []);
      }
      this.batchTimings.get(board.k).push({ pixels, iters, timeMs });
    }
  }

  // Get batch timings for regression analysis
  getBatchTimings(k) {
    return this.batchTimings.get(k) || [];
  }

  // Clear batch timings
  clearBatchTimings(k) {
    if (k !== undefined) {
      this.batchTimings.delete(k);
    } else {
      this.batchTimings.clear();
    }
  }

  async handleMessage(type, data) {
    switch (type) {
      case 'addBoard':
        this.workerNumber = data.workerNumber;
        const enableGPU = data.config.enableGPU;
        const webGPUAvailable = GpuBoard.isAvailable();

        // Query GPU limits once on first use
        if (enableGPU && webGPUAvailable && this.gpuMaxBufferSize === null) {
          this.gpuMaxBufferSize = await GpuBaseBoard.queryMaxBufferSize();
        }

        // Explicit board selection via board= parameter
        const forceBoard = data.config.forceBoard;
        const size = data.size;
        const dimsArea = data.config.dimsArea;
        const pixelSize = size / data.config.dimsWidth;
        const BoardClass = selectBoardClass(pixelSize, dimsArea, this.gpuMaxBufferSize, forceBoard);

        // Construct the board instance with optional inherited data
        let board = new BoardClass(data.k, size, data.reQD, data.imQD, data.config, data.id, data.inheritedData);
        this.boards.set(data.k, board);

        // Log inheritance stats if debug=inherit is set
        if (data.inheritedData && hasDebugFlag(data.config, 'inherit')) {
          const inherited = data.inheritedData.packed ?
            ((data.inheritedData.dIndices?.length || 0) + (data.inheritedData.cIndices?.length || 0)) :
            ((data.inheritedData.diverged?.length || 0) + (data.inheritedData.converged?.length || 0));
          console.log(`Board ${data.k} (${BoardClass.name}): received ${inherited} inherited pixels`);
        }

        // Enable batch timing collection if debug=b is set
        if (hasDebugFlag(data.config, 'b')) {
          this.collectBatchTimings = true;
        }
        // Enable console.log timing output if debug=t is set
        if (hasDebugFlag(data.config, 't')) {
          this.logTimings = true;
        }
        // Enable random batch sizes for benchmarking if debug=r is set
        if (hasDebugFlag(data.config, 'r')) {
          this.randomBatching = true;
          this.logTimings = true;  // Also enable timing output
        }

      // Store QD-precision coordinates
      board.sizesQD = [size, data.reQD, data.imQD];

      // Show coordinates
      let coordStr;
      const digits = Math.ceil(-Math.log10(pixelSize)) + 3;
      const re_str = qdToDecimalString(data.reQD, digits);
      const im_str = qdToDecimalString(data.imQD, digits);
      coordStr = `c=(${re_str}, ${im_str})`;
      console.log(
        `Board ${data.k}: ${board.constructor.name} @ ${coordStr}, ` +
        `dims=${data.config.dimsWidth}x${data.config.dimsHeight}, ` +
        `pixel=${pixelSize.toExponential(3)}`
      );

      // Log refC_qd at full precision for deep zoom boards
      // to debug click vs URL differences
      if (board.refC_qd && pixelSize < 1e-45) {
        const refReQD = [board.refC_qd[0], board.refC_qd[1],
          board.refC_qd[2], board.refC_qd[3]];
        const refImQD = [board.refC_qd[4], board.refC_qd[5],
          board.refC_qd[6], board.refC_qd[7]];
        const digits = Math.ceil(-Math.log10(pixelSize)) + 3;
        console.log(`  refC_qd: (${qdToDecimalString(refReQD, digits)}, ` +
          `${qdToDecimalString(refImQD, digits)})`);
      }

        // Send board type info once on creation
        this.sendToScheduler({
          type: 'boardCreated',
          data: {
            k: data.k,
            boardType: board.constructor.name
          }
        });
        break;
      case 'removeBoard':
        this.boards.delete(data.k);
        break;
      case 'setFocusedBoard':
        this.focusedBoardK = data.k;
        break;
      case 'setHiddenBoards':
        this.hiddenBoards = new Set(data.hiddenBoards);
        break;
      case 'requestTransfer':
        const transferredBoards = [];
        for (const k of data.boardKeys) {
          if (this.boards.has(k)) {
            const board = this.boards.get(k);
            board.compact();
            const serializedBoard = await board.serialize();
            this.boards.delete(k);
            transferredBoards.push(serializedBoard);
          }
        }
        // Send the serialized boards back to the scheduler
        this.sendToScheduler({
          type: 'downloadTransfer',
          data: { transferredBoards }
        });
        break;
      case 'uploadTransfer':
        // Recreate the board from the serialized data and add it to this worker
        const newBoard = Board.fromSerialized(data.boardData);
        this.boards.set(newBoard.k, newBoard);
        break;
      case 'pause':
        this.computationPaused = data.pause;
        break;
    }

    // Start iteration loop if not running (check after every message)
    if (!this.timer && this.boards.size && !this.computationPaused) {
      this.iterateBoards();
    } else {
      const remainingWork = Array.from(this.boards.values()).
          filter(board => !this.hiddenBoards.has(board.k)).
          map(b => b.un * b.effort).reduce((a, b) => a + b, 0);
      this.sendToScheduler({
        type: 'update',
        data: {
          remainingWork,
        }
      });
    }
  }

  async iterateBoards() {
    this.timer = null;
    if (this.computationPaused) {
      return;
    }
    let pri = Array.from(this.boards.values())
          .filter(board => (board.unfinished() || board.updateSize || board.hasPendingResults))
          .filter(board => !this.hiddenBoards.has(board.k));
    if (pri.length) {
      // Start timer if it is not already running.
      if (this.endTime) {
        this.startTime = (new Date).getTime();
        this.endTime = 0;
      }
      if (this.steps % 2) {
        // Prioritize most unfinished half the time.
        pri = pri.sort((a, b) => b.un - a.un);
      } else {
        // Prioritize the most recent half the time.
        pri = pri.sort((a, b) => b.k - a.k);
        // Allow the user to prioritize by pointing the mouse.
        if (this.focusedBoardK !== null) {
          pri.sort((a, b) => (a.k === this.focusedBoardK ? -1 : b.k === this.focusedBoardK ? 1 : 0));
        }
      }
      // Exponential scheduling policy
      let shift = Math.floor(this.steps++ / 2) + 1;
      let p = 0;
      while (shift & (1 << p)) { p += 1; }
      const board = pri[Math.min(p, pri.length) % pri.length];

      // Calculate targetIters based on time budget and effort
      // Work threshold tuned for ~10-20ms CPU batches and ~50-100ms GPU batches
      // Large batches improve throughput by amortizing per-batch overhead
      const batchTimeMs = this.batchTimeMs || 100;
      const workThreshold = batchTimeMs * 5000000;
      let targetIters;
      if (this.stepMode) {
        // Step mode: always 1 iteration per step
        targetIters = 1;
      } else if (this.randomBatching) {
        // Random batch sizes for benchmarking (debug=r)
        // Produces varied iteration counts for regression analysis
        targetIters = this.randomBatchMin + Math.floor(
          Math.random() * (this.randomBatchMax - this.randomBatchMin + 1)
        );
      } else {
        // Calculate iterations to fill time budget, respecting board limits
        const pixels = Math.max(board.un, 1);
        const effort = Math.max(board.effort, 1);
        const minIters = board.minBatchIters || 1;
        const maxIters = board.maxBatchIters || Infinity;
        targetIters = Math.min(maxIters, Math.max(minIters, Math.floor(workThreshold / (pixels * effort))));
      }

      // In step mode, wait for step() to request iterations
      if (this.stepMode && this.stepsRequested <= 0) {
        // If stepsRequested is 0, don't do anything (wait for step() call)
      } else {
        const shouldTime = this.collectBatchTimings || this.logTimings;
        const startTime = shouldTime ? performance.now() : 0;
        const startIter = board.it;
        const startPixels = board.un;
        await board.iterate(targetIters);
        if (shouldTime) {
          const elapsedMs = performance.now() - startTime;
          const actualIters = board.it - startIter;
          if (this.collectBatchTimings) {
            this.recordBatchTiming(board, startTime, startIter, startPixels);
          }
          if (this.logTimings && actualIters > 0) {
            const boardType = board.constructor.name;
            const elapsedUs = elapsedMs * 1000;  // Convert to microseconds
            const usPerPixelIter = elapsedUs / (startPixels * actualIters);
            const compactedFlag = board.lastBatchCompacted ? ' C' : '';
            console.log(`[timing] ${boardType} k=${board.k}: ${startPixels} px × ${actualIters} iters = ${elapsedUs.toFixed(1)}μs${compactedFlag}`);
          }
        }

        if (this.stepMode) {
          this.stepsRequested--; // Consume one step
          // Call step callback if set
          if (this.stepCallback) {
            await this.stepCallback();
          }
        }
      }
      const now = (new Date()).getTime();
      if (this.focusedBoardK == board.k ?
          (board.updateSize >= 1429 || now - board.lastTime >= 100) :
          (board.updateSize >= 4673 || now - board.lastTime >= 500)) {
        const boardEffort = board.un * board.effort;
        const remainingWork = pri.map(b => b.un * b.effort).reduce((a, b) => a + b, 0);
        const workerInfo = `${this.name}: ` + (board.unfinished() ?
             `boards {${[...this.boards.keys()]}}, work: ${remainingWork}` :
             `board finished`);
        this.sendToScheduler({
          type: 'iterations',
          data: {
            k: board.k,
            id: board.id,
            it: board.it,
            un: board.un,
            di: board.di,
            ch: board.ch,
            changeList: board.changeList,
            boardEffort,
            remainingWork,
            workerInfo,
            boardType: board.constructor.name,
            compactionCount: board.compactionCount || 0,
            activeCount: board.activeCount || board.config.dimsArea
          }
        });
        board.lastTime = now;
        board.updateSize = 0;
        board.changeList = [];
        if (!board.unfinished()) {
          // Delete board when done.
          this.boards.delete(board.k);
        }
      }
    } else {
      // End timer when there is no remaining work
      if (!this.endTime) {
         this.endTime = (new Date).getTime();
      }
      return;
    }
    this.timer = setTimeout(() => this.iterateBoards(), 0);
  }

  // Abstract method to be overridden by subclasses
  // Sends messages from worker back to scheduler
  sendToScheduler(msg) {
    throw new Error('FractalWorker.sendToScheduler() must be implemented by subclass');
  }
}

</script>
<script id="workerStart" type="text/webworker">
// This code runs only in real workers (not on main thread)
// Instantiate the FractalWorker and set up message handling

class RealWorker extends FractalWorker {
  sendToScheduler(msg) {
    // In real workers, send messages back to main thread
    self.postMessage(msg);
  }
}

// Create the worker instance
const worker = new RealWorker(undefined, self.name);

// Set up message handler
self.onmessage = async function(e) {
  const { type, data } = e.data;
  await worker.handleMessage(type, data);
};

</script>
<script id="debugCode">
// Debug flag 'w': Define MockWorker for main thread debugging
// FractalWorker class is always available on main thread now (workerCode is a regular script)
if (location.search.includes('debug=')) {
  const debugValue = decodeURIComponent(location.search.match(/[?&]debug=([^&]*)/)?.[1] || '');
  if (debugValue.split(',').includes('w')) {
    // Define MockWorker class that extends FractalWorker
    window.MockWorker = class MockWorker extends FractalWorker {
      constructor(workerNumber) {
        super(workerNumber, `MockWorker ${workerNumber}`);
        this.onmessage = null;  // Callback for sending messages back to Scheduler

        // Step mode support (debug=s flag)
        this.stepMode = false;
        this.stepsRequested = 0;
      }

      // Override to add step mode support
      async iterateBoards() {
        this.timer = null;

        // Step mode: only iterate if steps are requested
        if (this.stepMode && this.stepsRequested === 0) {
          // Wait for step() to be called
          this.timer = setTimeout(() => this.iterateBoards(), 100);
          return;
        }

        // Call parent implementation (it will check stepsRequested and decrement if needed)
        await super.iterateBoards();
      }

      // Handle incoming messages from Scheduler (when Scheduler calls worker.postMessage())
      // Real Workers receive messages via self.onmessage, but MockWorker receives via this method
      postMessage(msg) {
        // Schedule handleMessage asynchronously to match real Worker behavior
        setTimeout(async () => {
          const { type, data } = msg;
          await this.handleMessage(type, data);
        }, 0);
      }

      // Override abstract method to send messages back to Scheduler
      sendToScheduler(msg) {
        if (this.onmessage) {
          this.onmessage({ data: msg });
        }
      }
    };

    console.log('MockWorker class defined for main thread debugging');

    // Enable step mode if 's' flag is set
    if (debugValue.split(',').includes('s')) {
      // Set step mode flag on MockWorker initialization
      const originalConstructor = window.MockWorker;
      window.MockWorker = class extends originalConstructor {
        constructor(workerNumber) {
          super(workerNumber);
          this.stepMode = true;
          console.log(`MockWorker ${workerNumber} created in step mode`);
        }
      };

      // Helper functions for stepping through iterations
      window.step = function(n = 1, workerIndex = 0, callback = null) {
        if (typeof workerIndex === 'function') {
          callback = workerIndex;
          workerIndex = 0;
        }

        const worker = window[`worker${workerIndex}`];
        if (!worker || !worker.stepMode) {
          console.log(`Step mode not active for worker${workerIndex}. Load page with ?debug=w,s`);
          return;
        }

        worker.stepCallback = callback;
        worker.stepsRequested += n;

        if (!callback) {
          console.log(`Stepping worker${workerIndex} ${n} iteration(s)...`);
        }
        return worker.boards;
      };

      window.stepAll = function(workerIndex = 0) {
        const worker = window[`worker${workerIndex}`];
        if (!worker) {
          console.log(`No worker${workerIndex} available`);
          return;
        }

        worker.stepMode = false;
        worker.stepsRequested = 1; // Queue one step to trigger continuous iteration
        console.log(`Resuming continuous iteration for worker${workerIndex}...`);
      };

      window.pause = function(workerIndex = 0) {
        const worker = window[`worker${workerIndex}`];
        if (!worker) {
          console.log(`No worker${workerIndex} available`);
          return;
        }

        worker.stepMode = true;
        worker.stepsRequested = 0; // Clear any pending steps
        console.log(`Paused worker${workerIndex}. Use step() or step(n) to continue.`);
      };

      window.inspectBoard = function(k = 0, workerIndex = 0) {
        const worker = window[`worker${workerIndex}`];
        if (!worker || !worker.boards.has(k)) {
          console.log(`Board ${k} not found on worker${workerIndex}. Available:`, Array.from(worker?.boards?.keys() || []));
          return null;
        }

        const board = worker.boards.get(k);
        console.log(`Board ${k} on worker${workerIndex} (${board.constructor.name}):`);
        console.log(`  Iteration: ${board.it}`);
        console.log(`  Unfinished pixels: ${board.un}`);
        console.log(`  Diverged: ${board.di}`);
        console.log(`  Converged: ${board.ch}`);

        return board;
      };

      window.tracePixel = async function(k, pixelIndex, workerIndex = 0) {
        const worker = window[`worker${workerIndex}`];
        if (!worker || !worker.boards.has(k)) {
          console.log(`Board ${k} not found on worker${workerIndex}`);
          return null;
        }

        const board = worker.boards.get(k);
        const info = {
          boardType: board.constructor.name,
          iteration: board.it,
          nn: board.nn[pixelIndex]
        };

        // For Adaptive boards, read GPU state
        if (board.constructor.name === 'AdaptiveGpuBoard') {
          const pixelData = await board.readBuffer(board.buffers.pixels, Uint8Array);
          const offset = pixelIndex * 60;
          const pixelU32 = new Uint32Array(pixelData.buffer, offset, 15);
          const pixelF32 = new Float32Array(pixelData.buffer, offset, 15);

          info.status = new Int32Array([pixelU32[0]])[0];
          info.refIter = pixelU32[2];
          info.scale = new Int32Array([pixelU32[4]])[0];
          info.dzr = pixelF32[7];
          info.dzi = pixelF32[8];
          info.dzr_scaled = info.dzr * Math.pow(2, info.scale);
          info.dzi_scaled = info.dzi * Math.pow(2, info.scale);
        }

        // For QDZ boards, read CPU state
        if (board.constructor.name === 'QDZhuoranBoard') {
          info.refIter = board.refIter[pixelIndex];
          info.dzr = board.dz[pixelIndex * 2];
          info.dzi = board.dz[pixelIndex * 2 + 1];
        }

        console.table(info);
        return info;
      };

      // Analyze batch timings collected with debug=b
      // In step mode, each batch does 1 iteration, so we can only measure:
      //   time = overhead + perPixel × pixels
      // For multi-iteration batches (non-step mode), we could separate:
      //   time = perBatch + perIter × iters + perPixelIter × pixels × iters
      window.analyzeBatchTimings = function(k = 0) {
        const worker = window.worker0;
        if (!worker) {
          console.log('No worker available');
          return null;
        }

        const timings = worker.getBatchTimings(k);
        if (timings.length < 4) {
          console.log(`Not enough timing data (${timings.length} samples). Run more iterations with debug=b,w,s`);
          return null;
        }

        const board = worker.boards.get(k);
        const boardName = board?.constructor.name || 'Unknown';
        const n = timings.length;

        // Check if we have iteration variation
        const uniqueIters = [...new Set(timings.map(t => t.iters))];
        const hasIterVariation = uniqueIters.length > 1;

        // Simple linear regression: time = overhead + perPixel × pixels
        let sum_p = 0, sum_y = 0, sum_pp = 0, sum_py = 0;
        for (const t of timings) {
          const p = t.pixels;
          const y = t.timeMs * 1000; // μs
          sum_p += p; sum_y += y; sum_pp += p*p; sum_py += p*y;
        }

        const det = n * sum_pp - sum_p * sum_p;
        const perPixelUs = det !== 0 ? (n * sum_py - sum_p * sum_y) / det : 0;
        const overheadUs = (sum_y - perPixelUs * sum_p) / n;

        // Pixel count range
        const minPixels = Math.min(...timings.map(t => t.pixels));
        const maxPixels = Math.max(...timings.map(t => t.pixels));

        console.log(`\nBatch Timing Analysis for Board ${k} (${boardName}):`);
        console.log(`  Samples: ${n}`);
        console.log(`  Pixel range: ${minPixels} - ${maxPixels}`);
        console.log(`  Model: time = ${overheadUs.toFixed(1)} μs + ${perPixelUs.toFixed(4)} μs × pixels`);
        console.log(`  Per-pixel cost: ${Math.max(0, perPixelUs).toFixed(4)} μs/pixel`);
        console.log(`  Overhead: ${Math.max(0, overheadUs).toFixed(1)} μs/batch`);

        if (!hasIterVariation) {
          console.log(`\n  Note: In step mode, each batch does 1 iteration.`);
          console.log(`  The per-pixel cost is actually per-pixel-iteration.`);
        }

        // Show sample data
        console.log(`\n  Sample data (first 10):`);
        console.table(timings.slice(0, 10).map(t => ({
          pixels: t.pixels,
          iters: t.iters,
          timeMs: t.timeMs.toFixed(2),
          'μs/pixel': (t.timeMs * 1000 / t.pixels).toFixed(3)
        })));

        return { perPixelUs: Math.max(0, perPixelUs), overheadUs: Math.max(0, overheadUs), samples: n };
      };

      window.clearBatchTimings = function(k) {
        const worker = window.worker0;
        if (worker) {
          worker.clearBatchTimings(k);
          console.log(k !== undefined ? `Cleared timings for board ${k}` : 'Cleared all timings');
        }
      };

      console.log('Step mode enabled. Use step(), step(n), pause(), stepAll(), inspectBoard(k), tracePixel(k, pixelIndex)');
      if (window.worker0?.collectBatchTimings) {
        console.log('Batch timing enabled (debug=b). Use analyzeBatchTimings(k), clearBatchTimings(k)');
      }
    }
  }
}
</script>
<script id="mathCode">
//////////// DD (double-double) precision utilities ///////////

function toDD(x) {
  return Array.isArray(x) ? x : [x, 0];
}


// Add two DD values, returning DD result
function toDDAdd(a, b) {
  const aa = toDD(a);
  const bb = toDD(b);
  const out = [0, 0];
  ArddAdd(out, 0, aa[0], aa[1], bb[0], bb[1]);
  return out;
}

// Convert various complex formats to QDc format (8 elements)
// Handles: float64 pair [r, i], DDc [r_hi, r_lo, i_hi, i_lo], QDc [r0..r3, i0..i3]
function toQDc(c) {
  if (!c) return null;
  if (c.length === 8) return c;  // Already QDc
  if (c.length === 4) {
    // DDc format: [r_hi, r_lo, i_hi, i_lo]
    return [c[0], c[1], 0, 0, c[2], c[3], 0, 0];
  }
  if (c.length === 2) {
    // Float64 pair: [real, imag]
    return [c[0], 0, 0, 0, c[1], 0, 0, 0];
  }
  return null;
}

// Oct helpers for both main thread and workers (via mathCode)
function toQD(x) {
  if (!Array.isArray(x)) return [x, 0, 0, 0];
  if (x.length >= 4) return [x[0], x[1], x[2], x[3]];
  if (x.length === 3) return [x[0], x[1], x[2], 0];
  return [x[0], x[1] || 0, 0, 0];
}

function toQDScale(a, s) {
  const o = toQD(a);
  return [o[0] * s, o[1] * s, o[2] * s, o[3] * s];
}

function toQDAdd(a, b) {
  const aa = toQD(a);
  const bb = toQD(b);
  const out = new Array(4);
  ArqdAdd(out, 0, aa[0], aa[1], aa[2], aa[3], bb[0], bb[1], bb[2], bb[3]);
  return out;
}

function toQDSub(a, b) {
  const bb = toQD(b);
  return toQDAdd(a, [-bb[0], -bb[1], -bb[2], -bb[3]]);
}

function toQDMul(a, b) {
  const aa = toQD(a);
  const bb = toQD(b);
  const out = new Array(4);
  ArqdMul(out, 0, aa[0], aa[1], aa[2], aa[3], bb[0], bb[1], bb[2], bb[3]);
  return out;
}

function toQDSquare(a) {
  const aa = toQD(a);
  const out = new Array(4);
  ArqdSquare(out, 0, aa[0], aa[1], aa[2], aa[3]);
  return out;
}

function toQDDouble(a) {
  const aa = toQD(a);
  return [aa[0] * 2, aa[1] * 2, aa[2] * 2, aa[3] * 2];
}

function qdToNumber(o) {
  const v = toQD(o);
  return v[0] + v[1] + v[2] + v[3];
}

function qdToDD(o) {
  const v = toQD(o);
  return [v[0], v[1] + v[2] + v[3]];
}

// Convert a float64 to its exact BigInt representation, scaled by 10^scale.
function float64ToBigIntScaled(x, scale) {
  if (x === 0) return 0n;
  if (!Number.isFinite(x)) return 0n;
  const sign = x < 0 ? -1n : 1n;
  const absX = Math.abs(x);
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  view.setFloat64(0, absX);
  const bits = view.getBigUint64(0);
  const expBits = Number((bits >> 52n) & 0x7FFn);
  const mantissaBits = bits & 0xFFFFFFFFFFFFFn;
  let binaryExp, mantissa;
  if (expBits === 0) {
    mantissa = mantissaBits;
    binaryExp = -1022 - 52;
  } else {
    mantissa = (1n << 52n) | mantissaBits;
    binaryExp = expBits - 1023 - 52;
  }
  const five = 5n, two = 2n;
  let result = sign * mantissa * (five ** BigInt(scale));
  const netBinaryExp = binaryExp + scale;
  if (netBinaryExp >= 0) {
    result = result * (two ** BigInt(netBinaryExp));
  } else {
    result = result / (two ** BigInt(-netBinaryExp));
  }
  return result;
}

function decimalToQD(decimalString) {
  let s = decimalString.trim().toLowerCase();
  const neg = s.startsWith('-');
  if (neg) s = s.slice(1);
  if (s.startsWith('+')) s = s.slice(1);
  let exp = 0;
  const eIdx = s.indexOf('e');
  if (eIdx !== -1) {
    exp = parseInt(s.slice(eIdx + 1), 10);
    s = s.slice(0, eIdx);
  }
  const parts = s.split('.');
  const intPart = parts[0] || '0';
  const fracPart = parts[1] || '';
  let scale = fracPart.length - exp;
  const bigStr = intPart + fracPart;
  let n = BigInt(bigStr.replace(/^0+/, '') || '0');
  if (neg) n = -n;
  if (scale < 0) {
    n = n * (BigInt(10) ** BigInt(-scale));
    scale = 0;
  }
  // Use internal scale of 60 decimal places for exact float64 representation
  const internalScale = 60;
  if (scale < internalScale) {
    n = n * (BigInt(10) ** BigInt(internalScale - scale));
  } else if (scale > internalScale) {
    n = n / (BigInt(10) ** BigInt(scale - internalScale));
  }
  const limbs = [];
  let residual = n;
  const divisor = BigInt(10) ** BigInt(internalScale);
  for (let i = 0; i < 4; i++) {
    if (residual === 0n) { limbs.push(0); continue; }
    const limb = Number(residual) / Number(divisor);
    limbs.push(limb);
    const limbBigInt = float64ToBigIntScaled(limb, internalScale);
    residual = residual - limbBigInt;
  }
  // Normalize the result to ensure consistent representation across all QD operations.
  // Without this, limbs may not satisfy |limb[i]| < ulp(limb[i-1])/2, causing
  // ArqdAdd/toQDAdd to produce different representations when adding zero.
  // Uses quickTwoSum cascade to renormalize (fully inlined to avoid dependency issues).
  let s0 = limbs[0] + limbs[1], e0 = limbs[1] - (s0 - limbs[0]);
  let s1 = e0 + limbs[2], e1 = limbs[2] - (s1 - e0);
  let s2 = e1 + limbs[3], s3 = limbs[3] - (s2 - e1);
  let t0 = s0 + s1; s1 = s1 - (t0 - s0); s0 = t0;
  t0 = s1 + s2; s2 = s2 - (t0 - s1); s1 = t0;
  t0 = s2 + s3; s3 = s3 - (t0 - s2); s2 = t0;
  return [s0, s1, s2, s3];
}

// Parse a complex number string into QD precision real and imaginary parts.
// Accepts formats like: "-0.74543+0.11301i", "0.5i", "-i", "0.25", ""
// Returns { re: QD array, im: QD array } or null if parsing fails
function parseComplexToQD(coordString) {
  const trimmed = coordString.trim();

  // Empty string returns null to signal default/inherit behavior
  if (trimmed === '') {
    return null;
  }

  // Match: optional real part, then optional imaginary part (with 'i' or just 'i')
  const match = trimmed.match(
    /([-+]?\d*\.?\d+(?:e[-+]?\d+)?\b)?(?:([-+]?\d*\.?\d+(?:e[-+]?\d+)?)i|([-+]?i))?$/
  );

  if (!match) {
    return null;
  }

  // Extract real part (default to '0' if not present)
  const realStr = match[1] || '0';

  // Extract imaginary part: either match[2] (number with 'i') or match[3] (just 'i' or '-i')
  let imagStr = match[2] || (match[3] ? match[3].replace('i', '1') : '0');

  return {
    re: decimalToQD(realStr),
    im: decimalToQD(imagStr)
  };
}

// Convert QD value to decimal string with exact BigInt arithmetic.
function qdToDecimalString(qd, digits) {
  const o = Array.isArray(qd) ? qd : [qd, 0, 0, 0];
  const internalScale = 60;
  let total = 0n;
  for (let i = 0; i < 4; i++) {
    if (o[i] !== 0) {
      total += float64ToBigIntScaled(o[i], internalScale);
    }
  }
  const neg = total < 0n;
  if (neg) total = -total;
  const divisor = BigInt(10) ** BigInt(internalScale);
  const intPart = total / divisor;
  let fracPart = total % divisor;
  let result = intPart.toString();
  if (digits > 0) {
    let fracStr = fracPart.toString().padStart(internalScale, '0');
    if (digits < fracStr.length) {
      const roundDigit = parseInt(fracStr[digits]);
      fracStr = fracStr.slice(0, digits);
      if (roundDigit >= 5) {
        let carry = 1;
        let chars = fracStr.split('');
        for (let i = chars.length - 1; i >= 0 && carry; i--) {
          const d = parseInt(chars[i]) + carry;
          chars[i] = (d % 10).toString();
          carry = Math.floor(d / 10);
        }
        fracStr = chars.join('');
        if (carry) result = (BigInt(result) + 1n).toString();
      }
    } else {
      fracStr = fracStr.padEnd(digits, '0');
    }
    fracStr = fracStr.replace(/0+$/, '');
    if (fracStr.length > 0) result += '.' + fracStr;
  }
  return result;
}

function fast2Sum(a, b) {
  let s = a + b;
  let t = b - (s - a);
  return [s, t];
}

function slow2Sum(a, b) {
  let s = a + b;
  let c = s - a;
  return [s, (a - (s - c)) + (b - c)];
}

function ddSplit(a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  return [x, y];
}

function twoProduct(a, b) {
  let p = a * b;
  let [ah, al] = ddSplit(a);
  let [bh, bl] = ddSplit(b);
  let err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  return [p, err];
}

function twoSquare(a) {
  let p = a * a;
  let [ah, al] = ddSplit(a);
  let err = ((ah * ah - p) + 2 * ah * al) + al * al;
  return [p, err];
}

function ddAdd(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [h1, h2] = slow2Sum(a1, b1);
  let [l1, l2] = slow2Sum(a0, b0);
  let [v1, v2] = fast2Sum(h1, h2 + l1);
  return fast2Sum(v1, v2 + l2);
}




function ddNegate(a) {
  let [a1, a0] = a;
  return [-a1, -a0];
}

function ddSub(a, b) {
  return ddAdd(a, ddNegate(b));
}



function qdCompare(a, b) {
  if (a[0] < b[0]) return -1;
  if (a[0] > b[0]) return 1;
  if (a[1] < b[1]) return -1;
  if (a[1] > b[1]) return 1;
  if (a[2] < b[2]) return -1;
  if (a[2] > b[2]) return 1;
  if (a[3] < b[3]) return -1;
  if (a[3] > b[3]) return 1;
  return 0;
}


function qdEq(a, s) {
  return a[0] === s && a[1] === 0 && a[2] === 0 && a[3] === 0;
}



// Array in-place DD precision, allows fast computation
// by avoiding array constructors

function Afast2Sum(r, i, a, b) {
  let s = a + b;
  r[i] = s;
  r[i+1] = b - (s - a);
}

function Aslow2Sum(r, i, a, b) {
  let s = a + b;
  let c = s - a;
  r[i] = s;
  r[i+1] = (a - (s - c)) + (b - c);
}

function ArddSplit(r, i, a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  r[i] = x;
  r[i+1] = y;
}

function AtwoProduct(r, i, a, b) {
  const p = a * b;
  ArddSplit(r, i, a);
  const ah = r[i];
  const al = r[i+1];
  ArddSplit(r, i, b);
  const bh = r[i];
  const bl = r[i+1];
  const err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  r[i] = p;
  r[i+1] = err;
}

function AtwoSquare(r, i, a) {
  const p = a * a;
  ArddSplit(r, i, a);
  const ah = r[i];
  const al = r[i+1];
  const err = ((ah * ah - p) + 2 * ah * al) + al * al;
  r[i] = p;
  r[i+1] = err;
}

function AquickTwoSum(a, b) {
  const s = a + b;
  return [s, b - (s - a)];
}

function AsymmetricTwoSum(a, b) {
  const s = a + b;
  const bb = s - a;
  return [s, (a - (s - bb)) + (b - bb)];
}

// Three-sum from QD library: combines three values with proper error propagation
// Returns [sum, err1, err2] where sum + err1 + err2 = a + b + c (exactly)
function ArqdThreeSum(a, b, c) {
  let [t1, t2] = AsymmetricTwoSum(a, b);
  let [newA, t3] = AsymmetricTwoSum(c, t1);
  let [newB, newC] = AsymmetricTwoSum(t2, t3);
  return [newA, newB, newC];
}

function ArddAdd(r, i, a1, a2, b1, b2) {
  Aslow2Sum(r, i, a1, b1);
  const h1 = r[i];
  const h2 = r[i+1];
  Aslow2Sum(r, i, a2, b2);
  const l1 = r[i];
  const l2 = r[i+1];
  Afast2Sum(r, i, h1, h2 + l1);
  const v1 = r[i];
  const v2 = r[i+1];
  Afast2Sum(r, i, v1, v2 + l2);
}

function ArddMul(r, i, a1, a2, b1, b2) {
  AtwoProduct(r, i, a1, b1);
  const p1 = r[i];
  const p2 = r[i+1];
  Afast2Sum(r, i, p1, p2 + a1 * b2 + b1 * a2);
}

function ArddSet(r, i, a1, a2) {
  r[i] = a1;
  r[i+1] = a2;
}


function ArddSquare(r, i, a1, a2) {
  AtwoSquare(r, i, a1);
  const p1 = r[i];
  const p2 = r[i+1];
  Afast2Sum(r, i, p1, p2 + 2 * a1 * a2);
}


// Oct-double (four-limb) helpers for deeper precision

function ArqdTwoProduct(a, b) {
  const tmp = [];
  AtwoProduct(tmp, 0, a, b);
  return [tmp[0], tmp[1]];
}

function ArqdTwoSquare(a) {
  const tmp = [];
  AtwoSquare(tmp, 0, a);
  return [tmp[0], tmp[1]];
}

// Renormalization algorithm from QD library (Hida, Li, Bailey)
// Takes 5 inputs and produces 4 normalized outputs
function ArqdRenorm(r, i, c0, c1, c2, c3, c4) {
  let t0, t1, t2, t3, s;

  // First pass: propagate from bottom to top, collecting errors
  [s, t3] = AquickTwoSum(c3, c4);
  [s, t2] = AquickTwoSum(c2, s);
  [s, t1] = AquickTwoSum(c1, s);
  [c0, t0] = AquickTwoSum(c0, s);

  // Second pass: combine error terms
  [s, t2] = AquickTwoSum(t2, t3);
  [s, t1] = AquickTwoSum(t1, s);
  [c1, t0] = AquickTwoSum(t0, s);

  // Third pass: final cleanup
  [s, t1] = AquickTwoSum(t1, t2);
  [c2, t0] = AquickTwoSum(t0, s);

  c3 = t0 + t1;

  ArqdSet(r, i, c0, c1, c2, c3);
}

function ArqdSet(r, i, a1, a2, a3, a4) {
  r[i] = a1;
  r[i+1] = a2;
  r[i+2] = a3;
  r[i+3] = a4;
}


function ArqdAdd(r, i, a1, a2, a3, a4, b1, b2, b3, b4) {
  let s0, s1, s2, s3, s4, t0, t1, t2;
  [s0, t0] = AsymmetricTwoSum(a1, b1);
  [s1, t1] = AsymmetricTwoSum(a2, b2);
  [s2, t2] = AsymmetricTwoSum(a3, b3);
  s3 = a4 + b4;

  [s1, t0] = AsymmetricTwoSum(s1, t0);
  [s2, t1] = AsymmetricTwoSum(s2, t1);
  s3 += t2;

  [s2, t0] = AsymmetricTwoSum(s2, t0);
  s3 += t1;

  [s3, s4] = AsymmetricTwoSum(s3, t0);

  [s0, s1] = AquickTwoSum(s0, s1);
  [s1, s2] = AquickTwoSum(s1, s2);
  [s2, s3] = AquickTwoSum(s2, s3);
  [s3, s4] = AquickTwoSum(s3, s4);

  s2 += s4;
  [s2, s3] = AquickTwoSum(s2, s3);
  [s1, s2] = AquickTwoSum(s1, s2);

  ArqdSet(r, i, s0, s1, s2, s3);
}

// QD library sloppy_mul algorithm (Hida, Li, Bailey)
// Uses TwoProduct for 6 products (levels 0-2) for nearly full 212-bit precision
function ArqdMul(r, i, a1, a2, a3, a4, b1, b2, b3, b4) {
  // Level 0: a[0]*b[0]
  let [p0, q0] = ArqdTwoProduct(a1, b1);

  // Level 1: a[0]*b[1], a[1]*b[0]
  let [p1, q1] = ArqdTwoProduct(a1, b2);
  let [p2, q2] = ArqdTwoProduct(a2, b1);

  // Level 2: a[0]*b[2], a[1]*b[1], a[2]*b[0]
  let [p3, q3] = ArqdTwoProduct(a1, b3);
  let [p4, q4] = ArqdTwoProduct(a2, b2);
  let [p5, q5] = ArqdTwoProduct(a3, b1);

  // Accumulate terms using three_sum
  [p1, p2, q0] = ArqdThreeSum(p1, p2, q0);
  [p2, q1, q2] = ArqdThreeSum(p2, q1, q2);
  [p3, p4, p5] = ArqdThreeSum(p3, p4, p5);

  // Further combining
  let [s0, t0] = AsymmetricTwoSum(p2, p3);
  let [s1, t1] = AsymmetricTwoSum(q1, p4);
  let s2 = q2 + p5;
  [s1, t0] = AsymmetricTwoSum(s1, t0);
  s2 += t0 + t1;

  // Level 3 cross-products and remaining error terms
  s1 += a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + q0 + q3 + q4 + q5;

  // Renormalize
  ArqdRenorm(r, i, p0, p1, s0, s1, s2);
}

// QD library optimized sqr algorithm (Hida, Li, Bailey)
// Exploits symmetry: a[i]*a[j] = a[j]*a[i], so compute once and double
// Uses TwoSquare (cheaper than TwoProduct) where possible
function ArqdSquare(r, i, a1, a2, a3, a4) {
  // Level 0: a[0]² - use TwoSquare
  let [p0, q0] = ArqdTwoSquare(a1);

  // Level 1: 2*a[0]*a[1] - single TwoProduct with doubled arg
  let [p1, q1] = ArqdTwoProduct(2 * a1, a2);

  // Level 2: 2*a[0]*a[2] + a[1]²
  let [p2, q2] = ArqdTwoProduct(2 * a1, a3);
  let [p3, q3] = ArqdTwoSquare(a2);

  // Accumulate level 1
  [p1, p2, q0] = ArqdThreeSum(p1, q0, p2);

  // Accumulate level 2
  [p2, q1, q2] = ArqdThreeSum(p2, q1, q2);
  [p3, q3] = AsymmetricTwoSum(p3, q3);

  // Combine accumulated values
  let [s0, t0] = AsymmetricTwoSum(p2, p3);
  let [s1, t1] = AsymmetricTwoSum(q1, q3);
  let s2 = q2;
  [s1, t0] = AsymmetricTwoSum(s1, t0);
  s2 += t0 + t1;

  // Level 3: 2*a[0]*a[3] + 2*a[1]*a[2] (plain multiply)
  s1 += 2 * a1 * a4 + 2 * a2 * a3 + q0;

  // Renormalize
  ArqdRenorm(r, i, p0, p1, s0, s1, s2);
}


// Additional shared utility function for tracking cycles.

function fibonacciPeriod(iteration) {
  // Returns 1 at Fibonacci checkpoints (1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...)
  // Otherwise returns distance from most recent Fibonacci checkpoint plus 1.
  // Fibonacci growth (φ ≈ 1.618) reduces aliasing with periods compared to power-of-2.
  if (iteration === 0) return 1;
  if (iteration === 1) return 1;

  // Find largest Fibonacci number <= iteration
  let a = 1, b = 1;
  while (b < iteration) {
    const next = a + b;
    a = b;
    b = next;
  }

  // Return 1 if iteration is exact Fibonacci, else distance from previous
  if (b === iteration) return 1;
  return iteration - a + 1;
}

// Catmull-Rom spline interpolation for smooth movie camera paths.
// Uses quad-double precision for numerical stability at deep zoom.
function catmullRom1DQD(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  const c0 = (-t3 + 2*t2 - t) / 2;
  const c2 = (-3*t3 + 4*t2 + t) / 2;
  const c3 = (t3 - t2) / 2;
  // Compute offsets from p1 for numerical stability
  const s0 = toQDSub(p0, p1);
  const s2 = toQDSub(p2, p1);
  const s3 = toQDSub(p3, p1);
  return toQDAdd(toQDAdd(toQDAdd(toQDScale(s0, c0),
           toQDScale(s3, c3)), toQDScale(s2, c2)), p1);
}

function catmullRomSplineQD(p0, p1, p2, p3, t) {
  return [
    catmullRom1DQD(p0[0], p1[0], p2[0], p3[0], t),
    catmullRom1DQD(p0[1], p1[1], p2[1], p3[1], t)
  ];
}

</script>
<!-- Internationalization: Non-English help text and language detection -->
<div lang="es" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Explorador de Fractales del Conjunto de Mandelbrot
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Toca">Haz clic</span> para ampliar.</b>
<span mobile="">Haz clic derecho para guardar imágenes, <b>M</b> para crear y
guardar un vídeo de tu recorrido de zoom.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> se itera para cada
<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">número complejo</a>
<em>c</em>.  Los colores muestran
<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iteraciones</a> hasta
la divergencia; los puntos negros
<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">convergen o ciclan</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Los puntos amarillos muestran
<a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">órbitas</a></b>.
Los puntos rojos muestran ciclos límite.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Acerca de las iteraciones.</b> Este visor muestra más detalle fractal con el
tiempo al refinar las iteraciones hacia el infinito mientras exploras. Cuanto más
esperes, más detalle se mostrará.
Después de miles o millones de iteraciones, puedes resolver los detalles más finos
en las partes más complejas del fractal.
Ve información sobre iteraciones, progreso y coordenadas
<span mobile="tocando">pasando el cursor sobre</span> el número amarillo de zoom
bajo cada ventana.
<span mobile="Manteniendo tu dedo">Mover el ratón</span> sobre el contenido fractal
animará la órbita de valores <em>z</em> para cada ubicación <em>c</em>, revelando
la compleja dinámica de frontera que ha fascinado a los matemáticos.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Explorando una ruta de zoom.</b>
Cada <span mobile="toque">clic</span> en el fractal abre un nivel de zoom más alto
en la ubicación seleccionada, calculado en tu GPU si está disponible.
Después de ampliar más allá de una magnificación de un billón de veces, usamos un
algoritmo de perturbación de precisión cuádruple que resuelve detalles finos con
más de 60 dígitos de precisión.
Una vez que hayas creado una ruta interesante que muestre el detalle que deseas,
puedes <a class="moviemode">crear y descargar tu propio vídeo de zoom profundo de
Mandelbrot</a> o marcar tu URL para guardar y compartir tu exploración.
Para crear imágenes y vídeos de alta calidad, este visor calcula subpíxeles con
una proporción de <span class="pixelratio">2</span>:1<span mobile="">, y eso puede
aumentarse para crear visualizaciones más precisas</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Más comandos:</b>
<b>I</b> amplía;
<b mac="&#8984;">Ctrl</b>-clic para ampliar en el lugar;
<b>H</b> encoge y <b>G</b> agranda cada ventana;
<b>R</b> reabre ventanas intermedias;
<b>C</b> recentra todas;
<b>T</b> cambia el tema de color;
<b>U</b> resalta píxeles sin terminar;
<b mac="&#x23CE;">Enter</b> alterna pantalla completa;
<b>X</b> aumenta y <b>Z</b> disminuye el exponente de <em>z</em>;
<b>F</b> aumenta y <b>D</b> disminuye la proporción de píxeles;
<b>A</b> alterna relación de aspecto;
<b>M</b> crea un vídeo que sigue tu ruta;
<nobr><b>?</b> muestra esta ayuda.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<div lang="zh" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
曼德博集合分形探索器
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="点击">单击</span>以缩放。</b>
<span mobile="">右键单击以保存图像，按<b>M</b>键创建并保存您的缩放路径
视频。</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
对每个<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">复数</a>
<em>c</em> 迭代 <em>z &rightarrow; z<sup class="exponent">2</sup>+c</em>。
颜色显示到<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">发散的
迭代次数</a>；
黑色点<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">收敛或循环</a>。
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>黄点显示<a target="mbhelp"
href="https://plus.maths.org/content/unveiling-mandelbrot-set">轨道</a></b>。
红点显示极限环。
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>关于迭代。</b>随着您的探索，此查看器通过将迭代精细化至无穷来显示
更多分形细节。
等待时间越长，显示的细节越多。
经过数千或数百万次迭代后，您可以解析分形最复杂部分的最精细
细节。
通过<span mobile="点击">悬停在</span>每个窗口下方的黄色缩放数字上，
查看有关迭代、进度和坐标的信息。
<span mobile="按住手指">移动鼠标</span>到分形内容上将动画显示每个
位置 <em>c</em> 的 <em>z</em> 值轨道，揭示令数学家着迷的复杂边界动力学。
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>探索缩放路径。</b>
分形上的每次<span mobile="点击">单击</span>都会在所选位置打开更高的
缩放级别，
如果可用，将在您的GPU上计算。
当您放大超过万亿倍后，我们使用四精度扰动算法，可将精细细节解析到
超过60位数字的精度。
一旦您制作了一条显示所需细节的有趣路径，
您可以<a class="moviemode">创建并下载自己的曼德博深度缩放视频</a>，
或为您的URL添加书签以保存和分享您的探索。
为了创建高质量的图像和视频，
此查看器以<span class="pixelratio">2</span>:1的比例计算子像素<span mobile="">，
并且可以增加该比例以创建更精确的显示</span>。
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>更多命令：</b>
<b>I</b> 放大；
<b mac="&#8984;">Ctrl</b>-单击可原地放大；
<b>H</b> 缩小，<b>G</b> 放大每个窗口；
<b>R</b> 重新打开中间窗口；
<b>C</b> 重新居中所有窗口；
<b>T</b> 更改颜色主题；
<b>U</b> 突出显示未完成的像素；
<b mac="&#x23CE;">Enter</b> 切换全屏；
<b>X</b> 增加，<b>Z</b> 减少 <em>z</em> 指数；
<b>F</b> 增加，<b>D</b> 减少像素比率；
<b>A</b> 切换纵横比；
<b>M</b> 制作沿您路径的视频；
<nobr><b>?</b> 显示此帮助。</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<div lang="zh-TW" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
曼德博集合碎形探索器
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="點擊">點擊</span>以縮放。</b>
<span mobile="">右鍵點擊以儲存圖像，按<b>M</b>鍵創建並儲存您的縮放路徑
影片。</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
對每個<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">複數</a>
<em>c</em> 迭代 <em>z &rightarrow; z<sup class="exponent">2</sup>+c</em>。
顏色顯示到<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">發散的
迭代次數</a>；
黑色點<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">收斂或循環</a>。
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>黃點顯示<a target="mbhelp"
href="https://plus.maths.org/content/unveiling-mandelbrot-set">軌道</a></b>。
紅點顯示極限環。
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>關於迭代。</b>隨著您的探索，此檢視器通過將迭代精細化至無窮來顯示
更多碎形細節。
等待時間越長，顯示的細節越多。
經過數千或數百萬次迭代後，您可以解析碎形最複雜部分的最精細
細節。
通過<span mobile="點擊">懸停在</span>每個視窗下方的黃色縮放數字上，
查看有關迭代、進度和座標的資訊。
<span mobile="按住手指">移動滑鼠</span>到碎形內容上將動畫顯示每個
位置 <em>c</em> 的 <em>z</em> 值軌道，揭示令數學家著迷的複雜邊界動力學。
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>探索縮放路徑。</b>
碎形上的每次<span mobile="點擊">點擊</span>都會在所選位置開啟更高的
縮放級別，
如果可用，將在您的GPU上計算。
當您放大超過兆倍後，我們使用四精度擾動演算法，
可將精細細節解析到超過60位數字的精度。
一旦您製作了一條顯示所需細節的有趣路徑，
您可以<a class="moviemode">創建並下載自己的曼德博深度縮放影片</a>，
或為您的URL加入書籤以儲存和分享您的探索。
為了創建高品質的圖像和影片，
此檢視器以<span class="pixelratio">2</span>:1的比例計算子像素<span mobile="">，
並且可以增加該比例以創建更精確的顯示</span>。
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>更多命令：</b>
<b>I</b> 放大；
<b mac="&#8984;">Ctrl</b>-點擊可原地放大；
<b>H</b> 縮小，<b>G</b> 放大每個視窗；
<b>R</b> 重新開啟中間視窗；
<b>C</b> 重新置中所有視窗；
<b>T</b> 更改顏色主題；
<b>U</b> 突出顯示未完成的像素；
<b mac="&#x23CE;">Enter</b> 切換全螢幕；
<b>X</b> 增加，<b>Z</b> 減少 <em>z</em> 指數；
<b>F</b> 增加，<b>D</b> 減少像素比率；
<b>A</b> 切換縱橫比；
<b>M</b> 製作沿您路徑的影片；
<nobr><b>?</b> 顯示此幫助。</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<div lang="ar" style="display:none;direction:rtl;text-align:right">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
مستكشف كسيريات مجموعة ماندلبروت
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="اضغط">انقر</span> للتكبير.</b>
<span mobile="">انقر بزر الماوس الأيمن لحفظ الصور،
<b>M</b> لإنشاء وحفظ فيديو لمسار التكبير الخاص بك.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
يتم تكرار <em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> لكل
<a target="mbhelp"
href="http://en.wikipedia.org/wiki/Complex_number">عدد مركب</a>
<em>c</em>.  تُظهر الألوان
<a target="mbhelp"
href="http://warp.povusers.org/Mandelbrot/">التكرارات</a> حتى التباعد؛
النقاط السوداء <a
href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">تتقارب أو تدور</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>النقاط الصفراء تُظهر <a target="mbhelp"
href="https://plus.maths.org/content/unveiling-mandelbrot-set">المدارات</a></b>.
النقاط الحمراء تُظهر الدورات الحدية.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>حول التكرارات.</b> يُظهر هذا العارض المزيد من تفاصيل
الكسيريات
بمرور الوقت من خلال تحسين التكرارات إلى ما لا نهاية
أثناء استكشافك.
كلما انتظرت أكثر، كلما ظهر المزيد من التفاصيل.
بعد آلاف أو ملايين التكرارات، يمكنك حل أدق التفاصيل
في الأجزاء الأكثر تعقيداً من الكسيرية.
شاهد معلومات حول التكرارات والتقدم والإحداثيات
عن طريق <span mobile="الضغط على">تمرير المؤشر فوق</span>
رقم التكبير الأصفر أسفل كل نافذة.
<span mobile="الاحتفاظ بإصبعك">تحريك الماوس</span> فوق محتوى
الكسيرية سيُحرك مدار قيم <em>z</em> لكل موقع <em>c</em>،
مما يكشف ديناميكيات الحدود المعقدة التي فتنت علماء
الرياضيات.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>استكشاف مسار التكبير.</b>
كل <span mobile="نقرة">نقرة</span> على الكسيرية تفتح مستوى تكبير
أعلى في الموقع المحدد، محسوباً على GPU الخاص بك إن توفر.
بعد التكبير إلى ما يتجاوز تكبير تريليون ضعف، نستخدم
خوارزمية اضطراب رباعية الدقة تحل التفاصيل الدقيقة
لأكثر من
60 رقماً من الدقة.
بمجرد أن تصنع مساراً مثيراً يُظهر التفاصيل التي
تريدها،
يمكنك <a class="moviemode">إنشاء وتنزيل فيديو تكبير عميق
لماندلبروت الخاص بك</a> أو وضع إشارة مرجعية على عنوان URL
الخاص بك لحفظ ومشاركة استكشافك.
لإنشاء صور ومقاطع فيديو عالية الجودة، يحسب هذا العارض
البكسلات الفرعية بنسبة <span class="pixelratio">2</span>:1<span mobile="">،
ويمكن زيادة ذلك لإنشاء عروض أكثر دقة</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>المزيد من الأوامر:</b>
<b>I</b> يكبّر؛
<b mac="&#8984;">Ctrl</b>-نقر للتكبير في المكان؛
<b>H</b> يُصغّر و<b>G</b> يُكبّر كل نافذة؛
<b>R</b> يُعيد فتح النوافذ المتوسطة؛
<b>C</b> يُعيد توسيط الكل؛
<b>T</b> يُغيّر موضوع الألوان؛
<b>U</b> يُبرز البكسلات غير المكتملة؛
<b mac="&#x23CE;">Enter</b> يُبدّل وضع ملء الشاشة؛
<b>X</b> يزيد و<b>Z</b> ينقص أس <em>z</em>؛
<b>F</b> يزيد و<b>D</b> ينقص نسبة البكسل؛
<b>A</b> يبدّل نسبة العرض إلى الارتفاع؛
<b>M</b> يصنع فيديو يتبع مسارك؛
<nobr><b>?</b> يُظهر هذه المساعدة.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:left">
<a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a> -</p>
</div>

<div lang="id" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Penjelajah Fraktal Himpunan Mandelbrot
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Ketuk">Klik</span> untuk memperbesar.</b>
<span mobile="">Klik kanan untuk menyimpan gambar, <b>M</b> untuk membuat dan menyimpan
video jalur zoom Anda.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> diiterasi untuk setiap
<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">bilangan kompleks</a>
<em>c</em>.  Warna menunjukkan
<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iterasi</a> hingga
divergensi; titik hitam
<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">konvergen atau bersiklus</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Titik kuning menunjukkan
<a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbit</a></b>.
Titik merah menunjukkan siklus batas.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Tentang iterasi.</b> Penampil ini menunjukkan lebih banyak detail fraktal seiring
waktu dengan menyempurnakan iterasi hingga tak terhingga saat Anda menjelajah.
Semakin lama Anda menunggu, semakin banyak detail yang ditampilkan.
Setelah ribuan atau jutaan iterasi, Anda dapat menyelesaikan detail terbaik di bagian
paling kompleks dari fraktal.
Lihat informasi tentang iterasi, kemajuan, dan koordinat dengan
<span mobile="mengetuk">mengarahkan kursor ke</span> angka zoom kuning di bawah
setiap jendela.
<span mobile="Menahan jari Anda">Menggerakkan mouse</span> di atas konten fraktal akan
menganimasi orbit nilai <em>z</em> untuk setiap lokasi <em>c</em>, mengungkapkan
dinamika batas kompleks yang telah memukau para matematikawan.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Menjelajahi jalur zoom.</b>
Setiap <span mobile="ketukan">klik</span> pada fraktal membuka level zoom yang lebih
tinggi di lokasi yang dipilih, dihitung pada GPU Anda jika tersedia.
Setelah Anda memperbesar melampaui pembesaran satu triliun kali, kami menggunakan
algoritma perturbasi presisi ganda empat yang menyelesaikan detail halus hingga lebih
dari 60 digit akurasi.
Setelah Anda membuat jalur menarik yang menunjukkan detail yang Anda inginkan, Anda
dapat <a class="moviemode">membuat dan mengunduh video zoom dalam Mandelbrot Anda
sendiri</a> atau menandai URL Anda untuk menyimpan dan membagikan penjelajahan Anda.
Untuk membuat gambar dan video berkualitas tinggi, penampil ini menghitung subpiksel
dengan rasio <span class="pixelratio">2</span>:1<span mobile="">, dan itu dapat
ditingkatkan untuk membuat tampilan yang lebih presisi</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Perintah lainnya:</b>
<b>I</b> memperbesar;
<b mac="&#8984;">Ctrl</b>-klik untuk memperbesar di tempat;
<b>H</b> mengecilkan dan <b>G</b> memperbesar setiap jendela;
<b>R</b> membuka kembali jendela tengah;
<b>C</b> memusatkan kembali semua;
<b>T</b> mengubah tema warna;
<b>U</b> menyorot piksel yang belum selesai;
<b mac="&#x23CE;">Enter</b> mengalihkan layar penuh;
<b>X</b> meningkatkan dan <b>Z</b> menurunkan eksponen <em>z</em>;
<b>F</b> meningkatkan dan <b>D</b> menurunkan rasio piksel;
<b>A</b> mengalihkan rasio aspek;
<b>M</b> membuat video yang mengikuti jalur Anda;
<nobr><b>?</b> menampilkan bantuan ini.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<div lang="pt" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Explorador de Fractais do Conjunto de Mandelbrot
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Toque">Clique</span> para ampliar.</b>
<span mobile="">Clique com o botão direito para salvar imagens, <b>M</b> para criar e
salvar um vídeo do seu caminho de zoom.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> é iterado para cada
<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">número complexo</a>
<em>c</em>.  As cores mostram
<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">iterações</a> até a
divergência; pontos pretos
<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">convergem ou ciclam</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Pontos amarelos mostram
<a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">órbitas</a></b>.
Pontos vermelhos mostram ciclos limite.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Sobre iterações.</b> Este visualizador mostra mais detalhes fractais ao longo do
tempo, refinando iterações ao infinito enquanto você explora. Quanto mais você espera,
mais detalhes são mostrados.
Após milhares ou milhões de iterações, você pode resolver os detalhes mais finos nas
partes mais complexas do fractal.
Veja informações sobre iterações, progresso e coordenadas
<span mobile="tocando">passando o mouse sobre</span> o número amarelo de zoom sob
cada janela.
<span mobile="Mantendo seu dedo">Mover o mouse</span> sobre o conteúdo fractal animará
a órbita dos valores <em>z</em> para cada localização <em>c</em>, revelando a complexa
dinâmica de fronteira que fascinou matemáticos.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Explorando um caminho de zoom.</b>
Cada <span mobile="toque">clique</span> no fractal abre um nível de zoom mais alto no
local selecionado, calculado na sua GPU se disponível.
Após ampliar além de uma magnificação de um trilhão de vezes, usamos um algoritmo de
perturbação de precisão quádrupla que resolve detalhes finos com mais de 60 dígitos
de precisão.
Depois de criar um caminho interessante que mostra os detalhes que você deseja, você
pode <a class="moviemode">criar e baixar seu próprio vídeo de zoom profundo de
Mandelbrot</a> ou marcar sua URL para salvar e compartilhar sua exploração.
Para criar imagens e vídeos de alta qualidade, este visualizador calcula subpixels
com uma proporção de <span class="pixelratio">2</span>:1<span mobile="">, e isso pode
ser aumentado para criar exibições mais precisas</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Mais comandos:</b>
<b>I</b> amplia;
<b mac="&#8984;">Ctrl</b>-clique para ampliar no local;
<b>H</b> encolhe e <b>G</b> aumenta cada janela;
<b>R</b> reabre janelas intermediárias;
<b>C</b> recentraliza todas;
<b>T</b> muda o tema de cores;
<b>U</b> destaca pixels inacabados;
<b mac="&#x23CE;">Enter</b> alterna tela cheia;
<b>X</b> aumenta e <b>Z</b> diminui o expoente de <em>z</em>;
<b>F</b> aumenta e <b>D</b> diminui a proporção de pixels;
<b>A</b> alterna proporção de tela;
<b>M</b> cria um vídeo que segue seu caminho;
<nobr><b>?</b> mostra esta ajuda.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<div lang="fr" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Explorateur de Fractales de l'Ensemble de Mandelbrot
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Appuyez">Cliquez</span> pour zoomer.</b>
<span mobile="">Cliquez avec le bouton droit pour enregistrer les images, <b>M</b> pour
créer et enregistrer une vidéo de votre parcours de zoom.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> est itéré pour chaque
<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">nombre complexe</a>
<em>c</em>.  Les couleurs montrent les
<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">itérations</a> jusqu'à
la divergence ; les points noirs
<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">convergent ou cyclent</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Les points jaunes montrent les
<a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">orbites</a></b>.
Les points rouges montrent les cycles limites.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>À propos des itérations.</b> Ce visualiseur montre plus de détails fractals au fil
du temps en affinant les itérations vers l'infini pendant votre exploration. Plus vous
attendez, plus de détails sont affichés.
Après des milliers ou des millions d'itérations, vous pouvez résoudre les détails les
plus fins dans les parties les plus complexes de la fractale.
Consultez les informations sur les itérations, la progression et les coordonnées en
<span mobile="appuyant sur">passant la souris sur</span> le numéro de zoom jaune sous
chaque fenêtre.
<span mobile="En maintenant votre doigt">Déplacer votre souris</span> sur le contenu
fractal animera l'orbite des valeurs <em>z</em> pour chaque emplacement <em>c</em>,
révélant la dynamique de frontière complexe qui a fasciné les mathématiciens.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Explorer un parcours de zoom.</b>
Chaque <span mobile="appui">clic</span> sur la fractale ouvre un niveau de zoom
supérieur à l'emplacement sélectionné, calculé sur votre GPU si disponible.
Après avoir zoomé au-delà d'un grossissement de mille milliards de fois, nous utilisons
un algorithme de perturbation en quadruple précision qui résout les détails fins avec
plus de 60 chiffres de précision.
Une fois que vous avez créé un parcours intéressant qui montre les détails que vous
souhaitez, vous pouvez <a class="moviemode">créer et télécharger votre propre vidéo de
zoom profond de Mandelbrot</a> ou mettre en signet votre URL pour sauvegarder et
partager votre exploration.
Pour créer des images et des vidéos de haute qualité, ce visualiseur calcule les
sous-pixels avec un rapport de <span class="pixelratio">2</span>:1<span mobile="">, et
cela peut être augmenté pour créer des affichages plus précis</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Plus de commandes :</b>
<b>I</b> zoom avant ;
<b mac="&#8984;">Ctrl</b>-clic pour zoomer sur place ;
<b>H</b> rétrécit et <b>G</b> agrandit chaque fenêtre ;
<b>R</b> rouvre les fenêtres intermédiaires ;
<b>C</b> recentre toutes ;
<b>T</b> change le thème de couleur ;
<b>U</b> met en évidence les pixels inachevés ;
<b mac="&#x23CE;">Entrée</b> bascule en plein écran ;
<b>X</b> augmente et <b>Z</b> diminue l'exposant de <em>z</em> ;
<b>F</b> augmente et <b>D</b> diminue le rapport de pixels ;
<b>A</b> bascule le rapport d'aspect ;
<b>M</b> crée une vidéo qui suit votre parcours ;
<nobr><b>?</b> affiche cette aide.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<div lang="ja" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
マンデルブロ集合フラクタル探索ツール
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="タップ">クリック</span>してズーム。</b>
<span mobile="">右クリックで画像を保存、<b>M</b>でズームパスの
動画を作成・保存できます。</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
各<a target="mbhelp"
href="http://en.wikipedia.org/wiki/Complex_number">複素数</a>
<em>c</em> に対して
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em>
が反復されます。色は発散までの<a target="mbhelp"
href="http://warp.povusers.org/Mandelbrot/">反復回数</a>を示し、
黒い点は<a
href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">収束または周期的</a>です。
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>黄色の点は<a target="mbhelp"
href="https://plus.maths.org/content/unveiling-mandelbrot-set">軌道</a>を示します</b>。
赤い点は極限周期を示します。
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>反復について。</b>
このビューアは、探索中に反復を無限大まで精緻化することで、
時間とともにより多くのフラクタルの詳細を表示します。
待つほど、より多くの詳細が表示されます。
数千または数百万回の反復の後、フラクタルの最も複雑な部分で
最も細かい詳細を解像できます。
各ウィンドウ下の黄色のズーム番号を<span mobile="タップ">
マウスオーバー</span>することで、反復、進行状況、座標に関する
情報を確認できます。
フラクタルコンテンツ上で<span mobile="指を保持">マウスを
移動</span>すると、
各位置 <em>c</em> の <em>z</em> 値の軌道がアニメーション化され、数学者を
魅了してきた複雑な境界ダイナミクスが明らかになります。
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>ズームパスの探索。</b>
フラクタル上の各<span mobile="タップ">クリック</span>は、選択した場所で
より高いズームレベルを開き、可能であればGPU上で計算されます。
1兆倍を超える倍率までズームすると、60桁以上の精度で細かい
詳細を解決する4倍精度摂動アルゴリズムを使用します。
必要な詳細を示す興味深いパスを作成したら、<a class="moviemode">独自の
マンデルブロディープズーム動画を作成してダウンロード</a>したり、URLを
ブックマークして探索を保存・共有したりできます。
高品質の画像と動画を作成するために、このビューアは
<span class="pixelratio">2</span>:1の比率でサブピクセルを計算し<span mobile="">、
より正確な表示を作成するためにこれを増やすことができます</span>。
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>その他のコマンド：</b>
<b>I</b> ズームイン；
<b mac="&#8984;">Ctrl</b>-クリックでその場でズーム；
<b>H</b> で縮小、<b>G</b> で各ウィンドウを拡大；
<b>R</b> 中間ウィンドウを再度開く；
<b>C</b> すべてを再センタリング；
<b>T</b> カラーテーマを変更；
<b>U</b> 未完了のピクセルをハイライト；
<b mac="&#x23CE;">Enter</b> フルスクリーンを切り替え；
<b>X</b> で増加、<b>Z</b> で <em>z</em> 指数を減少；
<b>F</b> で増加、<b>D</b> でピクセル比率を減少；
<b>A</b> アスペクト比を切り替え；
<b>M</b> パスに従う動画を作成；
<nobr><b>?</b> このヘルプを表示。</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<div lang="ru" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Исследователь фракталов множества Мандельброта
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Нажмите">Щелкните</span>, чтобы увеличить.</b>
<span mobile="">Щелкните правой кнопкой мыши, чтобы
сохранить изображения, <b>M</b>, чтобы создать и
сохранить видео вашего пути увеличения.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> итерируется
для каждого <a target="mbhelp"
href="http://en.wikipedia.org/wiki/Complex_number">комплексного числа</a>
<em>c</em>.  Цвета показывают <a target="mbhelp"
href="http://warp.povusers.org/Mandelbrot/">итерации</a> до расхождения;
черные точки <a
href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">сходятся или
циклируются</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Желтые точки показывают <a target="mbhelp"
href="https://plus.maths.org/content/unveiling-mandelbrot-set">орбиты</a></b>.
Красные точки показывают предельные циклы.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Об итерациях.</b> Этот просмотрщик показывает больше
деталей
фракталов с течением времени, уточняя итерации до
бесконечности по мере вашего исследования.
Чем дольше вы ждете, тем больше деталей отображается.
После тысяч или миллионов итераций вы можете
разрешить
мельчайшие детали в самых сложных частях фрактала.
Просмотрите информацию об итерациях, прогрессе и
координатах,
<span mobile="нажав на">наведя курсор на</span> желтый номер
увеличения под каждым окном.
<span mobile="Удерживая палец">Перемещение мыши</span> над
фрактальным содержимым анимирует орбиту значений
<em>z</em> для каждого
местоположения <em>c</em>, раскрывая сложную динамику
границ, которая восхищала математиков.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Исследование пути увеличения.</b>
Каждый <span mobile="нажатие">щелчок</span> на фрактале
открывает
более высокий уровень увеличения в выбранном месте,
вычисляемый на вашем GPU, если доступно.
После увеличения более чем в триллион раз мы
используем
алгоритм возмущения с четверной точностью, который
разрешает мелкие детали с точностью более 60 цифр.
Как только вы создадите интересный путь, показывающий
нужные вам детали, вы можете <a class="moviemode">создать и
загрузить собственное
видео глубокого увеличения Мандельброта</a> или
добавить закладку
на ваш URL, чтобы сохранить и поделиться своим
исследованием.
Для создания высококачественных изображений и видео
этот
просмотрщик вычисляет субпиксели с соотношением
<span class="pixelratio">2</span>:1<span mobile="">, и это может быть
увеличено для создания более точных дисплеев</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Дополнительные команды:</b>
<b>I</b> увеличивает;
<b mac="&#8984;">Ctrl</b>-щелчок для увеличения на месте;
<b>H</b> уменьшает, а <b>G</b> увеличивает каждое окно;
<b>R</b> повторно открывает промежуточные окна;
<b>C</b> перецентрирует все;
<b>T</b> меняет цветовую тему;
<b>U</b> выделяет незавершенные пиксели;
<b mac="&#x23CE;">Enter</b> переключает полноэкранный режим;
<b>X</b> увеличивает, а <b>Z</b> уменьшает показатель
степени <em>z</em>;
<b>F</b> увеличивает, а <b>D</b> уменьшает соотношение
пикселей;
<b>A</b> переключает соотношение сторон;
<b>M</b> создает видео, следующее вашему пути;
<nobr><b>?</b> показывает эту справку.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<div lang="de" style="display:none">
<h1 style="margin-top:3px;margin-bottom:6px;font-size:1.1em">
Mandelbrot-Menge Fraktal-Explorer
</h1>

<p style="margin-top:6px;margin-bottom:6px">
<b><span mobile="Tippen">Klicken</span> Sie zum Vergrößern.</b>
<span mobile="">Rechtsklick zum Speichern von Bildern, <b>M</b> zum Erstellen und
Speichern eines Videos Ihres Zoom-Pfads.</span>
</p>

<p style="margin-top:6px;margin-bottom:6px">
<em>z &rightarrow; z<sup class="exponent">2</sup>+c</em> wird für jede
<a target="mbhelp" href="http://en.wikipedia.org/wiki/Complex_number">komplexe Zahl</a>
<em>c</em> iteriert.  Farben zeigen
<a target="mbhelp" href="http://warp.povusers.org/Mandelbrot/">Iterationen</a> bis zur
Divergenz; schwarze Punkte
<a href="https://math.bu.edu/DYSYS/FRACGEOM/node3.html">konvergieren oder zyklieren</a>.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Gelbe Punkte zeigen
<a target="mbhelp" href="https://plus.maths.org/content/unveiling-mandelbrot-set">Bahnen</a></b>.
Rote Punkte zeigen Grenzzyklen.
</p>

<p style="margin-top:6px;margin-bottom:6px">
<b>Über Iterationen.</b> Dieser Viewer zeigt im Laufe der Zeit mehr fraktale Details,
indem er die Iterationen während Ihrer Erkundung gegen unendlich verfeinert. Je länger
Sie warten, desto mehr Details werden angezeigt.
Nach Tausenden oder Millionen von Iterationen können Sie die feinsten Details in den
komplexesten Teilen des Fraktals auflösen.
Sehen Sie Informationen zu Iterationen, Fortschritt und Koordinaten, indem Sie
<span mobile="tippen">mit der Maus über</span> die gelbe Zoom-Nummer unter jedem
Fenster fahren.
<span mobile="Halten Sie Ihren Finger">Bewegen Sie Ihre Maus</span> über fraktale
Inhalte, um die Bahn der <em>z</em>-Werte für jeden Ort <em>c</em> zu animieren und
die komplexe Randdynamik zu enthüllen, die Mathematiker fasziniert hat.
</p>
<p style="margin-top:6px;margin-bottom:6px">
<b>Einen Zoom-Pfad erkunden.</b>
Jeder <span mobile="Tipp">Klick</span> auf das Fraktal öffnet eine höhere Zoomstufe
an der ausgewählten Stelle, berechnet auf Ihrer GPU, falls verfügbar.
Nachdem Sie über eine billionenfache Vergrößerung hinaus gezoomt haben, verwenden wir
einen Störungsalgorithmus mit vierfacher Genauigkeit, der feine Details mit mehr als
60 Ziffern Genauigkeit auflöst.
Sobald Sie einen interessanten Pfad erstellt haben, der die gewünschten Details zeigt,
können Sie <a class="moviemode">Ihr eigenes Mandelbrot-Deep-Zoom-Video erstellen und
herunterladen</a> oder Ihre URL als Lesezeichen setzen, um Ihre Erkundung zu speichern
und zu teilen.
Um qualitativ hochwertige Bilder und Videos zu erstellen, berechnet dieser Viewer
Subpixel mit einem Verhältnis von <span class="pixelratio">2</span>:1<span mobile="">,
und dies kann erhöht werden, um präzisere Anzeigen zu erstellen</span>.
</p>

<p style="margin-top:6px;margin-bottom:6px" mobile="">
<b>Weitere Befehle:</b>
<b>I</b> zoomt hinein;
<b mac="&#8984;">Strg</b>-Klick zum direkten Zoomen;
<b>H</b> verkleinert und <b>G</b> vergrößert jedes Fenster;
<b>R</b> öffnet Zwischenfenster erneut;
<b>C</b> zentriert alle neu;
<b>T</b> ändert das Farbschema;
<b>U</b> hebt unfertige Pixel hervor;
<b mac="&#x23CE;">Enter</b> schaltet Vollbild um;
<b>X</b> erhöht und <b>Z</b> verringert den <em>z</em>-Exponenten;
<b>F</b> erhöht und <b>D</b> verringert das Pixelverhältnis;
<b>A</b> schaltet Seitenverhältnis um;
<b>M</b> erstellt ein Video, das Ihrem Pfad folgt;
<nobr><b>?</b> zeigt diese Hilfe.</nobr></p>

<p style="margin-top:8px;margin-bottom:0;text-align:right">
- <a target="mbhelp"
href="http://davidbau.com/archives/2009/09/27/mandelbrot.html"
>David Bau</a> <a target="mbhelp"
href="https://github.com/davidbau/mandelbrot#readme"
title="View source on GitHub"><svg
style="width:14px;height:14px;vertical-align:-2px"><use
href="#github-icon"/></svg></a></p>
</div>

<script id="i18nCode">
// Internationalization Messages
const Messages = {
  en: {
    center_at_: 'center at ',
    percent_done_after_: '% done after ',
    iters: ' iters',
    pre_rendering_movie: 'Pre-rendering movie...',
    pre_rendering_: 'Pre-rendering ',
    diverges_in_: '\ndiverges in ',
    converges_after_: '\nconverges after ',
    after_: '\nafter ',
    period_: ', period '
  },
  es: {
    center_at_: 'centro en ',
    percent_done_after_: '% completado después de ',
    iters: ' iteraciones',
    pre_rendering_movie: 'Pre-renderizando video...',
    pre_rendering_: 'Pre-renderizando ',
    diverges_in_: '\ndiverge en ',
    converges_after_: '\nconverge después de ',
    after_: '\ndespués de ',
    period_: ', período '
  },
  zh: {
    center_at_: '中心位于 ',
    percent_done_after_: '% 完成，已迭代 ',
    iters: ' 次',
    pre_rendering_movie: '正在预渲染视频...',
    pre_rendering_: '正在预渲染 ',
    diverges_in_: '\n在 ',
    converges_after_: '\n在 ',
    after_: '\n在 ',
    period_: ' 后发散，周期 '
  },
  'zh-TW': {
    center_at_: '中心位於 ',
    percent_done_after_: '% 完成，已迭代 ',
    iters: ' 次',
    pre_rendering_movie: '正在預渲染影片...',
    pre_rendering_: '正在預渲染 ',
    diverges_in_: '\n在 ',
    converges_after_: '\n在 ',
    after_: '\n在 ',
    period_: ' 後發散，週期 '
  },
  ar: {
    center_at_: 'المركز في ',
    percent_done_after_: '% مكتمل بعد ',
    iters: ' تكرار',
    pre_rendering_movie: 'جارٍ العرض المسبق للفيديو...',
    pre_rendering_: 'جارٍ العرض المسبق ',
    diverges_in_: '\nيتباعد في ',
    converges_after_: '\nيتقارب بعد ',
    after_: '\nبعد ',
    period_: '، الفترة '
  },
  id: {
    center_at_: 'pusat di ',
    percent_done_after_: '% selesai setelah ',
    iters: ' iterasi',
    pre_rendering_movie: 'Pra-rendering video...',
    pre_rendering_: 'Pra-rendering ',
    diverges_in_: '\ndivergen dalam ',
    converges_after_: '\nkonvergen setelah ',
    after_: '\nsetelah ',
    period_: ', periode '
  },
  pt: {
    center_at_: 'centro em ',
    percent_done_after_: '% concluído após ',
    iters: ' iterações',
    pre_rendering_movie: 'Pré-renderizando vídeo...',
    pre_rendering_: 'Pré-renderizando ',
    diverges_in_: '\ndiverge em ',
    converges_after_: '\nconverge após ',
    after_: '\napós ',
    period_: ', período '
  },
  fr: {
    center_at_: 'centre à ',
    percent_done_after_: '% terminé après ',
    iters: ' itérations',
    pre_rendering_movie: 'Pré-rendu de la vidéo...',
    pre_rendering_: 'Pré-rendu ',
    diverges_in_: '\ndiverge en ',
    converges_after_: '\nconverge après ',
    after_: '\naprès ',
    period_: ', période '
  },
  ja: {
    center_at_: '中心: ',
    percent_done_after_: '% 完了、',
    iters: ' 回反復',
    pre_rendering_movie: '動画をプレレンダリング中...',
    pre_rendering_: 'プレレンダリング中 ',
    diverges_in_: '\n',
    converges_after_: '\n',
    after_: '\n',
    period_: ' 回反復後に発散、周期 '
  },
  ru: {
    center_at_: 'центр в ',
    percent_done_after_: '% завершено после ',
    iters: ' итераций',
    pre_rendering_movie: 'Предварительный рендеринг видео...',
    pre_rendering_: 'Предварительный рендеринг ',
    diverges_in_: '\nрасходится за ',
    converges_after_: '\nсходится после ',
    after_: '\nпосле ',
    period_: ', период '
  },
  de: {
    center_at_: 'Zentrum bei ',
    percent_done_after_: '% abgeschlossen nach ',
    iters: ' Iterationen',
    pre_rendering_movie: 'Video wird vorgerendert...',
    pre_rendering_: 'Vorrendering ',
    diverges_in_: '\ndivergiert in ',
    converges_after_: '\nkonvergiert nach ',
    after_: '\nnach ',
    period_: ', Periode '
  }
};

// Global MSG object for current language
let MSG = Messages.en;

// Global selected language (for URL preservation)
let SELECTED_LANG = 'en';
let LANG_FROM_URL = false;

// Detect and display the appropriate language
(function() {
  // Get language from URL parameter or browser setting
  const urlParams = new URLSearchParams(window.location.search);
  const urlLang = urlParams.get('lang');
  const browserLang = navigator.language.toLowerCase();
  const userLang = urlLang || browserLang;

  // List of supported languages
  const supportedLangs = ['en', 'es', 'zh', 'zh-tw', 'ar', 'id', 'pt',
                          'fr', 'ja', 'ru', 'de'];

  // Try exact match first, then base language code (e.g., zh-TW -> zh-tw, then zh)
  let selectedLang = 'en';
  if (supportedLangs.includes(userLang)) {
    selectedLang = userLang;
  } else {
    const baseLang = userLang.split('-')[0];
    selectedLang = supportedLangs.includes(baseLang) ? baseLang : 'en';
  }

  // Set globals
  MSG = Messages[selectedLang] || Messages['en'];
  SELECTED_LANG = selectedLang;
  LANG_FROM_URL = !!urlLang && supportedLangs.includes(urlLang);

  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', applyLanguage);
  } else {
    applyLanguage();
  }

  function applyLanguage() {
    const langDivs = document.querySelectorAll('#text [lang]');
    langDivs.forEach(div => {
      const divLang = div.getAttribute('lang').toLowerCase();
      div.style.display = divLang === selectedLang ? '' : 'none';
    });
  }
})();
</script>
<!-- BEGIN_MP4MUXER_LIBRARY -->
<!-- mp4-muxer library (stripped, ~28KB) -->
<!-- Source: https://www.npmjs.com/package/mp4-muxer -->
<!-- Built with: node scripts/build-mp4muxer.js --update-html -->
<script id="mp4Muxer">
(() => {
  // build/mp4Muxer.transformed.js
  (() => {
    "use strict";
    var __accessCheck = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    var __privateGet = (obj, member, getter) => {
      __accessCheck(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    var __privateAdd = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    var __privateSet = (obj, member, value, setter) => {
      __accessCheck(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    var __privateMethod = (obj, member, method) => {
      __accessCheck(obj, member, "access private method");
      return method;
    };
    var bytes = new Uint8Array(8);
    var view = new DataView(bytes.buffer);
    var u8 = (value) => {
      return [(value % 256 + 256) % 256];
    };
    var u16 = (value) => {
      view.setUint16(0, value, false);
      return [bytes[0], bytes[1]];
    };
    var i16 = (value) => {
      view.setInt16(0, value, false);
      return [bytes[0], bytes[1]];
    };
    var u24 = (value) => {
      view.setUint32(0, value, false);
      return [bytes[1], bytes[2], bytes[3]];
    };
    var u32 = (value) => {
      view.setUint32(0, value, false);
      return [bytes[0], bytes[1], bytes[2], bytes[3]];
    };
    var i32 = (value) => {
      view.setInt32(0, value, false);
      return [bytes[0], bytes[1], bytes[2], bytes[3]];
    };
    var u64 = (value) => {
      view.setUint32(0, Math.floor(value / 2 ** 32), false);
      view.setUint32(4, value, false);
      return [bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]];
    };
    var fixed_8_8 = (value) => {
      view.setInt16(0, 2 ** 8 * value, false);
      return [bytes[0], bytes[1]];
    };
    var fixed_16_16 = (value) => {
      view.setInt32(0, 2 ** 16 * value, false);
      return [bytes[0], bytes[1], bytes[2], bytes[3]];
    };
    var fixed_2_30 = (value) => {
      view.setInt32(0, 2 ** 30 * value, false);
      return [bytes[0], bytes[1], bytes[2], bytes[3]];
    };
    var ascii = (text, nullTerminated = false) => {
      let bytes2 = Array(text.length).fill(null).map((_, i) => text.charCodeAt(i));
      if (nullTerminated)
        bytes2.push(0);
      return bytes2;
    };
    var last = (arr) => {
      return arr && arr[arr.length - 1];
    };
    var lastPresentedSample = (samples) => {
      let result = void 0;
      for (let sample of samples) {
        if (!result || sample.presentationTimestamp > result.presentationTimestamp) {
          result = sample;
        }
      }
      return result;
    };
    var intoTimescale = (timeInSeconds, timescale, round = true) => {
      let value = timeInSeconds * timescale;
      return round ? Math.round(value) : value;
    };
    var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var deepClone = (x) => {
      if (!x)
        return x;
      if (typeof x !== "object")
        return x;
      if (Array.isArray(x))
        return x.map(deepClone);
      return Object.fromEntries(
        Object.entries(x).map(([key, value]) => [key, deepClone(value)]));
    };
    var isU32 = (value) => {
      return value >= 0 && value < 2 ** 32;
    };
    var box = (type, contents, children) => ({
      type,
      contents: contents && new Uint8Array(contents.flat(10)),
      children
    });
    var fullBox = (type, version, flags, contents, children) => box(
      type,
      [u8(version), u24(flags), contents ?? []],
      children
    );
    var ftyp = (details) => {
      let minorVersion = 512;
      return box("ftyp", [
        ascii("isom"),
        // Major brand
        u32(minorVersion),
        // Minor version
        // Compatible brands
        ascii("isom"),
        details.holdsAvc ? ascii("avc1") : [],
        ascii("mp41")
      ]);
    };
    var mdat = (reserveLargeSize) => ({ type: "mdat", largeSize: reserveLargeSize });
    var moov = (tracks, creationTime, fragmented = false) => box("moov", null, [
      mvhd(creationTime, tracks),
      ...tracks.map((x) => trak(x, creationTime)),
      null
    ]);
    var mvhd = (creationTime, tracks) => {
      let duration = intoTimescale(Math.max(
        0,
        ...tracks.filter((x) => x.samples.length > 0).map((x) => {
          const lastSample = lastPresentedSample(x.samples);
          return lastSample.presentationTimestamp + lastSample.duration;
        })
      ), GLOBAL_TIMESCALE);
      let nextTrackId = Math.max(...tracks.map((x) => x.id)) + 1;
      let needsU64 = !isU32(creationTime) || !isU32(duration);
      let u32OrU64 = needsU64 ? u64 : u32;
      return fullBox("mvhd", +needsU64, 0, [
        u32OrU64(creationTime),
        // Creation time
        u32OrU64(creationTime),
        // Modification time
        u32(GLOBAL_TIMESCALE),
        // Timescale
        u32OrU64(duration),
        // Duration
        fixed_16_16(1),
        // Preferred rate
        fixed_8_8(1),
        // Preferred volume
        Array(10).fill(0),
        // Reserved
        [fixed_16_16(1), fixed_16_16(0), fixed_2_30(0),
         fixed_16_16(0), fixed_16_16(1), fixed_2_30(0),
         fixed_16_16(0), fixed_16_16(0), fixed_2_30(1)],
        // Matrix
        Array(24).fill(0),
        // Pre-defined
        u32(nextTrackId)
        // Next track ID
      ]);
    };
    var trak = (track, creationTime) => box("trak", null, [
      tkhd(track, creationTime),
      mdia(track, creationTime)
    ]);
    var tkhd = (track, creationTime) => {
      let lastSample = lastPresentedSample(track.samples);
      let durationInGlobalTimescale = intoTimescale(
        lastSample ? lastSample.presentationTimestamp + lastSample.duration : 0,
        GLOBAL_TIMESCALE
      );
      let needsU64 = !isU32(creationTime) || !isU32(durationInGlobalTimescale);
      let u32OrU64 = needsU64 ? u64 : u32;
      let matrix = IDENTITY_MATRIX;
      return fullBox("tkhd", +needsU64, 3, [
        u32OrU64(creationTime),
        // Creation time
        u32OrU64(creationTime),
        // Modification time
        u32(track.id),
        // Track ID
        u32(0),
        // Reserved
        u32OrU64(durationInGlobalTimescale),
        // Duration
        Array(8).fill(0),
        // Reserved
        u16(0),
        // Layer
        u16(0),
        // Alternate group
        fixed_8_8(track.info.type === "audio" ? 1 : 0),
        // Volume
        u16(0),
        // Reserved
        [fixed_16_16(1), fixed_16_16(0), fixed_2_30(0),
         fixed_16_16(0), fixed_16_16(1), fixed_2_30(0),
         fixed_16_16(0), fixed_16_16(0), fixed_2_30(1)],
        // Matrix
        fixed_16_16(track.info.type === "video" ? track.info.width : 0),
        // Track width
        fixed_16_16(track.info.type === "video" ? track.info.height : 0)
        // Track height
      ]);
    };
    var mdia = (track, creationTime) => box("mdia", null, [
      mdhd(track, creationTime),
      hdlr(track.info.type === "video" ? "vide" : "soun"),
      minf(track)
    ]);
    var mdhd = (track, creationTime) => {
      let lastSample = lastPresentedSample(track.samples);
      let localDuration = intoTimescale(
        lastSample ? lastSample.presentationTimestamp + lastSample.duration : 0,
        track.timescale
      );
      let needsU64 = !isU32(creationTime) || !isU32(localDuration);
      let u32OrU64 = needsU64 ? u64 : u32;
      return fullBox("mdhd", +needsU64, 0, [
        u32OrU64(creationTime),
        // Creation time
        u32OrU64(creationTime),
        // Modification time
        u32(track.timescale),
        // Timescale
        u32OrU64(localDuration),
        // Duration
        u16(21956),
        // Language ("und", undetermined)
        u16(0)
        // Quality
      ]);
    };
    var hdlr = (componentSubtype) => fullBox("hdlr", 0, 0, [
      ascii("mhlr"),
      // Component type
      ascii(componentSubtype),
      // Component subtype
      u32(0),
      // Component manufacturer
      u32(0),
      // Component flags
      u32(0),
      // Component flags mask
      ascii("mp4-muxer-hdlr", true)
      // Component name
    ]);
    var minf = (track) => box("minf", null, [
      vmhd(),
      dinf(),
      stbl(track)
    ]);
    var vmhd = () => fullBox("vmhd", 0, 1, [
      u16(0),
      // Graphics mode
      u16(0),
      // Opcolor R
      u16(0),
      // Opcolor G
      u16(0)
      // Opcolor B
    ]);
    var dinf = () => box("dinf", null, [
      dref()
    ]);
    var dref = () => fullBox("dref", 0, 0, [
      u32(1)
      // Entry count
    ], [
      url()
    ]);
    var url = () => fullBox("url ", 0, 1);
    var stbl = (track) => {
      const needsCtts = track.compositionTimeOffsetTable.length > 1 ||
        track.compositionTimeOffsetTable.some((x) => x.sampleCompositionTimeOffset !== 0);
      return box("stbl", null, [
        stsd(track),
        stts(track),
        stss(track),
        stsc(track),
        stsz(track),
        stco(track),
        needsCtts ? ctts(track) : null
      ]);
    };
    var stsd = (track) => fullBox("stsd", 0, 0, [
      u32(1)
      // Entry count
    ], [
      videoSampleDescription(VIDEO_CODEC_TO_BOX_NAME[track.info.codec], track)
    ]);
    var videoSampleDescription = (compressionType, track) => box(compressionType, [
      Array(6).fill(0),
      // Reserved
      u16(1),
      // Data reference index
      u16(0),
      // Pre-defined
      u16(0),
      // Reserved
      Array(12).fill(0),
      // Pre-defined
      u16(track.info.width),
      // Width
      u16(track.info.height),
      // Height
      u32(4718592),
      // Horizontal resolution
      u32(4718592),
      // Vertical resolution
      u32(0),
      // Reserved
      u16(1),
      // Frame count
      Array(32).fill(0),
      // Compressor name
      u16(24),
      // Depth
      i16(65535)
      // Pre-defined
    ], [
      VIDEO_CODEC_TO_CONFIGURATION_BOX[track.info.codec](track),
      track.info.decoderConfig.colorSpace ? colr(track) : null
    ]);
    var COLOR_PRIMARIES_MAP = {
      "bt709": 1,
      // ITU-R BT.709
      "bt470bg": 5,
      // ITU-R BT.470BG
      "smpte170m": 6
      // ITU-R BT.601 525 - SMPTE 170M
    };
    var TRANSFER_CHARACTERISTICS_MAP = {
      "bt709": 1,
      // ITU-R BT.709
      "smpte170m": 6,
      // SMPTE 170M
      "iec61966-2-1": 13
      // IEC 61966-2-1
    };
    var MATRIX_COEFFICIENTS_MAP = {
      "rgb": 0,
      // Identity
      "bt709": 1,
      // ITU-R BT.709
      "bt470bg": 5,
      // ITU-R BT.470BG
      "smpte170m": 6
      // SMPTE 170M
    };
    var colr = (track) => box("colr", [
      ascii("nclx"),
      // Colour type
      u16(COLOR_PRIMARIES_MAP[track.info.decoderConfig.colorSpace.primaries]),
      // Colour primaries
      u16(TRANSFER_CHARACTERISTICS_MAP[track.info.decoderConfig.colorSpace.transfer]),
      // Transfer characteristics
      u16(MATRIX_COEFFICIENTS_MAP[track.info.decoderConfig.colorSpace.matrix]),
      // Matrix coefficients
      u8((track.info.decoderConfig.colorSpace.fullRange ? 1 : 0) << 7)
      // Full range flag
    ]);
    var avcC = (track) => track.info.decoderConfig && box("avcC", [
      // For AVC, description is an AVCDecoderConfigurationRecord, so nothing else to do here
      ...new Uint8Array(track.info.decoderConfig.description)
    ]);
    var stts = (track) => {
      return fullBox("stts", 0, 0, [
        u32(track.timeToSampleTable.length),
        // Number of entries
        track.timeToSampleTable.map((x) => [
          // Time-to-sample table
          u32(x.sampleCount),
          // Sample count
          u32(x.sampleDelta)
          // Sample duration
        ])
      ]);
    };
    var stss = (track) => {
      if (track.samples.every((x) => x.type === "key"))
        return null;
      let keySamples = [...track.samples.entries()]
        .filter(([, sample]) => sample.type === "key");
      return fullBox("stss", 0, 0, [
        u32(keySamples.length),
        // Number of entries
        keySamples.map(([index]) => u32(index + 1))
        // Sync sample table
      ]);
    };
    var stsc = (track) => {
      return fullBox("stsc", 0, 0, [
        u32(track.compactlyCodedChunkTable.length),
        // Number of entries
        track.compactlyCodedChunkTable.map((x) => [
          // Sample-to-chunk table
          u32(x.firstChunk),
          // First chunk
          u32(x.samplesPerChunk),
          // Samples per chunk
          u32(1)
          // Sample description index
        ])
      ]);
    };
    var stsz = (track) => fullBox("stsz", 0, 0, [
      u32(0),
      // Sample size (0 means non-constant size)
      u32(track.samples.length),
      // Number of entries
      track.samples.map((x) => u32(x.size))
      // Sample size table
    ]);
    var stco = (track) => {
      if (track.finalizedChunks.length > 0 && last(track.finalizedChunks).offset >= 2 ** 32) {
        return fullBox("co64", 0, 0, [
          u32(track.finalizedChunks.length),
          // Number of entries
          track.finalizedChunks.map((x) => u64(x.offset))
          // Chunk offset table
        ]);
      }
      return fullBox("stco", 0, 0, [
        u32(track.finalizedChunks.length),
        // Number of entries
        track.finalizedChunks.map((x) => u32(x.offset))
        // Chunk offset table
      ]);
    };
    var ctts = (track) => {
      return fullBox("ctts", 0, 0, [
        u32(track.compositionTimeOffsetTable.length),
        // Number of entries
        track.compositionTimeOffsetTable.map((x) => [
          // Time-to-sample table
          u32(x.sampleCount),
          // Sample count
          u32(x.sampleCompositionTimeOffset)
          // Sample offset
        ])
      ]);
    };
    var VIDEO_CODEC_TO_BOX_NAME = {
      "avc": "avc1",
      "hevc": "hvc1",
      "vp9": "vp09",
      "av1": "av01"
    };
    var VIDEO_CODEC_TO_CONFIGURATION_BOX = { "avc": avcC };
    var AUDIO_CODEC_TO_CONFIGURATION_BOX = {};
    var isTarget = Symbol("isTarget");
    var Target = class {
    };
    isTarget;
    var ArrayBufferTarget = class extends Target {
      constructor() {
        super(...arguments);
        this.buffer = null;
      }
    };
    var _helper, _helperView;
    var Writer = class {
      constructor() {
        this.pos = 0;
        __privateAdd(this, _helper, new Uint8Array(8));
        __privateAdd(this, _helperView, new DataView(__privateGet(this, _helper).buffer));
        this.offsets = /* @__PURE__ */ new WeakMap();
      }
      /** Sets the current position for future writes to a new one. */
      seek(newPos) {
        this.pos = newPos;
      }
      writeU32(value) {
        __privateGet(this, _helperView).setUint32(0, value, false);
        this.write(__privateGet(this, _helper).subarray(0, 4));
      }
      writeU64(value) {
        __privateGet(this, _helperView).setUint32(0, Math.floor(value / 2 ** 32), false);
        __privateGet(this, _helperView).setUint32(4, value, false);
        this.write(__privateGet(this, _helper).subarray(0, 8));
      }
      writeAscii(text) {
        for (let i = 0; i < text.length; i++) {
          __privateGet(this, _helperView).setUint8(i % 8, text.charCodeAt(i));
          if (i % 8 === 7)
            this.write(__privateGet(this, _helper));
        }
        if (text.length % 8 !== 0) {
          this.write(__privateGet(this, _helper).subarray(0, text.length % 8));
        }
      }
      writeBox(box2) {
        this.offsets.set(box2, this.pos);
        if (box2.contents && !box2.children) {
          this.writeBoxHeader(box2, box2.size ?? box2.contents.byteLength + 8);
          this.write(box2.contents);
        } else {
          let startPos = this.pos;
          this.writeBoxHeader(box2, 0);
          if (box2.contents)
            this.write(box2.contents);
          if (box2.children) {
            for (let child of box2.children)
              if (child)
                this.writeBox(child);
          }
          let endPos = this.pos;
          let size = box2.size ?? endPos - startPos;
          this.seek(startPos);
          this.writeBoxHeader(box2, size);
          this.seek(endPos);
        }
      }
      writeBoxHeader(box2, size) {
        this.writeU32(box2.largeSize ? 1 : size);
        this.writeAscii(box2.type);
        if (box2.largeSize)
          this.writeU64(size);
      }
      measureBoxHeader(box2) {
        return 8 + (box2.largeSize ? 8 : 0);
      }
      measureBox(box2) {
        if (box2.contents && !box2.children) {
          let headerSize = this.measureBoxHeader(box2);
          return headerSize + box2.contents.byteLength;
        } else {
          let result = this.measureBoxHeader(box2);
          if (box2.contents)
            result += box2.contents.byteLength;
          if (box2.children) {
            for (let child of box2.children)
              if (child)
                result += this.measureBox(child);
          }
          return result;
        }
      }
    };
    _helper = /* @__PURE__ */ new WeakMap();
    _helperView = /* @__PURE__ */ new WeakMap();
    var _target, _buffer, _bytes, _maxPos, _ensureSize, ensureSize_fn;
    var ArrayBufferTargetWriter = class extends Writer {
      constructor(target) {
        super();
        __privateAdd(this, _ensureSize);
        __privateAdd(this, _target, void 0);
        __privateAdd(this, _buffer, new ArrayBuffer(2 ** 16));
        __privateAdd(this, _bytes, new Uint8Array(__privateGet(this, _buffer)));
        __privateAdd(this, _maxPos, 0);
        __privateSet(this, _target, target);
      }
      write(data) {
        __privateMethod(this, _ensureSize, ensureSize_fn).call(this, this.pos + data.byteLength);
        __privateGet(this, _bytes).set(data, this.pos);
        this.pos += data.byteLength;
        __privateSet(this, _maxPos,
          Math.max(__privateGet(this, _maxPos), this.pos));
      }
      finalize() {
        __privateMethod(this, _ensureSize, ensureSize_fn).call(this, this.pos);
        __privateGet(this, _target).buffer = __privateGet(this, _buffer).slice(0,
          Math.max(__privateGet(this, _maxPos), this.pos));
      }
    };
    _target = /* @__PURE__ */ new WeakMap();
    _buffer = /* @__PURE__ */ new WeakMap();
    _bytes = /* @__PURE__ */ new WeakMap();
    _maxPos = /* @__PURE__ */ new WeakMap();
    _ensureSize = /* @__PURE__ */ new WeakSet();
    ensureSize_fn = function(size) {
      let newLength = __privateGet(this, _buffer).byteLength;
      while (newLength < size)
        newLength *= 2;
      if (newLength === __privateGet(this, _buffer).byteLength)
        return;
      let newBuffer = new ArrayBuffer(newLength);
      let newBytes = new Uint8Array(newBuffer);
      newBytes.set(__privateGet(this, _bytes), 0);
      __privateSet(this, _buffer, newBuffer);
      __privateSet(this, _bytes, newBytes);
    };
    var DEFAULT_CHUNK_SIZE = 2 ** 24;
    var MAX_CHUNKS_AT_ONCE = 2;
    var GLOBAL_TIMESCALE = 1e3;
    var SUPPORTED_VIDEO_CODECS = ["avc", "hevc", "vp9", "av1"];
    var TIMESTAMP_OFFSET = 2082844800;
    var FIRST_TIMESTAMP_BEHAVIORS = ["strict", "offset", "cross-track-offset"];
    var _options, _writer, _ftypSize, _mdat, _videoTrack, _creationTime;
    var _finalizedChunks, _finalized;
    var _validateOptions, validateOptions_fn;
    var _writeHeader, writeHeader_fn;
    var _prepareTracks, prepareTracks_fn;
    var _createSampleForTrack, createSampleForTrack_fn;
    var _addSampleToTrack, addSampleToTrack_fn;
    var _validateTimestamp, validateTimestamp_fn;
    var _finalizeCurrentChunk, finalizeCurrentChunk_fn;
    var _maybeFlushStreamingTargetWriter, maybeFlushStreamingTargetWriter_fn;
    var _ensureNotFinalized, ensureNotFinalized_fn;
    var Muxer = class {
      constructor(options) {
        __privateAdd(this, _validateOptions);
        __privateAdd(this, _writeHeader);
        __privateAdd(this, _prepareTracks);
        __privateAdd(this, _createSampleForTrack);
        __privateAdd(this, _addSampleToTrack);
        __privateAdd(this, _validateTimestamp);
        __privateAdd(this, _finalizeCurrentChunk);
        __privateAdd(this, _maybeFlushStreamingTargetWriter);
        __privateAdd(this, _ensureNotFinalized);
        __privateAdd(this, _options, void 0);
        __privateAdd(this, _writer, void 0);
        __privateAdd(this, _ftypSize, void 0);
        __privateAdd(this, _mdat, void 0);
        __privateAdd(this, _videoTrack, null);
        __privateAdd(this, _creationTime, Math.floor(Date.now() / 1e3) + TIMESTAMP_OFFSET);
        __privateAdd(this, _finalizedChunks, []);
        __privateAdd(this, _finalized, false);
        __privateMethod(this, _validateOptions, validateOptions_fn).call(this, options);
        options.video = deepClone(options.video);
        options.audio = deepClone(options.audio);
        options.fastStart = deepClone(options.fastStart);
        this.target = options.target;
        __privateSet(this, _options, {
          firstTimestampBehavior: "strict",
          ...options
        });
        if (options.target instanceof ArrayBufferTarget) {
          __privateSet(this, _writer, new ArrayBufferTargetWriter(options.target));
        } else {
          throw new Error(`Invalid target: ${options.target}`);
        }
        __privateMethod(this, _prepareTracks, prepareTracks_fn).call(this);
        __privateMethod(this, _writeHeader, writeHeader_fn).call(this);
      }
      addVideoChunk(sample, meta, timestamp, compositionTimeOffset) {
        if (!(sample instanceof EncodedVideoChunk)) {
          throw new TypeError("sample must be EncodedVideoChunk");
        }
        if (meta && typeof meta !== "object") {
          throw new TypeError("meta must be object");
        }
        if (timestamp !== void 0 && (!Number.isFinite(timestamp) || timestamp < 0)) {
          throw new TypeError(
            "timestamp must be non-negative"
          );
        }
        if (compositionTimeOffset !== void 0 &&
            !Number.isFinite(compositionTimeOffset)) {
          throw new TypeError(
            "compositionTimeOffset must be number"
          );
        }
        let data = new Uint8Array(sample.byteLength);
        sample.copyTo(data);
        this.addVideoChunkRaw(
          data,
          sample.type,
          timestamp ?? sample.timestamp,
          sample.duration,
          meta,
          compositionTimeOffset
        );
      }
      addVideoChunkRaw(data, type, timestamp, duration, meta, compositionTimeOffset) {
        if (!(data instanceof Uint8Array)) {
          throw new TypeError("data must be Uint8Array");
        }
        if (type !== "key" && type !== "delta") {
          throw new TypeError("type must be 'key'|'delta'");
        }
        if (!Number.isFinite(timestamp) || timestamp < 0) {
          throw new TypeError("timestamp must be non-negative");
        }
        if (!Number.isFinite(duration) || duration < 0) {
          throw new TypeError("duration must be non-negative");
        }
        if (meta && typeof meta !== "object") {
          throw new TypeError("meta must be object");
        }
        if (compositionTimeOffset !== void 0 &&
            !Number.isFinite(compositionTimeOffset)) {
          throw new TypeError(
            "compositionTimeOffset must be number"
          );
        }
        __privateMethod(this, _ensureNotFinalized, ensureNotFinalized_fn).call(this);
        if (!__privateGet(this, _options).video)
          throw new Error("No video track declared.");
        let videoSample = __privateMethod(
          this, _createSampleForTrack, createSampleForTrack_fn
        ).call(
          this, __privateGet(this, _videoTrack), data, type,
          timestamp, duration, meta, compositionTimeOffset
        );
        __privateMethod(
          this, _addSampleToTrack, addSampleToTrack_fn
        ).call(this, __privateGet(this, _videoTrack), videoSample);
      }
      /**
       * Finalizes the file, making it ready for use.
       * Must be called after all video and audio chunks have been added.
       */
      finalize() {
        if (__privateGet(this, _finalized)) {
          throw new Error("Cannot finalize a muxer more than once.");
        }
        if (__privateGet(this, _videoTrack))
          __privateMethod(
            this, _finalizeCurrentChunk, finalizeCurrentChunk_fn
          ).call(this, __privateGet(this, _videoTrack));
        let tracks = [__privateGet(this, _videoTrack)].filter(Boolean);
        if (__privateGet(this, _options).fastStart === "in-memory") {
          let mdatSize;
          for (let i = 0; i < 2; i++) {
            let movieBox2 = moov(tracks, __privateGet(this, _creationTime));
            let movieBoxSize = __privateGet(this, _writer).measureBox(movieBox2);
            mdatSize = __privateGet(this, _writer).measureBox(__privateGet(this, _mdat));
            let currentChunkPos = __privateGet(this, _writer).pos + movieBoxSize + mdatSize;
            for (let chunk of __privateGet(this, _finalizedChunks)) {
              chunk.offset = currentChunkPos;
              for (let { data } of chunk.samples) {
                currentChunkPos += data.byteLength;
                mdatSize += data.byteLength;
              }
            }
            if (currentChunkPos < 2 ** 32)
              break;
            if (mdatSize >= 2 ** 32)
              __privateGet(this, _mdat).largeSize = true;
          }
          let movieBox = moov(tracks, __privateGet(this, _creationTime));
          __privateGet(this, _writer).writeBox(movieBox);
          __privateGet(this, _mdat).size = mdatSize;
          __privateGet(this, _writer).writeBox(__privateGet(this, _mdat));
          for (let chunk of __privateGet(this, _finalizedChunks)) {
            for (let sample of chunk.samples) {
              __privateGet(this, _writer).write(sample.data);
              sample.data = null;
            }
          }
        }
        __privateMethod(
          this, _maybeFlushStreamingTargetWriter,
          maybeFlushStreamingTargetWriter_fn
        ).call(this);
        __privateGet(this, _writer).finalize();
        __privateSet(this, _finalized, true);
      }
    };
    _options = /* @__PURE__ */ new WeakMap();
    _writer = /* @__PURE__ */ new WeakMap();
    _ftypSize = /* @__PURE__ */ new WeakMap();
    _mdat = /* @__PURE__ */ new WeakMap();
    _videoTrack = /* @__PURE__ */ new WeakMap();
    _creationTime = /* @__PURE__ */ new WeakMap();
    _finalizedChunks = /* @__PURE__ */ new WeakMap();
    _finalized = /* @__PURE__ */ new WeakMap();
    _validateOptions = /* @__PURE__ */ new WeakSet();
    validateOptions_fn = function(options) {
      if (typeof options !== "object") {
        throw new TypeError("options required");
      }
      if (!(options.target instanceof Target)) {
        throw new TypeError("target must be Target instance");
      }
      if (options.video) {
        if (!SUPPORTED_VIDEO_CODECS.includes(options.video.codec)) {
          throw new TypeError(`Unsupported video codec: ${options.video.codec}`);
        }
        if (!Number.isInteger(options.video.width) || options.video.width <= 0) {
          throw new TypeError(
            `Invalid video width: ${options.video.width}. Must be a positive integer.`
          );
        }
        if (!Number.isInteger(options.video.height) || options.video.height <= 0) {
          throw new TypeError(
            `Invalid video height: ${options.video.height}. Must be a positive integer.`
          );
        }
        const videoRotation = options.video.rotation;
        if (typeof videoRotation === "number" && ![0, 90, 180, 270].includes(videoRotation)) {
          throw new TypeError(
            `Invalid video rotation: ${videoRotation}. Has to be 0, 90, 180 or 270.`
          );
        } else if (
          Array.isArray(videoRotation) &&
          (videoRotation.length !== 9 ||
           videoRotation.some((value) => typeof value !== "number"))
        ) {
          throw new TypeError(`Invalid video transformation matrix: ${videoRotation.join()}`);
        }
        if (
          options.video.frameRate !== void 0 &&
          (!Number.isInteger(options.video.frameRate) ||
           options.video.frameRate <= 0)
        ) {
          throw new TypeError(
            `Invalid video frame rate: ${options.video.frameRate}. Must be a positive integer.`
          );
        }
      }
      if (
        options.firstTimestampBehavior &&
        !FIRST_TIMESTAMP_BEHAVIORS.includes(options.firstTimestampBehavior)
      ) {
        throw new TypeError(
          `Invalid first timestamp behavior: ${options.firstTimestampBehavior}`);
      }
      if (options.fastStart !== "in-memory") {
        throw new TypeError(`'fastStart' must be 'in-memory'.`);
      }
    };
    _writeHeader = /* @__PURE__ */ new WeakSet();
    writeHeader_fn = function() {
      __privateGet(this, _writer).writeBox(ftyp({
        holdsAvc: __privateGet(this, _options).video?.codec === "avc",
        fragmented: false
      }));
      __privateSet(this, _ftypSize, __privateGet(this, _writer).pos);
      __privateSet(this, _mdat, mdat(false));
      __privateMethod(
        this, _maybeFlushStreamingTargetWriter,
        maybeFlushStreamingTargetWriter_fn
      ).call(this);
    };
    _prepareTracks = /* @__PURE__ */ new WeakSet();
    prepareTracks_fn = function() {
      if (__privateGet(this, _options).video) {
        __privateSet(this, _videoTrack, {
          id: 1,
          info: {
            type: "video",
            codec: __privateGet(this, _options).video.codec,
            width: __privateGet(this, _options).video.width,
            height: __privateGet(this, _options).video.height,
            rotation: __privateGet(this, _options).video.rotation ?? 0,
            decoderConfig: null
          },
          // The fallback contains many common frame rates as factors
          timescale: __privateGet(this, _options).video.frameRate ?? 57600,
          samples: [],
          finalizedChunks: [],
          currentChunk: null,
          firstDecodeTimestamp: void 0,
          lastDecodeTimestamp: -1,
          timeToSampleTable: [],
          compositionTimeOffsetTable: [],
          lastTimescaleUnits: null,
          lastSample: null,
          compactlyCodedChunkTable: []
        });
      }
    };
    _createSampleForTrack = /* @__PURE__ */ new WeakSet();
    createSampleForTrack_fn = function(
      track, data, type, timestamp, duration, meta, compositionTimeOffset
    ) {
      let presentationTimestampInSeconds = timestamp / 1e6;
      let decodeTimestampInSeconds = (timestamp - (compositionTimeOffset ?? 0)) / 1e6;
      let durationInSeconds = duration / 1e6;
      let adjusted = __privateMethod(
        this, _validateTimestamp, validateTimestamp_fn
      ).call(
        this, presentationTimestampInSeconds, decodeTimestampInSeconds, track
      );
      presentationTimestampInSeconds = adjusted.presentationTimestamp;
      decodeTimestampInSeconds = adjusted.decodeTimestamp;
      if (meta?.decoderConfig) {
        if (track.info.decoderConfig === null) {
          track.info.decoderConfig = meta.decoderConfig;
        } else {
          Object.assign(track.info.decoderConfig, meta.decoderConfig);
        }
      }
      let sample = {
        presentationTimestamp: presentationTimestampInSeconds,
        decodeTimestamp: decodeTimestampInSeconds,
        duration: durationInSeconds,
        data,
        size: data.byteLength,
        type,
        // Will be refined once the next sample comes in
        timescaleUnitsToNextSample: intoTimescale(durationInSeconds, track.timescale)
      };
      return sample;
    };
    _addSampleToTrack = /* @__PURE__ */ new WeakSet();
    addSampleToTrack_fn = function(track, sample) {
      track.samples.push(sample);
      const sampleCompositionTimeOffset = intoTimescale(
        sample.presentationTimestamp - sample.decodeTimestamp,
        track.timescale
      );
      if (track.lastTimescaleUnits !== null) {
        let timescaleUnits = intoTimescale(sample.decodeTimestamp, track.timescale, false);
        let delta = Math.round(timescaleUnits - track.lastTimescaleUnits);
        track.lastTimescaleUnits += delta;
        track.lastSample.timescaleUnitsToNextSample = delta;
        if (__privateGet(this, _options).fastStart !== "fragmented") {
          let lastTableEntry = last(track.timeToSampleTable);
          if (lastTableEntry.sampleCount === 1) {
            lastTableEntry.sampleDelta = delta;
            lastTableEntry.sampleCount++;
          } else if (lastTableEntry.sampleDelta === delta) {
            lastTableEntry.sampleCount++;
          } else {
            lastTableEntry.sampleCount--;
            track.timeToSampleTable.push({
              sampleCount: 2,
              sampleDelta: delta
            });
          }
          const lastCompositionTimeOffsetTableEntry = last(track.compositionTimeOffsetTable);
          if (
            lastCompositionTimeOffsetTableEntry.sampleCompositionTimeOffset ===
            sampleCompositionTimeOffset
          ) {
            lastCompositionTimeOffsetTableEntry.sampleCount++;
          } else {
            track.compositionTimeOffsetTable.push({
              sampleCount: 1,
              sampleCompositionTimeOffset
            });
          }
        }
      } else {
        track.lastTimescaleUnits = 0;
        track.timeToSampleTable.push({
          sampleCount: 1,
          sampleDelta: intoTimescale(sample.duration, track.timescale)
        });
        track.compositionTimeOffsetTable.push({
          sampleCount: 1,
          sampleCompositionTimeOffset
        });
      }
      track.lastSample = sample;
      let beginNewChunk = false;
      if (!track.currentChunk) {
        beginNewChunk = true;
      } else {
        let currentChunkDuration = sample.presentationTimestamp -
          track.currentChunk.startTimestamp;
        beginNewChunk = currentChunkDuration >= 0.5;
      }
      if (beginNewChunk) {
        if (track.currentChunk) {
          __privateMethod(this, _finalizeCurrentChunk, finalizeCurrentChunk_fn).call(this, track);
        }
        track.currentChunk = {
          startTimestamp: sample.presentationTimestamp,
          samples: []
        };
      }
      track.currentChunk.samples.push(sample);
    };
    _validateTimestamp = /* @__PURE__ */ new WeakSet();
    validateTimestamp_fn = function(presentationTimestamp, decodeTimestamp, track) {
      const strictTimestampBehavior =
        __privateGet(this, _options).firstTimestampBehavior === "strict";
      const noLastDecodeTimestamp = track.lastDecodeTimestamp === -1;
      const timestampNonZero = decodeTimestamp !== 0;
      if (strictTimestampBehavior && noLastDecodeTimestamp && timestampNonZero) {
        throw new Error(
          `First chunk must have timestamp 0 (got DTS=${decodeTimestamp}). ` +
          `Use firstTimestampBehavior:"offset" to auto-fix.`
        );
      } else if (
        __privateGet(this, _options).firstTimestampBehavior === "offset" ||
        __privateGet(this, _options).firstTimestampBehavior === "cross-track-offset"
      ) {
        if (track.firstDecodeTimestamp === void 0) {
          track.firstDecodeTimestamp = decodeTimestamp;
        }
        let baseDecodeTimestamp;
        if (__privateGet(this, _options).firstTimestampBehavior === "offset") {
          baseDecodeTimestamp = track.firstDecodeTimestamp;
        } else {
          baseDecodeTimestamp = Math.min(
            __privateGet(this, _videoTrack)?.firstDecodeTimestamp ?? Infinity,
            Infinity
          );
        }
        decodeTimestamp -= baseDecodeTimestamp;
        presentationTimestamp -= baseDecodeTimestamp;
      }
      if (decodeTimestamp < track.lastDecodeTimestamp) {
        throw new Error(
          `Timestamps must be monotonically increasing ` +
          `(DTS went from ${track.lastDecodeTimestamp * 1e6} to ${decodeTimestamp * 1e6}).`
        );
      }
      track.lastDecodeTimestamp = decodeTimestamp;
      return { presentationTimestamp, decodeTimestamp };
    };
    _finalizeCurrentChunk = /* @__PURE__ */ new WeakSet();
    finalizeCurrentChunk_fn = function(track) {
      if (!track.currentChunk)
        return;
      track.finalizedChunks.push(track.currentChunk);
      __privateGet(this, _finalizedChunks).push(track.currentChunk);
      if (
        track.compactlyCodedChunkTable.length === 0 ||
        last(track.compactlyCodedChunkTable).samplesPerChunk !==
        track.currentChunk.samples.length
      ) {
        track.compactlyCodedChunkTable.push({
          firstChunk: track.finalizedChunks.length,
          // 1-indexed
          samplesPerChunk: track.currentChunk.samples.length
        });
      }
      if (__privateGet(this, _options).fastStart === "in-memory") {
        track.currentChunk.offset = 0;
      }
    };
    _maybeFlushStreamingTargetWriter = /* @__PURE__ */ new WeakSet();
    maybeFlushStreamingTargetWriter_fn = function() {
    };
    _ensureNotFinalized = /* @__PURE__ */ new WeakSet();
    ensureNotFinalized_fn = function() {
      if (__privateGet(this, _finalized)) {
        throw new Error(
          "Cannot add new video or audio chunks after the file has been finalized.");
      }
    };
    window.Mp4Muxer = { Muxer, ArrayBufferTarget };
  })();
})();

</script>
<!-- END_MP4MUXER_LIBRARY -->
<script id="startApp">
// Start the application
window.explorer = new MandelbrotExplorer();
window.explorer.start();
</script>
</div> <!-- closes id=text -->
</body>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W8X6PWJH83"></script>
<script id="analytics">
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-W8X6PWJH83');
</script>
</html>
