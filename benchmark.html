<!doctype html>
<html>
<head>
<title>Board Performance Benchmark</title>
<style>
body {
  font-family: monospace;
  padding: 20px;
  background: #1e1e1e;
  color: #d4d4d4;
}
.results {
  background: #252526;
  padding: 15px;
  border-radius: 5px;
  margin: 10px 0;
}
table {
  border-collapse: collapse;
  width: 100%;
  margin: 10px 0;
}
th, td {
  text-align: left;
  padding: 8px;
  border-bottom: 1px solid #444;
}
th {
  font-weight: bold;
  border-bottom: 2px solid #666;
}
.winner { color: #4ec9b0; }
.tie { color: #ce9178; }
button {
  padding: 10px 20px;
  font-size: 14px;
  font-family: monospace;
  margin: 5px;
  cursor: pointer;
}
#status {
  color: #4ec9b0;
  margin: 10px 0;
}
</style>
</head>
<body>

<h1>Mandelbrot Board Performance Benchmark</h1>
<p>Testing optimized ZhuoranBoard with Chebyshev norm rebasing check</p>

<div>
  <button onclick="runBenchmark('deep')">Benchmark: Deep Zoom (1e-13)</button>
  <button onclick="runBenchmark('verydeep')">Benchmark: Very Deep (1e-16)</button>
  <button onclick="runBenchmark('extreme')">Benchmark: Extreme (1e-20)</button>
  <button onclick="runAllBenchmarks()">Run All Benchmarks</button>
</div>

<div id="status"></div>
<div id="results"></div>

<script id="quadCode">
//////////// quad-precision (qd, double double) utilities ///////////

function toQd(x) {
  return Array.isArray(x) ? x : [x, 0];
}

function toQdc(c) {
  if (c.length == 4) { return c; }
  const r = toQd(c[0]);
  const j = toQd(c[1]);
  return [r[0], r[1], j[0], j[1]];
}

function fast2Sum(a, b) {
  let s = a + b;
  let t = b - (s - a);
  return [s, t];
}

function slow2Sum(a, b) {
  let s = a + b;
  let c = s - a;
  return [s, (a - (s - c)) + (b - c)];
}

function qdSplit(a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  return [x, y];
}

function twoProduct(a, b) {
  let p = a * b;
  let [ah, al] = qdSplit(a);
  let [bh, bl] = qdSplit(b);
  let err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  return [p, err];
}

function twoSquare(a) {
  let p = a * a;
  let [ah, al] = qdSplit(a);
  let err = ((ah * ah - p) + 2 * ah * al) + al * al;
  return [p, err];
}

function qdAdd(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [h1, h2] = slow2Sum(a1, b1);
  let [l1, l2] = slow2Sum(a0, b0);
  let [v1, v2] = fast2Sum(h1, h2 + l1);
  return fast2Sum(v1, v2 + l2);
}

function qdMul(a, b) {
  let [a1, a0] = a;
  let [b1, b0] = b;
  let [p1, p2] = twoProduct(a1, b1);
  return fast2Sum(p1, p2 + a1 * b0 + b1 * a0);
}

function qdDouble(a) {
  return [a[0] * 2, a[1] * 2];
}

function qdScale(q, s) {
  let [q1, q0] = q;
  let [p1, p2] = twoProduct(q1, s);
  return fast2Sum(p1, p2 + s * q0);
}

function qdSquare(a) {
  let [a1, a0] = a;
  let [p1, p2] = twoSquare(a1);
  return fast2Sum(p1, p2 + 2 * a1 * a0);
}

function qdcPow(q, n) {
  if (n === 1) return q;
  if (n === 2) return qdcSquare(q);
  if (n === 3) return qdcMul(qdSquare(q), q);
  let result = [1, 0, 0, 0];
  let base = q;
  while (n > 0) {
    if (n % 2 === 1) { result = qdcMul(result, base); }
    base = qdcSquare(base);
    n = Math.floor(n / 2);
  }
  return result;
}

function qdNegate(a) {
  let [a1, a0] = a;
  return [-a1, -a0];
}

function qdSub(a, b) {
  return qdAdd(a, qdNegate(b));
}

function qdDiv(a, b) {
  let reciprocal = qdReciprocal(b);
  return qdMul(a, reciprocal);
}

function qdReciprocal(b, iters = 2) {
  if (b[0] === 0 && b[1] === 0) {
    return [NaN, 0];  // Return NaN for division by zero
  }
  // Refine the approximation using Newton-Raphson iteration
  let x = [1 / b[0], 0];
  for (let i = 0; i < iters; i++) {
    x = qdMul(x, qdSub([2, 0], qdMul(x, b)));
  }
  return x;
}

// Complex operations in quad precision
function qdcAdd(a, b) {
  let realSum = qdAdd([a[0], a[1]], [b[0], b[1]]);
  let imagSum = qdAdd([a[2], a[3]], [b[2], b[3]]);
  return [realSum[0], realSum[1], imagSum[0], imagSum[1]];
}

// Complex subtraction in quad precision
function qdcSub(a, b) {
  let realDiff = qdSub([a[0], a[1]], [b[0], b[1]]);
  let imagDiff = qdSub([a[2], a[3]], [b[2], b[3]]);
  return [realDiff[0], realDiff[1], imagDiff[0], imagDiff[1]];
}

// Complex multiplication in quad precision
function qdcMul(a, b) {
  let ac = qdMul([a[0], a[1]], [b[0], b[1]]);
  let bd = qdMul([a[2], a[3]], [b[2], b[3]]);
  let adbc = qdMul(qdAdd([a[0], a[1]], [a[2], a[3]]), qdAdd([b[0], b[1]], [b[2], b[3]]));
  let real = qdSub(ac, bd);
  let imag = qdSub(adbc, qdAdd(ac, bd));
  return [real[0], real[1], imag[0], imag[1]];
}

// Complex doubling in quad precision
function qdcDouble(a) {
  let realDouble = qdDouble([a[0], a[1]]);
  let imagDouble = qdDouble([a[2], a[3]]);
  return [realDouble[0], realDouble[1], imagDouble[0], imagDouble[1]];
}

// Complex squaring in quad precision
function qdcSquare(a) {
  let a0a0 = qdSquare([a[0], a[1]]);
  let a1a1 = qdSquare([a[2], a[3]]);
  let a0a1 = qdMul([a[0], a[1]], [a[2], a[3]]);
  let real = qdSub(a0a0, a1a1);
  let imag = qdDouble(a0a1);
  return [real[0], real[1], imag[0], imag[1]];
}

// Complex absolute value in quad precision
function qdcAbs(a) {
  let a0a0 = qdSquare([a[0], a[1]]);
  let a1a1 = qdSquare([a[2], a[3]]);
  return qdAdd(a0a0, a1a1);
}

function qdParse(s) {
  s = s.trim().toLowerCase();
  if (s === "infinity" || s === "+infinity") return [Infinity, 0];
  if (s === "-infinity") return [-Infinity, 0];
  if (s === "nan") return [NaN, 0];
  let sign = 1;
  if (s[0] === '-') {
    sign = -1;
    s = s.slice(1);
  } else if (s[0] === '+') {
    s = s.slice(1);
  }
  let e = 0;
  let parts = s.split('e');
  if (parts.length > 1) {
    s = parts[0];
    e = parseInt(parts[1]);
  }
  let decimalPos = s.indexOf('.');
  if (decimalPos !== -1) {
    s = s.replace('.', '');
    e -= s.length - decimalPos;
  }
  s = s.replace(/^0+/, '');
  if (s === '') return [0, 0];
  let result = [0, 0];
  for (let digit of s) {
    result = qdAdd(qdMul(result, [10, 0]), [parseInt(digit), 0]);
  }
  if (e !== 0) {
    result = qdMul(result, qdPow10(e));
  }
  if (sign === -1) {
    result = qdNegate(result);
  }
  return result;
}

function qdPow10(e) {
  if (e < 0) return qdReciprocal(qdPow10(-e));
  // Up to 1e16, the second component is zero.
  if (e <= 16) { return [10 ** e, 0]; }
  if (e % 2) { return qdMul([1e15, 0], qdPow10(e - 15)) };
  return qdSquare(qdPow10(e / 2));
}

function qdFloor(q) {
  let [a, b] = q;
  let fl = Math.floor(a);
  let [r0, r1] = qdAdd([a, b], [-fl, 0]);
  if (r0 < 0 || (r0 === 0 && r1 < 0)) {
    fl -= 1;
  }
  return [fl, 0];
}

function qdCompare(a, b) {
  if (a[0] < b[0]) return -1;
  if (a[0] > b[0]) return 1;
  if (a[1] < b[1]) return -1;
  if (a[1] > b[1]) return 1;
  return 0;
}

function qdLt(a, s) {
  return a[0] < s || (a[0] == s && a[1] < 0);
}

function qdEq(a, s) {
  return a[0] == s && a[1] == 0;
}

function qdAbs(q) {
  return (q[0] + q[1] < 0) ? qdNegate(q) : q;
}

function qdFixed(q, digits = 0) {
  // With fixed-point notation, digits specifies the number of digits after the decimal point.
  return qdFormat(q, digits, true);
}

const qdTen = [10, 0];

function qdFormat(q, digits = 'auto', useFixedPoint = false) {
  // With scientific notation, digits specifies the number of significant digits.
  let [a, b] = q;
  let s = a < 0 || (a === 0 && b < 0) ? '-' : '';
  let autoFormat = (digits == 'auto');
  if (autoFormat) {
     digits = 32;
  }
  q = qdAbs(q);
  if (!isFinite(a) || !isFinite(b)) return a.toString();
  if (a === 0 && b === 0) {
     if (autoFormat) return '0';
     if (useFixedPoint) digits += 1;
     return '0' + (digits > 1 ? '.' + '0'.repeat(digits - 1) : '');
  }
  // Scale q to be between 1 and 10
  let e = parseInt(q[0].toExponential().match(/e([+-]\d+)/)[1]);
  if (qdCompare(q, qdPow10(e)) < 0) { e -= 1; }
  if (qdCompare(q, qdPow10(1+e)) >= 0) { e += 1; }
  if (e) { q = qdMul(q, qdPow10(-e)); }
  if (!qdLt(q, 10)) { // Hit boundary condition
    q = qdDiv(q, qdTen);
    e += 1;
  }
  let result = '';
  let nonzeroDigits = digits;
  if (useFixedPoint && !autoFormat) {
     nonzeroDigits = nonzeroDigits + e + 1;
  }
  for (let i = 0; i < nonzeroDigits + 1; i++) {
    let floorQ = qdFloor(q);
    let digit = floorQ[0];
    result += digit;
    q = qdSub(q, floorQ);
    q = qdMul(q, qdTen);
  }
  // Rounding
  if (nonzeroDigits < 0) {
    // No nonzero signficant digits? Treat as zero.
    result = '?';
    nonzeroDigits = 0;
    e = 0;
  } else if (parseInt(result[nonzeroDigits]) >= 5) {
    result = result.slice(0, nonzeroDigits) + '?';
    let carry = 1;
    for (let i = nonzeroDigits - 1; i >= 0; i--) {
      let digit = parseInt(result[i]) + carry;
      if (digit < 10) {
        result = result.slice(0, i) + digit + result.slice(i + 1);
        carry = 0;
        break;
      } else {
        result = result.slice(0, i) + '0' + result.slice(i + 1);
        carry = 1;
      }
    }
    if (carry) {
      result = '1' + result;
      nonzeroDigits += 1;
      e++;
    }
  }
  result = result.slice(0, nonzeroDigits);
  epart = '';
  if (!useFixedPoint && (!autoFormat || e < -6 || e >= 32)) {
    // Scientific notation
    if (result.length > 1) {
      result = result[0] + '.' + result.slice(1);
    }
    if (e !== 0) {
      epart = 'e' + e;
    }
  } else {
    // Fixed-point notation
    if (e >= 0) {
      result = result.padEnd(e + 1, '0');
      result = result.slice(0, e + 1) + '.' + result.slice(e + 1);
    } else {
      result = '0.' + '0'.repeat(-e - 1) + result;
    }
    // Ensure the correct number of digits after the decimal point
    let [intPart, fracPart] = result.split('.');
    if (digits <= 0) {
      result = intPart;
    } else {
      fracPart = (fracPart || '').padEnd(digits, '0');
      result = intPart + '.' + fracPart;
    }
  }
  if (autoFormat) {
    // Auto digit selection: trim trailing zeros
    result = result.replace(/\.0+$|(\.\d*[1-9])0+$/, "$1");
  }
  return s + result + epart;
}

// Array in-place quad precision, allows fast computation
// by avoiding array constructors

function Afast2Sum(r, i, a, b) {
  let s = a + b;
  r[i] = s;
  r[i+1] = b - (s - a);
}

function Aslow2Sum(r, i, a, b) {
  let s = a + b;
  let c = s - a;
  r[i] = s;
  r[i+1] = (a - (s - c)) + (b - c);
}

function AqdSplit(r, i, a) {
  const c = (134217729) * a;  // 2^27 + 1, Veltkamp-Dekker constant
  const x = c - (c - a);
  const y = a - x;
  r[i] = x;
  r[i+1] = y;
}

function AtwoProduct(r, i, a, b) {
  const p = a * b;
  AqdSplit(r, i, a);
  const ah = r[i];
  const al = r[i+1];
  AqdSplit(r, i, b);
  const bh = r[i];
  const bl = r[i+1];
  const err = ((ah * bh - p) + ah * bl + al * bh) + al * bl;
  r[i] = p;
  r[i+1] = err;
}

function AtwoSquare(r, i, a) {
  const p = a * a;
  AqdSplit(r, i, a);
  const ah = r[i];
  const al = r[i+1];
  const err = ((ah * ah - p) + 2 * ah * al) + al * al;
  r[i] = p;
  r[i+1] = err;
}

function AqdAdd(r, i, a1, a2, b1, b2) {
  Aslow2Sum(r, i, a1, b1);
  const h1 = r[i];
  const h2 = r[i+1];
  Aslow2Sum(r, i, a2, b2);
  const l1 = r[i];
  const l2 = r[i+1];
  Afast2Sum(r, i, h1, h2 + l1);
  const v1 = r[i];
  const v2 = r[i+1];
  Afast2Sum(r, i, v1, v2 + l2);
}

function AqdMul(r, i, a1, a2, b1, b2) {
  AtwoProduct(r, i, a1, b1);
  const p1 = r[i];
  const p2 = r[i+1];
  Afast2Sum(r, i, p1, p2 + a1 * b2 + b1 * a2);
}

function AqdSet(r, i, a1, a2) {
  r[i] = a1;
  r[i+1] = a2;
}

function AqdcCopy(r, i, s, si) {
  r[i] = s[si];
  r[i+1] = s[si+1];
  r[i+2] = s[si+2];
  r[i+3] = s[si+3];
}

function AqdcGet(s, si) {
  return s.slice(si, si+4);
}

function AqdSquare(r, i, a1, a2) {
  AtwoSquare(r, i, a1);
  const p1 = r[i];
  const p2 = r[i+1];
  Afast2Sum(r, i, p1, p2 + 2 * a1 * a2);
}

function AqdAbsSub(r, i, a1, a2, b1, b2) {
  AqdAdd(r, i, a1, a2, -b1, -b2);
  if (r[i] + r[i+1] < 0) {
    r[i] = -r[i];
    r[i+1] = -r[i+1];
  }
}

// Additional shared utility function for tracking cycles.

function figurePeriod(iteration) {
  // Returns 1 plus the number of iterations since the most recent multiple
  // of a high power-of-two-exceeding-3/4-digits-of(iteration).
  let tail = 1;
  if (iteration) while (Math.floor(iteration / tail) ** 3 > tail) { tail *= 2; }
  return iteration - (Math.floor(iteration / tail) * tail) + 1
}
</script>

<script id="workerCode">
class Board {
  constructor(k, size, re, im, config, id) {
    this.k = k;    // Number in explorer
    this.sizes = [size, toQd(re), toQd(im)];
    this.id = id;  // Random ID
    this.config = config;  // Global config

    this.it = 1;            // Current iteration
    this.un = config.dims2; // Unfinished pixels
    this.di = 0;            // Diverged pixels
    this.ch = 0;            // Chaotic pixels
    this.effort = 1;        // Work-per pixel

    this.pix = this.sizes[0] / this.config.dims;
    this.epsilon = Math.min(1e-12, this.pix / 10);
    this.epsilon2 = Math.min(1e-9, this.pix * 10);

    this.lastTime = 0;      // Time last message sent out
    this.changeList = [];   // List of new data to send
    this.updateSize = 0;    // Amount of data to send

    // Initialize arrays
    this.nn = new Array(this.config.dims2).fill(0);
    this.pp = new Array(this.config.dims2).fill(0);
    this.cc = [];
    this.zz = [];
    this.bb = [];
  }

  serialize() {
    return {
      type: this.constructor.name,
      k: this.k,
      sizes: this.sizes,
      id: this.id,
      config: this.config,
      it: this.it,
      un: this.un,
      di: this.di,
      ch: this.ch,
      lastTime: this.lastTime,
      changeList: this.changeList,
      updateSize: this.updateSize
    };
  }

  compact() {
  }

  queueChanges(changes) {
    if (changes !== null) {
      this.changeList.push(changes);
      this.updateSize += changes.nn.length + changes.vv.length;
    }
  }

  static fromSerialized(serialized) {
    const subclasses = new Map([
      ['CpuBoard', CpuBoard],
      ['PerturbationBoard', PerturbationBoard]
    ]);
    return subclasses.get(serialized.type).fromSerialized(serialized);
  }

  inspike(re, im) {
    // We do not iterate infinitely for chaotic points in the spike.
    return (im == 0.0 && re > -2.0 && re < -1.401155 &&
            this.config.exponent == 2);
  }

  inspikeQdA(re1, re2, im1, im2) {
    // We do not iterate infinitely for chaotic points in the spike.
    return (im1 + im2 == 0.0 && re1 >= -2.0 && re1 < -1.401155 &&
            this.config.exponent == 2);
  }

  unfinished() {
    // Chaotic points in the spike counted as finished after 100000 iterations.
    const result = Math.max(0, this.un + (this.it < 100000 ? 0 : -this.ch));
    return result;
  }
}

class CpuBoard extends Board {
  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);

    // Convert re and im to quad-double if they're scalars
    if (typeof re === 'number') re = toQd(re);
    if (typeof im === 'number') im = toQd(im);

    // Initialize board
    for (let y = 0; y < this.config.dims; y++) {
      const jFrac = (0.5 - (y / this.config.dims));
      const j = jFrac * size + im[0];
      for (let x = 0; x < this.config.dims; x++) {
        const rFrac = ((x / this.config.dims) - 0.5);
        const r = rFrac * size + re[0];
        this.cc.push(r, j);
        if (this.inspike(r, j)) {
          this.ch += 1;
        }
      }
    }

    this.zz = this.cc.slice();
    this.bb = this.cc.slice();
    this.ss = Array(this.config.dims2).fill(null).map((_, i) => i);
  }

  static fromSerialized(serialized) {
    const board = new CpuBoard(
      serialized.k,
      serialized.sizes[0],
      serialized.sizes[1],
      serialized.sizes[2],
      serialized.config,
      serialized.id
    );

    // Override initialized values with serialized data
    Object.assign(board, serialized);

    // Reconstruct sparse arrays from serialized data
    const cc = board.cc;
    board.cc = [];
    board.zz = [];
    board.bb = [];
    board.pp = [];
    for (let i = 0; i < serialized.ss.length; i++) {
      const index = serialized.ss[i];
      board.cc[index * 2] = cc[index * 2];
      board.cc[index * 2 + 1] = cc[index * 2 + 1];
      board.zz[index * 2] = serialized.zz[i * 2];
      board.zz[index * 2 + 1] = serialized.zz[i * 2 + 1];
      board.bb[index * 2] = serialized.bb[i * 2];
      board.bb[index * 2 + 1] = serialized.bb[i * 2 + 1];
      board.pp[index] = serialized.pp[i];
    }

    return board;
  }

  serialize() {
    return {
      ...super.serialize(),
      ss: this.ss,
      zz: this.ss.flatMap(i => [this.zz[i*2], this.zz[i*2+1]]),
      bb: this.ss.flatMap(i => [this.bb[i*2], this.bb[i*2+1]]),
      pp: this.ss.map(index => this.pp[index]),
    }
  }

  iterate() {
    let changes = null;

    const results = [0, 0, 0];
    let s = this.ss;    // speedy list of indexes to compute
    // head and tail factor i into an odd num and largest power of 2.
    if (figurePeriod(this.it) == 1) {
      for (let t = 0; t < s.length; ++t) {
        let m = s[t];
        if (this.nn[m]) continue;
        this.bb[m * 2] = this.zz[m * 2];
        this.bb[m * 2 + 1] = this.zz[m * 2 + 1];
        this.pp[m] = 0;
      }
    }
    for (let t = 0; t < s.length; ++t) {
      const index = s[t];
      const computeResult = this.compute(index);
      if (computeResult !== 0) {
        if (!changes) {
          changes = { iter: this.it, nn: [], vv: [] };
        }
        if (computeResult < 0) {
          changes.vv.push({
            index: index,
            z: [this.zz[index * 2], this.zz[index * 2 + 1]],
            p: this.pp[index]
          });
        } else {
          changes.nn.push(index);
        }
      }
    }
    if (changes) {
      this.un -= changes.nn.length + changes.vv.length; // newly finished
      this.di += changes.nn.length; // diverged
    }
    if (s.length > this.un * 1.25) {
      this.compact();
      if (this.ss.length > this.un + this.ch) {
        // Debug: Check for overlap between ss and changes
        if (changes) {
          const ssSet = new Set(this.ss);
          const changedIndexes = new Set([...changes.nn, ...changes.vv.map(v => v.index)]);
          const overlap = [...ssSet].filter(x => changedIndexes.has(x));
          if (overlap.length > 0) {
            console.warn(`Overlap detected between ss and changes: ${overlap.length} items`);
            console.warn(`Overlap indexes: ${overlap}`);
            console.warn(`ss length: ${this.ss.length}, un: ${this.un}`);
            console.warn(`changes: nn ${changes.nn.length}, vv ${changes.vv.length}`);
          }
        }

        // Additional checks
        const uniqueSS = new Set(this.ss);
        if (uniqueSS.size !== this.ss.length) {
          console.warn(`Duplicate entries in ss detected. ss length: ${this.ss.length}, unique entries: ${uniqueSS.size}`);
        }

        const invalidIndexes = this.ss.filter(i => this.nn[i]);
        if (invalidIndexes.length > 0) {
          console.warn(`Found ${invalidIndexes.length} indexes in ss that are already marked as finished in nn`);
        }

        if (this.ss.length !== this.un + this.ch) {
          console.warn(`Mismatch between ss length (${this.ss.length}) and un (${this.un})`);
        }
        throw new Error(`excess ss ${s.length}, ${this.ss.length}, ${this.un}`);
      }
    }

    this.it++;
    this.queueChanges(changes);
  }

  compact() {
    this.ss = this.ss.filter(i => !this.nn[i]);
  }

  compute(m) {
    if (this.nn[m]) return 0;
    const m2 = m * 2;
    const m2i = m2 + 1;
    const r = this.zz[m2];
    const j = this.zz[m2i];
    const r2 = r * r;
    const j2 = j * j;
    if (r2 + j2 > 4.0) {
      this.nn[m] = this.it;
      return 1;
    }
    let ra = r2 - j2;
    let ja = 2 * r * j;
    for (let ord = 2; ord < this.config.exponent; ord++) {
      let rt = r * ra - j * ja;
      ja = r * ja + j * ra;
      ra = rt;
    }
    ra += this.cc[m2];
    ja += this.cc[m2i];
    this.zz[m2] = ra;
    this.zz[m2i] = ja;
    const rb = this.bb[m2];
    const jb = this.bb[m2i];
    const db = Math.abs(rb - ra) + Math.abs(jb - ja);
    if (db <= this.epsilon2) {
      if (!this.pp[m]) { this.pp[m] = this.it; }
      if (db <= this.epsilon) {
        this.nn[m] = -this.it;
        if (this.inspike(this.cc[m2], this.cc[m2i]) && this.ch > 0) {
          this.ch -= 1;
        }
        return -1;
      }
    }
    return 0;
  }

}

class PerturbationBoard extends Board {
  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);

    this.quadIndexes = [];
    this.pertIndexes = [];
    this.tt = [];
    this.perturbationThreshold = Math.min(0.1, Math.sqrt(1e15 * (size / config.dims)));
    this.effort = 3;
    this.initPerturbationBoard(size, re, im);
  }

  initPerturbationBoard(size, re, im) {
    this.cc = new Array(this.config.dims2 * 4).fill(NaN);
    // Odd grid ensures that center point corresponds to a quad precision pixel
    const gridSize = Math.floor(this.config.dims / 17 / 2) * 2 + 1;
    const step = this.config.dims / gridSize;
    const offset = step / 2;
    const pix = size / this.config.dims;
    const cc = this.cc;
    re = toQd(re);
    im = toQd(im);

    // Initialize reference points and perturbations
    for (let gy = 0; gy < gridSize; gy++) {
      const ry = Math.round(gy * step + offset);
      const jFrac = (0.5 - (ry / this.config.dims));
      const cj = qdAdd(im, qdScale(toQd(jFrac), size))
      for (let gx = 0; gx < gridSize; gx++) {
        const rx = Math.round(gx * step + offset);
        const rFrac = ((rx / this.config.dims) - 0.5);
        const refIndex = (ry * this.config.dims + rx);
        const ri = refIndex * 4;
        const cr = qdAdd(re, qdScale(toQd(rFrac), size));

        // Initialize reference point
        cc[ri] = cr[0];
        cc[ri+1] = cr[1];
        cc[ri+2] = cj[0];
        cc[ri+3] = cj[1];
        this.quadIndexes.push(refIndex);
        let refspike = this.inspikeQdA(cr[0], cr[1], cj[0], cj[1]);
        if (refspike) {
          this.ch += 1;
        }

        // Initialize perturbations around this reference point
        const minY = Math.max(0, Math.floor(ry - offset));
        const maxY = Math.min(this.config.dims - 1, Math.ceil(ry + offset));
        const minX = Math.max(0, Math.floor(rx - offset));
        const maxX = Math.min(this.config.dims - 1, Math.ceil(rx + offset));
        for (let py = minY; py <= maxY; py++) {
          const dci = (ry - py) * pix;
          for (let px = minX; px <= maxX; px++) {
            const dcr = (px - rx) * pix;
            const pertIndex = (py * this.config.dims + px);
            const pi = pertIndex * 4;
            if (isNaN(cc[pi+3])) {  // Avoid double-initialization
              cc[pi] = dcr;
              cc[pi+1] = dci;
              cc[pi+2] = refIndex;
              cc[pi+3] = Infinity;
              this.pertIndexes.push(pertIndex);
              if (refspike && py == ry) {
                this.ch += 1;
              }
            }
          }
        }
      }
    }

    this.zz = this.cc.slice();
    this.bb = [];
    this.nz = [];
  }

  static fromSerialized(serialized) {
    const board = new PerturbationBoard(
      serialized.k,
      serialized.sizes[0],
      serialized.sizes[1],
      serialized.sizes[2],
      serialized.config,
      serialized.id
    );
    const cc = board.cc;

    // Override initialized values with serialized data
    Object.assign(board, serialized);
    delete board.pertZZ;

    // Reconstruct arrays from serialized data, leaving empty spots
    board.cc = [];
    board.zz = [];
    board.nz = [];
    board.bb = [];
    board.pp = [];
    for (let i = 0; i < serialized.quadIndexes.length; i++) {
      const index = serialized.quadIndexes[i];
      for (let j = 0; j < 4; j++) {
        board.zz[index * 4 + j] = board.nz[index * 4 + j] = serialized.zz[i * 4 + j];
        board.bb[index * 4 + j] = serialized.bb[i * 4 + j];
        board.cc[index * 4 + j] = cc[index * 4 + j];
      }
      if (!isFinite(cc[index * 4 + 3])) {
        board.initAsQuadPrecision(index, cc);
      }
      board.pp[index] = serialized.pp[i];
    }
    for (let i = 0; i < serialized.pertIndexes.length; i++) {
      const index = serialized.pertIndexes[i];
      for (let j = 0; j < 3; j++) {
        board.zz[index * 4 + j] = serialized.pertZZ[i * 3 + j];
        board.cc[index * 4 + j] = cc[index * 4 + j];
      }
      board.zz[index * 4 + 3] = board.cc[index * 4 + 3] = Infinity;
      board.pp[index] = 0;
    }
    return board;
  }

  serialize() {
    return {
      ...super.serialize(),
      quadIndexes: this.quadIndexes,
      pertIndexes: this.pertIndexes,
      zz: this.quadIndexes.flatMap(i => [this.zz[i*4], this.zz[i*4+1], this.zz[i*4+2], this.zz[i*4+3]]),
      bb: this.quadIndexes.flatMap(i => [this.bb[i*4], this.bb[i*4+1], this.bb[i*4+2], this.bb[i*4+3]]),
      pp: this.quadIndexes.map(index => this.pp[index]),
      pertZZ: this.pertIndexes.flatMap(i => [this.zz[i*4], this.zz[i*4+1], this.zz[i*4+2]]),
    };
  }

  iterate() {
    let changes = null;

    let i = this.it;
    let head = i, tail = 1;
    while ((head & 1) == 0) { head >>= 1; tail <<= 1; }
    let results = [0, 0, 0];

    // Precompute quad-precision point escape without updating z
    for (const index of this.quadIndexes) {
      if (head <= tail && !this.nn[index]) {
        AqdcCopy(this.bb, index*4, this.zz, index*4);
        this.pp[index] = 0;
      }
      let r = this.precomputeQuad(index);
      results[r + 1] += 1;
      if (r !== 0) {
        if (!changes) {
          changes = { iter: this.it, nn: [], vv: [] };
        }
        if (r < 0) {
          changes.vv.push({
            index: index,
            z: AqdcGet(this.nz, index*4),
            p: this.pp[index]
          });
        } else {
          changes.nn.push(index);
        }
      }
    }

    // Iterate perturbation points that use the old z
    const newQuadIndexes = [];
    let cache = { refIndex: null, binZpow: [] };
    for (const index of this.pertIndexes) {
      if (!this.computePerturbation(index, cache)) {
        this.convertToQuadPrecision(index);
        let r = this.precomputeQuad(index);
        results[r + 1] += 1;
        newQuadIndexes.push(index);
        if (r !== 0) {
          if (!changes) {
            changes = { iter: this.it, nn: [], vv: [] };
          }
          if (r < 0) {
            changes.vv.push({
              index: index,
              z: z,
              p: this.pp[index]
            });
          } else {
            changes.nn.push(index);
          }
        }
      }
    }

    // Update index arrays
    if (newQuadIndexes.length > 0) {
      const newPertIndexes = [];
      let qi = 0;
      for (const index of this.pertIndexes) {
        if (newQuadIndexes[qi] == index) {
          qi += 1;
        } else {
          newPertIndexes.push(index);
        }
      }
      this.quadIndexes = this.quadIndexes.concat(newQuadIndexes);
      this.pertIndexes = newPertIndexes;
    }

    // Finally update quad-precision z with precomputed values
    for (const index of this.quadIndexes) {
      AqdcCopy(this.zz, index*4, this.nz, index*4);
    }

    // Tally progress
    let diverged = results[2];
    let count = results[0] + diverged;
    this.un -= count;
    this.di += diverged;

    // Trim finished pixels from array.
    if (this.pertIndexes.length + this.quadIndexes.length > this.un * 1.25) {
      this.compact();
      // Switch to full quad when perturbations are a small fraction of the work
      if (this.pertIndexes.length < this.quadIndexes.length * 0.5) {
        for (const index of this.pertIndexes) {
          this.convertToQuadPrecision(index);
          this.quadIndexes.push(index);
        }
        this.pertIndexes = [];
      }
    }

    this.it++;
    this.queueChanges(changes);
  }

  compact() {
    const trimmedQuadIndexes = this.quadIndexes.filter(i => !this.nn[i]);
    this.quadIndexes = trimmedQuadIndexes;
  }

  precomputeQuad(m) {
    // Quad-precision compute
    if (this.nn[m]) return 0;
    const m4 = m * 4;
    const tt = this.tt;
    const nz = this.nz;
    const r1 = this.zz[m4];
    const r2 = this.zz[m4+1];
    const j1 = this.zz[m4+2];
    const j2 = this.zz[m4+3];
    const cr1 = this.cc[m4];
    const cr2 = this.cc[m4+1];
    const cj1 = this.cc[m4+2];
    const cj2 = this.cc[m4+3];
    const br1 = this.bb[m4];
    const br2 = this.bb[m4+1];
    const bj1 = this.bb[m4+2];
    const bj2 = this.bb[m4+3];

    AqdSquare(tt, 0, r1, r2);                    // 0: rsq = r**2
    AqdSquare(tt, 2, j1, j2);                    // 2: jsq = j**2
    AqdAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);   // 4: d = rsq+jsq
    if (tt[4] > 4) {  // tt[4] is the high part of the magnitude squared
      this.nn[m] = this.it;
      AqdcCopy(nz, m4, this.zz, m4);
      return 1;
    }
    AqdMul(tt, 6, 2 * r1, 2 * r2, j1, j2);       // 6: ja = 2*r*j
    AqdAdd(tt, 8, tt[0], tt[1], -tt[2], -tt[3]); // 8: ra = rsq-jsq
    for (let ord = 2; ord < this.config.exponent; ord++) {
      AqdMul(tt, 0, j1, j2, tt[6], tt[7]);         // 0: j * ja
      AqdMul(tt, 2, r1, r2, tt[8], tt[9]);         // 2: r * ra
      AqdAdd(tt, 4, -tt[0], -tt[1], tt[2], tt[3]); // 4: rt = r*ra - j*ja
      AqdMul(tt, 0, r1, r2, tt[6], tt[7]);         // 0: r * ja
      AqdMul(tt, 2, j1, j2, tt[8], tt[9]);         // 2: j * ra
      AqdAdd(tt, 6, tt[0], tt[1], tt[2], tt[3]);   // 6: ja = r*ja + j*ra
      AqdSet(tt, 8, tt[4], tt[5]);                 // 8: ra = rt
    }
    AqdAdd(nz, m4, tt[8], tt[9], cr1, cr2);        // nz: nzr = ra + cr
    AqdAdd(nz, m4+2, tt[6], tt[7], cj1, cj2);      // nz+2: nzj = ja + cj
    AqdAbsSub(tt, 0, br1, br2, nz[m4], nz[m4+1]);  // 0: abs(nzr - br)
    AqdAbsSub(tt, 2, bj1, bj2, nz[m4+2], nz[m4+3]);// 2: abs(nzj - bj)
    AqdAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);     // 4: db = abs(nzr-br)+abs(nzj-bj)
    const db = tt[4] + tt[5]
    if (db <= this.epsilon2) {
      if (!this.pp[m]) { this.pp[m] = this.it; }
      if (db <= this.epsilon) {
        this.nn[m] = -this.it;
        if (this.inspikeQdA(cr1, cr2, cj1, cj2) && this.ch > 0) {
          this.ch -= 1;
        }
        return -1;
      }
    }
    return 0;
  }

  computePerturbation(index, cache) {
    const m4 = index * 4;
    const cr = this.cc[m4]
    const ci = this.cc[m4+1]
    const refIndex = this.cc[m4+2]
    const ri4 = refIndex * 4;
    const dr = this.zz[m4];
    const di = this.zz[m4+1];

    // Switch to quad when approaching convergence.
    if (this.nn[refIndex] || this.pp[refIndex]) return false;

    // Compute binomial powers of z
    if (cache.refIndex !== refIndex) {
      cache.refIndex = refIndex;
      const ri4 = refIndex * 4;
      const zr = this.zz[ri4];
      const zi = this.zz[ri4+2];
      this.fillBinZpow(cache.binZpow, zr, zi);
    }
    const binZpow = cache.binZpow;

    // Compute in (z+d)^n - z^n = nz^(n-1) d + (n(n-1)/2)z^(n-2) d^2...
    let r = dr;
    let i = di;
    for (let ord = 0; ord < binZpow.length; ord += 2) {
      r += binZpow[ord];
      i += binZpow[ord+1];
      const rNew = r * dr - i * di;
      i = r * di + i * dr;
      r = rNew;
    }

    // Add perturbation in c
    r += cr;
    i += ci;

    if (this.isThresholdExceeded(r, i, refIndex)) {
      return false;
    }

    this.zz[m4] = r;
    this.zz[m4+1] = i;
    return true;
  }

  fillBinZpow(binZpow, zr, zi) {
    let zrCurrent = zr, ziCurrent = zi;
    let coeff = this.config.exponent;

    for (let k = 1; k < this.config.exponent - 1; k++) {
      binZpow[k*2-2] = coeff * zrCurrent;
      binZpow[k*2-1] = coeff * ziCurrent;

      // Update z power
      const zrNew = zrCurrent * zr - ziCurrent * zi;
      ziCurrent = zrCurrent * zi + ziCurrent * zr;
      zrCurrent = zrNew;

      // Update coefficient for next iteration
      coeff *= (this.config.exponent - k) / (k + 1);
    }

    // Add the last element without computing the next z power or coefficient
    if (this.config.exponent > 1) {
      binZpow[this.config.exponent*2 - 4] = coeff * zrCurrent;
      binZpow[this.config.exponent*2 - 3] = coeff * ziCurrent;
    }
  }

  isThresholdExceeded(dr, di, refIndex) {
    const mag = Math.max(Math.abs(dr), Math.abs(di));
    if (mag > this.perturbationThreshold) return true;
    // If orbit is getting large, then be more careful.
    if (mag * 10 < this.perturbationThreshold) return false;
    const zr = this.zz[refIndex * 4];
    const zi = this.zz[refIndex * 4 + 2];
    return ((dr + zr) ** 2 + (di + zi) ** 2 > 3);
  }

  convertToQuadPrecision(index) {
    const m4 = index * 4;
    const dr = this.zz[m4];
    const di = this.zz[m4+1];
    const cr = this.cc[m4];
    const ci = this.cc[m4+1];
    const refIndex = this.cc[m4+2];
    const ri4 = refIndex * 4;
    AqdAdd(this.zz, m4, dr, 0, this.zz[ri4], this.zz[ri4+1])
    AqdAdd(this.zz, m4+2, di, 0, this.zz[ri4+2], this.zz[ri4+3])
    AqdAdd(this.cc, m4, cr, 0, this.cc[ri4], this.cc[ri4+1])
    AqdAdd(this.cc, m4+2, ci, 0, this.cc[ri4+2], this.cc[ri4+3])
  }

  initAsQuadPrecision(index, refcc) {
    const m4 = index * 4;
    const cr = this.cc[m4];
    const ci = this.cc[m4+1];
    const refIndex = this.cc[m4+2];
    const ri4 = refIndex * 4;
    AqdAdd(this.cc, m4, cr, 0, refcc[ri4], refcc[ri4+1])
    AqdAdd(this.cc, m4+2, ci, 0, refcc[ri4+2], refcc[ri4+3])
  }
}

// Single reference orbit perturbation method.
// Based on Zhuoran Li's 2021 approach: https://mathr.co.uk/blog/2021-05-14_stretching_deep_zoom.html
// Rebasing implementation follows Imagina: https://github.com/ImaginaFractal/Imagina
class ZhuoranBoard extends Board {
  constructor(k, size, re, im, config, id) {
    super(k, size, re, im, config, id);

    // Reference orbit data (quad-double precision)
    this.maxRefIterations = 10000;  // Will grow dynamically
    this.refOrbit = [];  // Array of [r_high, r_low, i_high, i_low] for each iteration
    this.refOrbitEscaped = false;
    this.refIterations = 0;  // Current length of reference orbit

    // Reference point (center of image)
    const refRe = toQd(re);
    const refIm = toQd(im);
    this.refC = [refRe[0], refRe[1], refIm[0], refIm[1]];

    // Per-pixel data (double precision)
    this.dc = [];  // Delta c from reference point [real, imag] pairs
    this.dz = [];  // Current perturbation delta [real, imag] pairs
    this.refIter = [];  // Which iteration of reference each pixel is following
    this.pixelIndexes = [];  // Active pixel indices

    // Working array for quad-double operations
    this.tt = new Array(16);

    // Initialize reference orbit with z = 0 and z = c
    this.refOrbit.push([0, 0, 0, 0]);  // Iteration 0: z = 0
    this.refOrbit.push(this.refC.slice());  // Iteration 1: z = 0^2 + c = c
    this.refIterations = 1;  // We have computed 1 iteration beyond z=0

    this.initPixels(size, re, im);
    this.effort = 2;  // Slightly lower than PerturbationBoard since simpler
  }

  initPixels(size, re, im) {
    const pix = size / this.config.dims;
    const dims = this.config.dims;
    const refRe = this.refC[0] + this.refC[1];
    const refIm = this.refC[2] + this.refC[3];

    // BUG FIX: re and im might be quad-double arrays, convert to regular doubles
    const re_double = Array.isArray(re) ? (re[0] + re[1]) : re;
    const im_double = Array.isArray(im) ? (im[0] + im[1]) : im;

    // Initialize all pixels as perturbations from the reference point
    for (let y = 0; y < dims; y++) {
      const yFrac = (0.5 - y / dims);
      const ci = im_double + yFrac * size;
      const dci = ci - refIm;

      for (let x = 0; x < dims; x++) {
        const xFrac = (x / dims - 0.5);
        const cr = re_double + xFrac * size;
        const dcr = cr - refRe;

        const index = y * dims + x;
        this.dc[index * 2] = dcr;
        this.dc[index * 2 + 1] = dci;
        // CpuBoard starts with z = c (skipping the trivial first iteration where 0^2+c=c)
        // So we start at refIter=1 where refOrbit[1] = c_ref
        // With dz = dc, we get: z = c_ref + dc = c (correct!)
        this.dz[index * 2] = dcr;
        this.dz[index * 2 + 1] = dci;
        this.refIter[index] = 1;  // Start at iteration 1 (z = c)
        this.pixelIndexes.push(index);

        // Check for spike
        if (this.inspike(cr, ci)) {
          this.ch += 1;
        }
      }
    }
  }

  static fromSerialized(serialized) {
    const board = new ZhuoranBoard(
      serialized.k,
      serialized.sizes[0],
      serialized.sizes[1],
      serialized.sizes[2],
      serialized.config,
      serialized.id
    );

    // Restore state
    Object.assign(board, serialized);
    return board;
  }

  serialize() {
    return {
      ...super.serialize(),
      refOrbit: this.refOrbit,
      refOrbitEscaped: this.refOrbitEscaped,
      refIterations: this.refIterations,
      refC: this.refC,
      dc: this.dc,
      dz: this.dz,
      refIter: this.refIter,
      pixelIndexes: this.pixelIndexes
    };
  }

  iterate() {
    let changes = null;

    // Step 1: Extend reference orbit if needed and not escaped
    // Find the maximum refIter among all active pixels
    let maxRefIter = 0;
    for (const index of this.pixelIndexes) {
      if (!this.nn[index] && this.refIter[index] > maxRefIter) {
        maxRefIter = this.refIter[index];
      }
    }

    // Extend reference orbit to cover all active pixels plus a buffer
    const targetRefIterations = Math.max(this.it + 100, maxRefIter + 100);

    while (!this.refOrbitEscaped && this.refIterations < targetRefIterations) {
      this.extendReferenceOrbit();
    }

    // Step 2: Iterate all active pixels using perturbation
    const newPixelIndexes = [];
    for (const index of this.pixelIndexes) {
      if (this.nn[index]) continue;  // Skip finished pixels

      const result = this.iteratePixel(index);

      if (result !== 0) {
        if (!changes) {
          changes = { iter: this.it, nn: [], vv: [] };
        }

        if (result > 0) {
          // Diverged
          changes.nn.push(index);
          this.nn[index] = this.it;
          this.di += 1;
          this.un -= 1;
        } else {
          // Converged
          const index2 = index * 2;
          changes.vv.push({
            index: index,
            z: [this.dz[index2] + this.getCurrentRefZ(index)[0],
                this.dz[index2 + 1] + this.getCurrentRefZ(index)[2]],
            p: this.pp[index]
          });
          this.nn[index] = -this.it;
          this.un -= 1;

          if (this.inspike(
            this.dc[index2] + this.refC[0] + this.refC[1],
            this.dc[index2 + 1] + this.refC[2] + this.refC[3]
          ) && this.ch > 0) {
            this.ch -= 1;
          }
        }
      } else {
        newPixelIndexes.push(index);
      }
    }

    this.pixelIndexes = newPixelIndexes;

    // Compact if needed
    if (this.pixelIndexes.length > this.un * 1.25) {
      this.pixelIndexes = this.pixelIndexes.filter(i => !this.nn[i]);
    }

    this.it++;
    this.queueChanges(changes);
  }

  extendReferenceOrbit() {
    // Compute one more iteration of the reference orbit in quad-double precision
    const lastIndex = this.refIterations;
    const last = this.refOrbit[lastIndex];
    const tt = this.tt;

    const r1 = last[0];
    const r2 = last[1];
    const j1 = last[2];
    const j2 = last[3];

    // Check for escape
    AqdSquare(tt, 0, r1, r2);                    // rsq = r**2
    AqdSquare(tt, 2, j1, j2);                    // jsq = j**2
    AqdAdd(tt, 4, tt[0], tt[1], tt[2], tt[3]);   // d = rsq + jsq

    // tt[4] is the high part of the magnitude squared (tt[5] is just the low correction)
    // Use larger escape radius (256) for numerical stability, matching pixel escape threshold
    if (tt[4] > 256) {
      this.refOrbitEscaped = true;
      return;
    }

    // Compute z^n for general exponent
    AqdMul(tt, 6, 2 * r1, 2 * r2, j1, j2);       // ja = 2*r*j
    AqdAdd(tt, 8, tt[0], tt[1], -tt[2], -tt[3]); // ra = rsq - jsq

    for (let ord = 2; ord < this.config.exponent; ord++) {
      AqdMul(tt, 0, j1, j2, tt[6], tt[7]);         // j * ja
      AqdMul(tt, 2, r1, r2, tt[8], tt[9]);         // r * ra
      AqdAdd(tt, 4, -tt[0], -tt[1], tt[2], tt[3]); // rt = r*ra - j*ja
      AqdMul(tt, 0, r1, r2, tt[6], tt[7]);         // r * ja
      AqdMul(tt, 2, j1, j2, tt[8], tt[9]);         // j * ra
      AqdAdd(tt, 6, tt[0], tt[1], tt[2], tt[3]);   // ja = r*ja + j*ra
      AqdSet(tt, 8, tt[4], tt[5]);                 // ra = rt
    }

    // Add c to get next z
    const newZ = [0, 0, 0, 0];
    AqdAdd(newZ, 0, tt[8], tt[9], this.refC[0], this.refC[1]);      // real part
    AqdAdd(newZ, 2, tt[6], tt[7], this.refC[2], this.refC[3]);      // imag part

    this.refOrbit.push(newZ);
    this.refIterations++;

    // Grow array if needed
    if (this.refIterations >= this.maxRefIterations) {
      this.maxRefIterations *= 2;
    }
  }

  iteratePixel(index) {
    const index2 = index * 2;
    let refIter = this.refIter[index];

    // Ensure reference orbit exists for this iteration
    if (refIter >= this.refOrbit.length) {
      // Need more reference orbit iterations
      if (this.refOrbitEscaped) {

        // Reference has escaped, can't extend further
        // Imagina's approach: Rebase to beginning of reference orbit
        // This allows continued use of perturbation theory

        // Get current z value
        const lastRef = this.refOrbit[this.refOrbit.length - 1];
        const lastRefR = lastRef[0] + lastRef[1];
        const lastRefI = lastRef[2] + lastRef[3];
        const dr = this.dz[index2];
        const di = this.dz[index2 + 1];

        // Set dz to current total position (Imagina's VecResetAndSync)
        this.dz[index2] = lastRefR + dr;
        this.dz[index2 + 1] = lastRefI + di;

        // Restart from iteration 0 (where z_ref = 0)
        this.refIter[index] = 0;
        refIter = 0;

        // Continue with perturbation iteration from the top
        // (don't return, fall through to normal iteration code below)
      } else {
        // This shouldn't happen with proper reference orbit extension
        console.warn(`Pixel ${index} needs refIter ${refIter} but orbit length is ${this.refOrbit.length}`);
        return 1;  // Mark as diverged only if unexpected
      }
    }

    // Check if we need to rebase (Zhuoran's key innovation)
    if (this.shouldRebase(index)) {
      // Imagina's rebasing: set dz = z_total and restart from refIter = 0
      const ref = this.refOrbit[refIter];
      const refR = ref[0] + ref[1];
      const refI = ref[2] + ref[3];
      const dr = this.dz[index2];
      const di = this.dz[index2 + 1];

      // Set dz to current total position (z_ref + dz)
      this.dz[index2] = refR + dr;
      this.dz[index2 + 1] = refI + di;

      // Restart from iteration 0 (where z_ref = 0)
      this.refIter[index] = 0;
      refIter = 0;
    }

    // Get reference orbit value for current iteration
    const ref = this.refOrbit[refIter];
    if (!ref) {
      // Safety check - this shouldn't happen with the fix above
      console.error(`Missing reference orbit at iteration ${refIter}`);
      return 0;
    }
    const refR = ref[0] + ref[1];  // Convert quad to double
    const refI = ref[2] + ref[3];

    // Perturbation iteration: dz = 2 * dz * z_ref + dz^2 + dc
    const dr = this.dz[index2];
    const di = this.dz[index2 + 1];

    // Compute dz^2
    const dzSqR = dr * dr - di * di;
    const dzSqI = 2 * dr * di;

    // Compute 2 * dz * z_ref
    const twoZrefDzR = 2 * (dr * refR - di * refI);
    const twoZrefDzI = 2 * (dr * refI + di * refR);

    // New dz = 2 * dz * z_ref + dz^2 + dc
    const newDr = twoZrefDzR + dzSqR + this.dc[index2];
    const newDi = twoZrefDzI + dzSqI + this.dc[index2 + 1];

    // Update dz first before checking divergence
    this.dz[index2] = newDr;
    this.dz[index2 + 1] = newDi;

    // Now check for divergence with the updated values
    // Use larger escape radius (256 instead of 4) for numerical stability with perturbation theory
    // This prevents artifacts near the boundary due to floating-point errors
    const totalR = refR + newDr;
    const totalI = refI + newDi;
    const totalMag2 = totalR * totalR + totalI * totalI;

    if (totalMag2 > 256) {
      return 1;  // Diverged
    }

    // Check for convergence using the same pattern as CpuBoard
    // Note: we're using the updated dz values that we just stored
    if (figurePeriod(this.it) == 1) {
      if (!this.bb[index2]) {
        this.bb[index2] = this.dz[index2];
        this.bb[index2 + 1] = this.dz[index2 + 1];
        this.pp[index] = 0;
      } else {
        const db = Math.abs(this.dz[index2] - this.bb[index2]) + Math.abs(this.dz[index2 + 1] - this.bb[index2 + 1]);
        if (db <= this.epsilon2) {
          if (!this.pp[index]) {
            this.pp[index] = this.it;
          }
          if (db <= this.epsilon) {
            return -1;  // Converged
          }
        }
        this.bb[index2] = this.dz[index2];
        this.bb[index2 + 1] = this.dz[index2 + 1];
      }
    }

    // Update reference iteration counter (dz was already updated above)
    this.refIter[index]++;

    return 0;  // Continue iterating
  }

  shouldRebase(index) {
    // Zhuoran's rebasing condition (from Imagina):
    // Rebase when |z_total| < |dz| * threshold
    // This detects when we're near the critical point (0 for Mandelbrot)
    const index2 = index * 2;
    const dr = this.dz[index2];
    const di = this.dz[index2 + 1];
    const dzMag = dr * dr + di * di;

    const refIter = this.refIter[index];

    // Don't rebase if we're already at iteration 0 (start of reference orbit)
    if (refIter === 0) {
      return false;
    }

    // Check if reference orbit exists for this iteration
    if (refIter >= this.refOrbit.length || !this.refOrbit[refIter]) {
      return false; // Can't check, don't rebase
    }

    const ref = this.refOrbit[refIter];
    const refR = ref[0] + ref[1];
    const refI = ref[2] + ref[3];

    // Compute z_total = z_ref + dz
    const totalR = refR + dr;
    const totalI = refI + di;
    const totalMag = totalR * totalR + totalI * totalI;

    // Rebase when orbit approaches critical point (0)
    // Threshold slightly above 1.0 for numerical stability
    const rebaseThreshold = 1.000001;

    return totalMag < dzMag * rebaseThreshold;
  }

  getCurrentRefZ(index) {
    const refIter = this.refIter[index];
    if (refIter <= this.refIterations && this.refOrbit[refIter]) {
      return this.refOrbit[refIter];
    }
    return [0, 0, 0, 0];
  }
}

function workerLog(message) {
  self.postMessage({
    type: 'log',
    data: message
  });
}

const workerName = self.name;
const boards = new Map();
let hiddenBoards = new Set();
let focusedBoardK = null;
let computationPaused = false;
let steps = 0;
let startTime = 0;
let endTime = -1;
let timer = null;

self.onmessage = function(e) {
  const { type, data } = e.data;
  switch (type) {
    case 'addBoard':
      workerNumber = data.workerNumber;
      const useZhuoranApproach = true;

      const board = data.size / data.config.dims < 1e-15
        ? (useZhuoranApproach
            ? new ZhuoranBoard(data.k, data.size, data.re, data.im, data.config, data.id)
            : new PerturbationBoard(data.k, data.size, data.re, data.im, data.config, data.id))
        : new CpuBoard(data.k, data.size, data.re, data.im, data.config, data.id);

      boards.set(data.k, board);
      console.log(`View ${data.k}: ${board.constructor.name}`);
      break;
    case 'removeBoard':
      boards.delete(data.k);
      break;
    case 'setFocusedBoard':
      focusedBoardK = data.k;
      break;
    case 'setHiddenBoards':
      hiddenBoards = new Set(data.hiddenBoards);
      break;
    case 'requestTransfer':
      const transferredBoards = [];
      for (const k of data.boardKeys) {
        if (boards.has(k)) {
          const board = boards.get(k);
          board.compact();
          const serializedBoard = board.serialize();
          boards.delete(k);
          transferredBoards.push(serializedBoard);
        }
      }
      // Send the serialized boards back to the scheduler
      self.postMessage({
        type: 'downloadTransfer',
        data: { transferredBoards }
      });
      break;
    case 'uploadTransfer':
      // Recreate the board from the serialized data and add it to this worker
      const newBoard = Board.fromSerialized(data.boardData);
      boards.set(newBoard.k, newBoard);
      break;
    case 'pause':
      computationPaused = data.pause;
      break;
  }
  if (!timer && boards.size && !computationPaused) {
    iterateBoards();
  } else {
    const remainingWork = Array.from(boards.values()).
        filter(board => !hiddenBoards.has(board.k)).
        map(b => b.unfinished() * b.effort).reduce((a, b) => a + b, 0);
    self.postMessage({
      type: 'update',
      data: {
        remainingWork,
      }
    });
  }
};

function iterateBoards() {
  timer = null;
  if (computationPaused) {
    return;
  }
  let pri = Array.from(boards.values())
        .filter(board => (board.unfinished() || board.updateSize))
        .filter(board => !hiddenBoards.has(board.k));
  if (pri.length) {
    // Start timer if it is not already running.
    if (endTime) {
      startTime = (new Date).getTime();
      endTime = 0;
    }
    if (steps % 2) {
      // Prioritize most unfinished half the time.
      pri = pri.sort((a, b) => b.unfinished() - a.unfinished());
    } else {
      // Prioritize the most recent half the time.
      pri = pri.sort((a, b) => b.k - a.k);
      // Allow the user to prioritize by pointing the mouse.
      if (focusedBoardK !== null) {
        pri.sort((a, b) => (a.k === focusedBoardK ? -1 : b.k === focusedBoardK ? 1 : 0));
      }
    }
    // Exponential scheduling policy
    let shift = Math.floor(steps++ / 2) + 1;
    let p = 0;
    while (shift & (1 << p)) { p += 1; }
    const board = pri[Math.min(p, pri.length) % pri.length];
    for (let workDone = 0; workDone < 17377 && board.unfinished(); ) {
      workDone += board.un * board.effort;
      // Iterate the board and process any changes
      // Note: updates the board's changeList and updateSize
      board.iterate();
    }
    const now = (new Date()).getTime();
    if (focusedBoardK == board.k ?
        (board.updateSize >= 1429 || now - board.lastTime >= 100) :
        (board.updateSize >= 4673 || now - board.lastTime >= 500)) {
      const boardEffort = board.unfinished() * board.effort;
      const remainingWork = pri.map(b => b.unfinished() * b.effort).reduce((a, b) => a + b, 0);
      const workerInfo = `${workerName}: ` + (board.unfinished() ?
           `boards {${[...boards.keys()]}}, work: ${remainingWork}` :
           `board finished`);
      self.postMessage({
        type: 'iterations',
        data: {
          k: board.k,
          id: board.id,
          it: board.it,
          un: board.un,
          di: board.di,
          ch: board.ch,
          changeList: board.changeList,
          boardEffort,
          remainingWork,
          workerInfo
        }
      });
      board.lastTime = now;
      board.updateSize = 0;
      board.changeList = [];
      if (!board.unfinished()) {
        // Delete board when done.
        boards.delete(board.k);
        // workerLog(`Board ${board.k} finished, leaving {${[...boards.keys()]}}`);
      }
    }
  } else {
    // End timer when there is no remaining work
    if (!endTime) {
       endTime = (new Date).getTime();
       // workerLog(`Finished in ${((endTime - startTime) / 1000).toFixed(3)}s`);
    }
    return;
  }
  timer = setTimeout(iterateBoards, 0);
}

</script>

<script>
const testLocations = {
  deep: {
    name: "Deep zoom (1e-13)",
    re: -0.7325494582388732,
    im: 0.24145866660812834,
    size: 7.86432e-13
  },
  verydeep: {
    name: "Very deep zoom (1e-16)",
    re: -0.7325494582388732,
    im: 0.24145866660812834,
    size: 1e-16
  },
  extreme: {
    name: "Extreme deep zoom (1e-20)",
    re: -0.7325494582388732,
    im: 0.24145866660812834,
    size: 1e-20
  }
};

const config = {
  dims: 128,
  dims2: 128 * 128,
  exponent: 2,
  unknownColor: 0,
  colorTheme: 0
};

function benchmarkBoard(BoardClass, location, maxIterations = 1000) {
  const startTime = performance.now();

  const board = new BoardClass(
    0,
    location.size,
    location.re,
    location.im,
    config,
    'benchmark'
  );

  const initTime = performance.now() - startTime;

  let iterations = 0;
  let totalIterTime = 0;

  const iterStartTime = performance.now();

  while (iterations < maxIterations && board.unfinished() > 0) {
    const iterStart = performance.now();
    board.iterate();
    totalIterTime += performance.now() - iterStart;
    iterations++;
  }

  const totalTime = performance.now() - iterStartTime;

  return {
    boardType: BoardClass.name,
    initTime,
    iterations,
    totalIterTime,
    totalTime,
    avgIterTime: totalIterTime / iterations,
    unfinished: board.unfinished(),
    diverged: board.di,
    converged: config.dims2 - board.un - board.di
  };
}

function formatTime(ms) {
  if (ms >= 1000) return `${(ms/1000).toFixed(2)}s`;
  return `${ms.toFixed(1)}ms`;
}

function runBenchmark(locKey) {
  const location = testLocations[locKey];
  const status = document.getElementById('status');

  status.textContent = `Running PerturbationBoard for ${location.name}...`;

  setTimeout(() => {
    const pertResult = benchmarkBoard(PerturbationBoard, location);
    status.textContent = `Running ZhuoranBoard for ${location.name}...`;

    setTimeout(() => {
      const zhuoranResult = benchmarkBoard(ZhuoranBoard, location);

      displayResults(location, pertResult, zhuoranResult);
      status.textContent = 'Benchmark complete!';
    }, 10);
  }, 10);
}

function displayResults(location, pertResult, zhuoranResult) {
  const resultsDiv = document.getElementById('results');

  let html = `<div class="results">`;
  html += `<h3>${location.name}</h3>`;
  html += `<div>Center: (${location.re}, ${location.im})</div>`;
  html += `<div>Size: ${location.size.toExponential(2)}</div>`;
  html += `<div>Grid: ${config.dims}x${config.dims} (${config.dims2} pixels)</div>`;

  html += `<table>`;
  html += `<tr><th>Metric</th><th>PerturbationBoard</th><th>ZhuoranBoard</th><th>Winner</th></tr>`;

  const metrics = [
    ['Init time', 'initTime', true],
    ['Total iterations', 'iterations', false],
    ['Total iteration time', 'totalIterTime', true],
    ['Avg time per iteration', 'avgIterTime', true],
    ['Total time', 'totalTime', true],
    ['Pixels diverged', 'diverged', false],
    ['Pixels unfinished', 'unfinished', false]
  ];

  for (const [label, key, isTime] of metrics) {
    const pertVal = pertResult[key];
    const zhuoranVal = zhuoranResult[key];

    let pertStr, zhuoranStr, winner, winnerClass;

    if (isTime) {
      pertStr = formatTime(pertVal);
      zhuoranStr = formatTime(zhuoranVal);
      const diff = Math.abs(pertVal - zhuoranVal) / Math.min(pertVal, zhuoranVal);
      if (diff < 0.05) {
        winner = 'Tie';
        winnerClass = 'tie';
      } else {
        winner = pertVal < zhuoranVal ? 'Perturbation' : 'Zhuoran';
        winnerClass = 'winner';
      }
    } else {
      pertStr = pertVal.toString();
      zhuoranStr = zhuoranVal.toString();
      winner = pertVal === zhuoranVal ? 'Tie' : (pertVal < zhuoranVal ? 'Perturbation' : 'Zhuoran');
      winnerClass = pertVal === zhuoranVal ? 'tie' : 'winner';
    }

    html += `<tr><td>${label}</td><td>${pertStr}</td><td>${zhuoranStr}</td><td class="${winnerClass}">${winner}</td></tr>`;
  }

  html += `</table>`;

  const speedup = pertResult.totalTime / zhuoranResult.totalTime;
  if (speedup > 1.05) {
    html += `<div class="winner"> ZhuoranBoard is ${speedup.toFixed(2)}x faster</div>`;
  } else if (speedup < 0.95) {
    html += `<div class="winner"> PerturbationBoard is ${(1/speedup).toFixed(2)}x faster</div>`;
  } else {
    html += `<div class="tie">  Similar performance (${speedup.toFixed(2)}x)</div>`;
  }

  html += `</div>`;

  resultsDiv.innerHTML = html + resultsDiv.innerHTML;
}

function runAllBenchmarks() {
  const keys = ['deep', 'verydeep', 'extreme'];
  let index = 0;

  function runNext() {
    if (index < keys.length) {
      runBenchmark(keys[index]);
      index++;
      setTimeout(runNext, 100);
    }
  }

  runNext();
}
</script>

</body>
</html>
